//---------------------------------------------------------------------------------------------
// Probius Tactical
//---------------------------------------------------------------------------------------------

// Abilities and Behaviors
const string c_AB_DisruptionPulse                               = "ProbiusDisruptionPulse";
const string c_AB_WarpRift                                      = "ProbiusWarpRift";
const string c_AB_PhotonCannon                                  = "ProbiusPhotonCannon";
const string c_AB_WarpInPylon                                   = "ProbiusWarpInPylon";
const string c_AB_WorkerRush                                    = "ProbiusWorkerRush";
const string c_AB_PylonOvercharge                               = "ProbiusPylonOvercharge";
const string c_AB_NullGate                                      = "ProbiusNullGate";
const string c_ProbiusPowerUserEnergyRegen                      = "ProbiusPowerUserEnergyRegen";

// Talents and modifiers
const string c_ProbiusPylonOverchargeTalent                     = "ProbiusPylonOverchargeHeroic";

// Range, Radius, Misc Variables
const fixed c_ProbiusVisionRadius                               = 12.0;
const fixed c_ProbiusLowEnergy                                  = 10.0;
const fixed c_ProbiusDisruptionPulseRange                       = 10.0;
const fixed c_ProbiusDisruptionPulseRangeSquared                = 100.0;
const fixed c_ProbiusWarpRiftCastRange                          = 6.0;
const fixed c_ProbiusWarpRiftDetonationRadius                   = 3.0;
const fixed c_ProbiusWarpInPylonPlacementDistance               = 4.0;
const fixed c_ProbiusWarpInPylonShrubSearchDistance             = 6.0;
const fixed c_ProbiusPhotonCannonAttackRange                    = 6.0;
const fixed c_ProbiusPylonOverchargeAttackRange                 = 15.0;
const int c_ProbiusPylonOverchargeMinPylonCount                 = 2;
const fixed c_ProbiusPylonOverchargeAttackRangeSquared          = 225.0;
const fixed c_ProbiusNullGateCastRange                          = 7.5;
const fixed c_ProbiusNullGateVectorRange                        = 8.25;

//-------------------------------------------------------------------------------------------------
unit ProbiusGetWarpRiftUnit (int player, unit aiUnit, unitgroup scanGroup) {
    // returns the most appropriate Warprift unit to target for detonation for
    // Q W combo.
    point warpRiftPosition;
    point casterPosition;
    unit itWarpRiftUnit;
    unit bestWarpRiftUnit;
    unitgroup warpRiftUnitGroup;
    unitgroup structuresNearWarpRift;
    unitgroup warpRiftDetonationGroup;
    int i;
    int warpRiftsCount;
    int heroUnitsCount;
    int nonHeroUnitsCount;
    int bestHeroesCount;
    int bestNonHeroesCount;

    warpRiftUnitGroup = libHPRO_gv_heroProbiusWarpRifts[player];
    warpRiftsCount = UnitGroupCount(warpRiftUnitGroup, c_unitCountAll);
    // out early if there aren't any warprift units
    if (warpRiftsCount == 0) {
        return bestWarpRiftUnit;
    }

    // for each unit in libHPRO_gv_heroProbiusWarpRifts
    for (i = 1; i <= warpRiftsCount; i += 1) {
        itWarpRiftUnit = UnitGroupUnit(warpRiftUnitGroup, i);
        if (!UnitIsValid(itWarpRiftUnit)) {
            continue;
        }
        warpRiftPosition = UnitGetPosition(itWarpRiftUnit);
        casterPosition = UnitGetPosition(aiUnit);
        warpRiftDetonationGroup = UnitsInArea(scanGroup, warpRiftPosition, c_ProbiusWarpRiftDetonationRadius);
        // make sure there are enough units in the detonation radius
        if (DistanceSquaredBetweenPoints(casterPosition, warpRiftPosition) < c_ProbiusDisruptionPulseRangeSquared) {
            // make sure we are in range of this warp rift unit to detonate
            if (EnoughEnemiesInArea(warpRiftDetonationGroup, warpRiftPosition, c_ProbiusWarpRiftDetonationRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast2Minions)) {
                // set best warp rift unit incase we don't find enough heroes
                // but did find enough non-hero targets
                nonHeroUnitsCount = CountMinionsInGroup(warpRiftDetonationGroup) + CountCreepsInGroup(warpRiftDetonationGroup);
                if (bestHeroesCount == 0
                 && nonHeroUnitsCount > bestNonHeroesCount) {
                    bestNonHeroesCount = nonHeroUnitsCount;
                    bestWarpRiftUnit = itWarpRiftUnit;
                }
                // We need to now see if this is the best rift to detonate based
                // on number of Heroes it will hit
                heroUnitsCount = CountHeroesInGroup(warpRiftDetonationGroup);
                if (heroUnitsCount > bestHeroesCount) {
                    bestHeroesCount = heroUnitsCount;
                    bestWarpRiftUnit = itWarpRiftUnit;
                }
            }
            // if we fail to satisfy unit count conditions, check to see if there is a tower.
            // But only consider a rift with a structure in its blast radius to be best rift
            // if we haven't previously found a rift with heroes in the blast radius.
            else if (bestWarpRiftUnit == null) {
                    structuresNearWarpRift = UnitGroupFilterTowers(UnitsInArea(warpRiftDetonationGroup, warpRiftPosition, c_ProbiusWarpRiftDetonationRadius));
                    if (UnitGroupCount(structuresNearWarpRift, c_unitCountAll) > 0) {
                        bestWarpRiftUnit = itWarpRiftUnit;
                    }
            }
        }
    }

    return bestWarpRiftUnit;
}

//-------------------------------------------------------------------------------------------------
bool ProbiusDisruptionPulse (int player, unit aiUnit, unitgroup scanGroup) {
    // Line skill shot that pierces target.
    // Will detonate armed Warprifts.
    order spellOrd;
    unit targetEnemy;
    unit warpRiftUnit;
    bool issueOrder;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DisruptionPulse, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // if we can find a good warprift as a target, cast the ability at that location.
    warpRiftUnit = ProbiusGetWarpRiftUnit(player, aiUnit, scanGroup);
    if (UnitIsValid(warpRiftUnit)) {
        issueOrder = HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(warpRiftUnit));
        // we don't want this ability to cause lower difficulty cooldown handicap
        libAIAI_gv_aIHeroes[player].lv_nextOffensiveSpellCheckTime = 0.0;
        return issueOrder;
    }

    // Prefer close, weak enemy hero
    query.lv_maxDistance = c_ProbiusDisruptionPulseRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;

    // Find weak hero
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // if no hero found, find a minion
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        // No minion, can we cast on a tower?
        if (!UnitIsValid(targetEnemy)) {
            targetEnemy = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
            if (targetEnemy != null) {
                issueOrder = HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
                libAIAI_gv_aIHeroes[player].lv_nextOffensiveSpellCheckTime = 0.0;
                return issueOrder;
            }
            return false;
        }
    }
    issueOrder = HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
    // I am intentionally resetting SpellCheckTime because Probius is rather
    // useless without his abilities. - KGu
    libAIAI_gv_aIHeroes[player].lv_nextOffensiveSpellCheckTime = 0.0;
    return issueOrder;
}

//-------------------------------------------------------------------------------------------------
bool ProbiusWarpRift (int player, unit aiUnit, unitgroup scanGroup) {
    // Create a bomb at target location that has an arming delay and slows
    // enemies in a radius around the bomb.
    // Can be hit with Q Disruption Pulse to detonate the bomb and deal AoE
    // damage centered on the bomb.
    order spellOrd;
    unit targetEnemy;
    point targetEnemyPosition;
    point playerPosition;
    point targetTowerPosition;
    bool issueOrder;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_WarpRift, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Prefer close, weak enemy hero
    query.lv_maxDistance = c_ProbiusWarpRiftCastRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;

    // Find weak hero
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // if no hero found, find a minion
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        // No minion, can we cast on a tower?
        if (!UnitIsValid(targetEnemy)) {
            targetEnemy = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
            if (targetEnemy != null) {
                issueOrder = HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
                // we don't want this ability to cause lower difficulty cooldown handicap
                libAIAI_gv_aIHeroes[player].lv_nextOffensiveSpellCheckTime = 0.0;
                return issueOrder;
            }
            return false;
        }
    }
    issueOrder = HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
    // I am intentionally resetting SpellCheckTime because Probius is rather
    // useless without his abilities. - KGu
    libAIAI_gv_aIHeroes[player].lv_nextOffensiveSpellCheckTime = 0.0;
    return issueOrder;
}

//-------------------------------------------------------------------------------------------------
bool ProbiusPhotonCannon (int player, unit aiUnit, unitgroup scanGroup) {
    // place a static turret with a finite duration that shoots enemies
    // Don't fudge placement position.
    order spellOrd;
    point pos;
    bool issueOrder;

    spellOrd = StormHeroAICreateOrder(player, c_AB_PhotonCannon, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // only consider using if we are powered
    if (!UnitHasBehavior(aiUnit, c_ProbiusPowerUserEnergyRegen)) {
        return false;
    }

    pos = UnitGetPosition(aiUnit);
    if (!AnyEnemiesInArea(scanGroup, pos, c_ProbiusPhotonCannonAttackRange)) {
        return false;
    }
    OrderSetTargetPoint(spellOrd, pos);
    return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
}

//-------------------------------------------------------------------------------------------------
bool ProbiusWarpInPylon (int player, unit aiUnit, unitgroup scanGroup) {
    // create a pylon that gives Probius mana regeneration
    // no fudging of placement postion
    order spellOrd;
    fixed energy;
    point shrubPosition;
    point pos;

    spellOrd = StormHeroAICreateOrder(player, c_AB_WarpInPylon, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    pos = UnitGetPosition(aiUnit);
    energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    // if we are running on fumes, just drop a pylon where we are to recharge a bit
    if (energy < c_ProbiusLowEnergy) {
        OrderSetTargetPoint(spellOrd, pos);
        return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    }

    // if overcharge is off cooldown, and there's a teamfight, use right here to get an extra pylon
    if (PlayerHasTalent(player, c_ProbiusPylonOverchargeTalent)
    && !libCore_gf_IsAbilityOnCooldown(aiUnit, c_AB_PylonOvercharge)
    && TeamFightInArea(player, scanGroup, pos, c_Storm_AI_DefaultTeamfightRange)) {
        OrderSetTargetPoint(spellOrd, pos);
        return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    }

    // don't use if there are no units near us (we are traveling between lanes)
    if (!EnoughEnemiesInArea(scanGroup, pos, c_ProbiusVisionRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast1Minion)) {
        return false;
    }

    // if we are already powered, don't place another
    if (UnitHasBehavior(aiUnit, c_ProbiusPowerUserEnergyRegen)) {
        return false;
    }

    // if we are on enemy territory search for a shrub behind us at retreat point
    if (TowardFarSideOfTheMap(player, aiUnit)) {
        pos = libAIAI_gf_HeroAIGetRetreatPosition(player, c_ProbiusWarpInPylonShrubSearchDistance, null);
    }

    // find nearest shrub
    shrubPosition = FindClosestShrub(pos, c_ProbiusWarpInPylonShrubSearchDistance);

    // if shrub point is not valid (we couldn't find a shrub close enough)
    if (shrubPosition == null) {
        pos = libAIAI_gf_HeroAIGetRetreatPosition(player, c_ProbiusWarpInPylonPlacementDistance, null);
        HeroClaimForTactical(player, 1.0, true);
        OrderSetTargetPoint(spellOrd, pos);
        return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    }

    HeroClaimForTactical(player, 2.0, true);
    OrderSetTargetPoint(spellOrd, shrubPosition);
    return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
}

//-------------------------------------------------------------------------------------------------
bool ProbiusWorkerRush (int player, unit aiUnit, unitgroup scanGroup) {
    // Gives Probius a boost of speed for a duration, removed early if he takes
    // damage.
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_WorkerRush, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // use if we are low on health, or we are returning to lane
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth
    || libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSReturnToLane) {
        return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    }

    return false;
}

//-------------------------------------------------------------------------------------------------
int ProbiusGetPylonsInRangeCount (int player, unit aiUnit) {
    // returns the number of pylons within range of probius
    int pylonsInRange;
    int pylonCount;
    unit pylonUnit;
    point pylonPosition;
    point playerPosition;
    unitgroup pylonUnitGroup;
    int i;

    pylonUnitGroup = libHPRO_gv_heroProbiusWarpInPylonPylonGroup[player];
    pylonCount = UnitGroupCount(pylonUnitGroup, c_unitCountAll);
    playerPosition = UnitGetPosition(aiUnit);
    for (i = 1; i <= pylonCount; i += 1) {
        pylonUnit = UnitGroupUnit(pylonUnitGroup, i);
        pylonPosition = UnitGetPosition(pylonUnit);
        if (DistanceSquaredBetweenPoints(pylonPosition, playerPosition) < c_ProbiusPylonOverchargeAttackRangeSquared) {
            pylonsInRange += 1;
        }
    }

    return pylonsInRange;
}

//-------------------------------------------------------------------------------------------------
bool ProbiusPylonOvercharge (int player, unit aiUnit, unitgroup scanGroup) {
    // Empoweres all pylons on the map and allows them to attack enemies
    // in a large area around the pylons.
    order spellOrd;
    point playerPoint;

    spellOrd = StormHeroAICreateOrder(player, c_AB_PylonOvercharge, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    playerPoint = UnitGetPosition(aiUnit);
    // teamfight nearby?
    if (!TeamFightInArea(player, scanGroup, playerPoint, c_Storm_AI_DefaultTeamfightRange)){
        return false;
    }

    // are there at least 2 pylons on the map?
    if (UnitGroupCount(libHPRO_gv_heroProbiusWarpInPylonPylonGroup[player], c_unitCountAll) < c_ProbiusPylonOverchargeMinPylonCount) {
         return false;
    }
    // are they near us?
    if (ProbiusGetPylonsInRangeCount(player, aiUnit) < c_ProbiusPylonOverchargeMinPylonCount) {
        return false;
    }

    return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
}

//-------------------------------------------------------------------------------------------------
bool ProbiusNullGate (int player, unit aiUnit, unitgroup scanGroup) {
    // creates two vector targeted gates that damages and slows enemies who walk
    // between the gates.
    // No order position fudging.
    order spellOrd;
    point vectorStartPoint;
    point vectorEndPoint;
    point targetPos;
    unit targetEnemy;
    unitgroup scanGroupHeroes;
    unitgroup newScanGroup;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NullGate, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // find a weak hero as our primary target
    query.lv_maxDistance = c_ProbiusNullGateCastRange;
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;

    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    // there is a valid target so build a new unit group for targeting

    // Make a new scan group where target enemy is the first unit in the scan group
    // This is used by AIBestAttackVectorStart
    scanGroupHeroes = UnitGroupFilterHeroes(scanGroup);
    newScanGroup = libNtve_gf_ConvertUnitToUnitGroup(targetEnemy);
    UnitGroupAddUnitGroup(newScanGroup, scanGroupHeroes);

    // if there's only 1 hero in range try to hit as many non-hero units as possible
    if (CountHeroesInGroup(newScanGroup) <= 1) {
        // modify newScanGroup to include minions
        // our target needs to be the first unit in the unitgroup
        UnitGroupAddUnitGroup(newScanGroup, scanGroup);

        // if there are no minions nearby use target facing
        // Make sure we have at least 2 targets for AIBestAttackVectorStart
        if (CountMinionsInGroup(newScanGroup) <= 0) {
            targetPos = UnitGetPosition(targetEnemy);
            OrderSetTargetPoint(spellOrd, targetPos);
            vectorEndPoint = LeadPoint(null, targetPos, targetEnemy, c_ProbiusNullGateVectorRange, true, false);
            OrderSetVectorPoint(spellOrd, vectorEndPoint);

            return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueAddToFront);
        }
    }

    // newScanGroup is either hero units only, or also includes minions
    vectorStartPoint = AIBestAttackVectorStart(newScanGroup, UnitGetPosition(aiUnit), c_ProbiusNullGateCastRange, c_ProbiusNullGateVectorRange, 0);
    OrderSetTargetPoint(spellOrd, vectorStartPoint);

    // Don't use AIBestAttackVectorEnd() since we need to clamp the end point to a certain distance
    vectorEndPoint = PointWithOffsetPolar(vectorStartPoint, c_ProbiusNullGateVectorRange, PointGetFacing(vectorStartPoint));
    OrderSetVectorPoint(spellOrd, vectorEndPoint);

    return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueAddToFront);
}

//-------------------------------------------------------------------------------------------------
void AIThinkProbius (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (ProbiusWarpInPylon(player, aiUnit, scanGroup)) {
        return;
    }

    if (ProbiusPhotonCannon(player, aiUnit, scanGroup)) {
        return;
    }

    if (ProbiusWarpRift(player, aiUnit, scanGroup)) {
        return;
    }

    if (ProbiusDisruptionPulse(player, aiUnit, scanGroup)) {
        return;
    }

    if (ProbiusWorkerRush(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player)) {
        if (ProbiusPylonOvercharge(player, aiUnit, scanGroup)) {
            return;
        }

        if (ProbiusNullGate(player, aiUnit, scanGroup)) {
            return;
        }
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}
