//---------------------------------------------------------------------------------------------
// Alarak Tactical
//---------------------------------------------------------------------------------------------

// Abilities and Behaviors
const string c_AB_AlarakDiscordStrike                       = "AlarakDiscordStrike";
const string c_AB_AlarakTelekinesis                         = "AlarakTelekinesis";
const string c_AB_AlarakLightningSurge                      = "AlarakLightningSurge";
const string c_AB_AlarakDeadlyCharge                        = "AlarakDeadlyCharge";
const string c_AB_AlarakDeadlyChargeSecondHeroic            = "AlarakDeadlyCharge2ndHeroic";
const string c_AB_AlarakUnleashDeadlyCharge                 = "AlarakUnleashDeadlyCharge";
const string c_AB_AlarakUnleashDeadlyChargeSecondHeroic     = "AlarakUnleashDeadlyCharge2ndHeroic";
const string c_AB_AlarakCounterStrike                       = "AlarakCounterStrikeTargeted";
const string c_AB_AlarakCounterStrikeSecondHeroic           = "AlarakCounterStrikeTargeted2ndHeroic";
const string c_AlarakDeadlyChargeActive                     = "AlarakDeadlyChargeCaster";
const string c_AlarakDeadlyChargeStack                      = "AlarakDeadlyChargeStack";

// Items (CUnit IDs of the items)
const string c_AlarakHastyBargainItem                       = "AlarakHastyBargainItem";
const string c_AlarakLastLaughItem                          = "AlarakLastLaughItem";

// Talents and modifiers
const string c_AlarakCounterStrikeSecondHeroicTalent        = "AlarakCounterStrikeItem";
const string c_AlarakDeadlyChargeSecondHeroicTalent         = "AlarakDeadlyChargeItem";
const string c_AlarakDoubleCrossTalent                      = "AlarakDoubleCross";
const fixed c_AlarakDoubleCrossTalentRangeModifier          = 1.25;
const string c_AlarakExtendedLightningTalent                = "AlarakExtendedLightning";
const fixed c_AlarakExtendedLightningTalentRangeModifier    = 1.2;
const string c_AlarakProjectedForceTalent                   = "AlarakProjectedForce";
const fixed c_AlarakProjectedForceTalentRangeModifier       = 1.25;

// Range, Radius, Misc Variables
const fixed c_AlarakDiscordStrikeRange                      = 5.0;
const fixed c_AlarakDiscordStrikeHeroesInRangeRadius        = 12.0;
const fixed c_AlarakLightningSurgeRange                     = 10.0;
const fixed c_AlarakTelekinesisMaxRange                     = 8.0;
const fixed c_AlarakTelekinesisMinRange                     = 5.1;
const fixed c_AlarakTelekinesisPushDistance                 = 4.0;
const fixed c_AlarakDeadlyChargeRange                       = 16.0;
const fixed c_AlarakCounterStrikeRange                      = 10.0;
const fixed c_AlarakLastLaughItemRange                      = 9.0;
const fixed c_AlarakDeadlyChargeThinkChannelTime            = 1.25;
unit[libCore_gv_bALMaxPlayers + 1] alarakCurrentDeadlyChargeTarget;
bool[libCore_gv_bALMaxPlayers + 1] alarakSkipDiscordStrikeThisAIThink;

//-------------------------------------------------------------------------------------------------
bool AlarakDiscordStrike (int player, unit aiUnit, unitgroup scanGroup) {
    // High damage inverted cone Silence, originates from Alarak
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    fixed abilityRange;
    point playerPos;

    // Telekinesis is evaluated before Discord Strike
    // Get out early if Telekinesis just ordered the unit to do a Q-W combo this AITHink
    // so that we don't get orders stomped out.
    if (alarakSkipDiscordStrikeThisAIThink[player]) {
        // reset the bool
        alarakSkipDiscordStrikeThisAIThink[player] = false;
        return false;
    }

    spellOrd = StormHeroAICreateOrder(player, c_AB_AlarakDiscordStrike, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // talent range modifier
    abilityRange = c_AlarakDiscordStrikeRange;
    if (PlayerHasTalent(player, c_AlarakDoubleCrossTalent)) {
        abilityRange *= c_AlarakDoubleCrossTalentRangeModifier;
    }

    // target nearest injured hero
    query.lv_maxDistance = abilityRange;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    // only want to use on main heroes
    query.lv_minScore = c_Storm_AI_FullHeroScore;

    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // Don't use on minions if there are nearby enemy heroes that can potentially
        // move into range, or get knocked into range with W.
        // Otherwise we are safe to use for PVE.
        playerPos = UnitGetPosition(aiUnit);
        if (AnyHeroesInArea(scanGroup, playerPos, c_AlarakDiscordStrikeHeroesInRangeRadius)) {
            return false;
        }

        // find a minion and remove score min.
        query.lv_minScore = 0.0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);

        // early out if the target is not valid
        if (!UnitIsValid(targetEnemy)) {
                // Can we cast on a tower?
                targetEnemy = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
                if (targetEnemy != null) {
                    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
                }
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
}

//-------------------------------------------------------------------------------------------------
bool AlarakTelekinesis (int player, unit aiUnit, unitgroup scanGroup) {
    // Vector targeted ability that pushes targets in a specified directed
    // Can be used offensively on enemy heroes, or defensively on Alarak himself
    order spellOrd;
    order comboOrd;
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    fixed abilityRange;
    fixed minAbilityRange;
    point pushTargetEndPoint;
    point playerPos;
    point targetPos;
    point retreatPos;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AlarakTelekinesis, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // talent range modifier
    abilityRange = c_AlarakTelekinesisMaxRange;
    if (PlayerHasTalent(player, c_AlarakProjectedForceTalent)) {
        abilityRange *= c_AlarakProjectedForceTalentRangeModifier;
    }

    playerPos = UnitGetPosition(aiUnit);
    // Do we need to use on ourselves and escape?
    if (libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSRetreat
     && AnyHeroesInArea(scanGroup, playerPos, abilityRange)) {
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(UnitGetOwner(aiUnit), abilityRange, null);
        OrderSetTargetPoint(spellOrd, playerPos);
        pushTargetEndPoint = LeadPoint(playerPos, retreatPos, aiUnit, c_AlarakTelekinesisPushDistance, false, false);
        OrderSetVectorPoint(spellOrd, pushTargetEndPoint);
        return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    }

    // try to combo with Q if it isn't on cooldown already
    comboOrd = StormHeroAICreateOrder(player, c_AB_AlarakDiscordStrike, 0);
    if (!UnitOrderIsValid(aiUnit, comboOrd)) {
        // If Q is on cooldown, early out
        return false;
    }

    // target nearest injured hero
    query.lv_maxDistance = abilityRange;
    // We don't want to target a unit that is within Discord Strike range
    // Modify minRange if Discord Strike range is increased
    minAbilityRange = c_AlarakTelekinesisMinRange;
    if (PlayerHasTalent(player, c_AlarakDoubleCrossTalent)) {
        minAbilityRange *= c_AlarakDoubleCrossTalentRangeModifier;
    }
    query.lv_minDistance = minAbilityRange;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    // only want to use on main heroes
    query.lv_minScore = c_Storm_AI_FullHeroScore;

    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // early out if the target is not valid
        return false;
    }

    // push them towards us
    targetPos = UnitGetPosition(targetEnemy);
    OrderSetTargetPoint(spellOrd, targetPos);
    pushTargetEndPoint = LeadPoint(playerPos, targetPos, targetEnemy, c_AlarakTelekinesisPushDistance, false, true);
    OrderSetVectorPoint(spellOrd, pushTargetEndPoint);

    // Skip Q script this loop since we are manually issueing the order here
    alarakSkipDiscordStrikeThisAIThink[player] = true;
    OrderSetTargetPoint(comboOrd, pushTargetEndPoint);
    UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    return UnitIssueOrder(aiUnit, comboOrd, c_orderQueueAddToFront);
}

//-------------------------------------------------------------------------------------------------
bool AlarakEnoughHeroesBetweenUnits (unit aiUnit, unit targetEnemy, unitgroup scanGroup, fixed minHeroCount, bool recklessCharging) {

    // logic for are there enough units in between my caster and the target?
    point casterPoint;
    point targetPoint;
    point offsetPoint;
    fixed distance;
    fixed searchSegments;
    fixed segmentLength;
    fixed totalEnemyHeroCount;
    fixed enemyHeroCount;
    fixed searchRadius;
    int i;

    totalEnemyHeroCount = 0;
    enemyHeroCount = 0;
    // How many offsets are we going to try to search?
    searchSegments = 4;
    casterPoint = UnitGetPosition(aiUnit);
    targetPoint = UnitGetPosition(targetEnemy);

    // if we're charging, we don't want to check the full distance, only how much we've already built up
    if (recklessCharging) {
        distance = UnitBehaviorCount(aiUnit, c_AlarakDeadlyChargeStack) * 0.55;
    }
    else {
        distance = DistanceBetweenPoints(casterPoint, targetPoint);
    }

    // The distance of each offset
    // we create evenly spaced searches towards our target point
    segmentLength = distance / searchSegments;
    // search radius should be half the segment length
    searchRadius = segmentLength / 2;
    // initialize offset point in front of the caster, towards the target
    offsetPoint = MovePointTowardsPoint(casterPoint, targetPoint, searchRadius);

    for (i = 1; i <= searchSegments; i += 1) {

        // increase total hero count by number of enemy heroes we find
        enemyHeroCount = CountHeroesInGroup(UnitGroupFilterHeroes(UnitsInArea(scanGroup, offsetPoint, searchRadius)));
        totalEnemyHeroCount += enemyHeroCount;

        // Have we found enough heroes?
        if (totalEnemyHeroCount >= minHeroCount) {
            return true;
        }

        // update offset point
        offsetPoint = MovePointTowardsPoint(offsetPoint, targetPoint, segmentLength);
    }

    // We didn't find enough heroes
    return false;
}

//---------------------------------------------------------------------------------------------
bool AlarakLightningSurge (int player, unit aiUnit, unitgroup scanGroup) {
    // deals instant damage to the target and all enemies between them, heals for damage dealt to inner enemies
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    fixed abilityRange;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AlarakLightningSurge, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // talent range modifier
    abilityRange = c_AlarakLightningSurgeRange;
    if (PlayerHasTalent(player, c_AlarakExtendedLightningTalent)) {
        abilityRange *= c_AlarakExtendedLightningTalentRangeModifier;
    }

    query.lv_maxDistance = abilityRange;
    // Cast on a weak enemy hero if i can
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    // we want the farthest target so that we maximize chance of hitting something in between
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferDistantTargets;

    // Make sure there is at least 1 hero between our caster and target
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)
     || !AlarakEnoughHeroesBetweenUnits(aiUnit, targetEnemy, scanGroup, c_Storm_AI_AtLeast1Hero, false)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetEnemy, null);
}

//-------------------------------------------------------------------------------------------------
unit GetTargetForAlarakDeadlyCharge (int player, unit aiUnit, unitgroup scanGroup) {
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    // make sure we aren't too low on health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return null;
    }

    // make sure there are nearby targets
    if (!AnyHeroesInArea(scanGroup, UnitGetPosition(aiUnit), c_AlarakDeadlyChargeRange)) {
        return null;
    }

    query.lv_maxDistance = c_AlarakDeadlyChargeRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferDistantTargets;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);

    alarakCurrentDeadlyChargeTarget[player] = targetEnemy;
    return targetEnemy;
}

//-------------------------------------------------------------------------------------------------
bool AlarakDeadlyChargeAim (int player, unit aiUnit, unitgroup scanGroup) {
    unit targetEnemy;
    order ord;
    order spellOrd;

    targetEnemy = GetTargetForAlarakDeadlyCharge(player, aiUnit, scanGroup);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    if (UnitHasBehavior2(aiUnit, c_AlarakDeadlyChargeActive)
     && UnitUpdateChanneledOrderTarget(aiUnit, UnitGetPosition(targetEnemy))) {
        return true;
    }

    ord = StormHeroAICreateOrder(player, c_AB_AlarakDeadlyCharge, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        HeroReleaseFromTactical(player);
        return false;
    }

    OrderSetTargetPoint(ord, UnitGetPosition(targetEnemy));
    return UnitIssueOrder(aiUnit, ord, c_orderQueueReplace);
}

//-------------------------------------------------------------------------------------------------
bool AlarakShouldCancelDeadlyCharge (int player, unit aiUnit, unitgroup scanGroup) {

    // are we low on health?
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return true;
    }

    // are there no enemies in range?
    if (!AnyHeroesInArea(scanGroup, UnitGetPosition(aiUnit), c_AlarakDeadlyChargeRange)) {
        return true;
    }

    return false;
}

//-------------------------------------------------------------------------------------------------
bool AlarakUnleashDeadlyCharge (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;

    if (AlarakEnoughHeroesBetweenUnits(aiUnit, alarakCurrentDeadlyChargeTarget[player], scanGroup, c_Storm_AI_AtLeast1Hero, true)) {

        // use the appropriate version of the unleash ability
        if (PlayerHasTalent(player, c_AlarakDeadlyChargeSecondHeroicTalent)) {
            spellOrd = StormHeroAICreateOrder(player, c_AB_AlarakUnleashDeadlyChargeSecondHeroic, 0);
        }
        else {
            spellOrd = StormHeroAICreateOrder(player, c_AB_AlarakUnleashDeadlyCharge, 0);
        }

        if (!UnitOrderIsValid(aiUnit, spellOrd)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    return false;
}

//-------------------------------------------------------------------------------------------------
void AlarakDeadlyChargeThink (int player, unit aiUnit, unitgroup scanGroup) {
    // Update direction of Deadly Charge

    // Cancel if we're already low on health
    if (AlarakShouldCancelDeadlyCharge(player, aiUnit, scanGroup)) {

        // Since moving will cancel the ability, AI will cancel as soon as we release from tactical
        HeroReleaseFromTactical(player);
        return;
    }

    // Update our target and aiming.
    // we should continue and extend the duration of claim for tactical
    HeroClaimForTactical(player, c_AlarakDeadlyChargeThinkChannelTime, false);
    // This could fail if the move (index 4) order fails.
    if (AlarakDeadlyChargeAim(player, aiUnit, scanGroup)) {

        // We succesfully updated, should we unleash?
        if (AlarakUnleashDeadlyCharge(player, aiUnit, scanGroup)) {
            return;
        }

        return;
    }
}

//-------------------------------------------------------------------------------------------------
bool AlarakDeadlyCharge (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    unit targetEnemy;

    // Only use if there is a team fight nearby
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {
        return false;
    }

    // use the appropriate version of Deadly Charge ability
    if (PlayerHasTalent(player, c_AlarakDeadlyChargeSecondHeroicTalent)) {
        spellOrd = StormHeroAICreateOrder(player, c_AB_AlarakDeadlyChargeSecondHeroic, 0);
    }
    else {
        spellOrd = StormHeroAICreateOrder(player, c_AB_AlarakDeadlyCharge, 0);
    }

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    targetEnemy = GetTargetForAlarakDeadlyCharge(player, aiUnit, scanGroup);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    OrderSetTargetPoint(spellOrd, UnitGetPosition(targetEnemy));
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    HeroClaimForTactical(player, c_AlarakDeadlyChargeThinkChannelTime, false);
    // Don't use HeroIssueOrder for channeling
    UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    return true;
}

//-------------------------------------------------------------------------------------------------
bool AlarakCounterStrike (int player, unit aiUnit, unitgroup scanGroup) {
    // high damage delayed skillshot that only fires if the caster is attacked during a small window
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit targetHero;

    // Only use if there is a team fight nearby
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {
        return false;
    }

    // Where we recently attacked?
    if (!HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }

    // user the appropriate version of counter strike
    if (PlayerHasTalent(player, c_AlarakCounterStrikeSecondHeroicTalent)) {
        spellOrd = StormHeroAICreateOrder(player, c_AB_AlarakCounterStrikeSecondHeroic, 0);
    }
    else {
      spellOrd = StormHeroAICreateOrder(player, c_AB_AlarakCounterStrike, 0);
    }

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // prefer far weak heroes to maximize targets inbetween target and caster
    query.lv_maxDistance = c_AlarakCounterStrikeRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferDistantTargets;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetHero));
}

//-------------------------------------------------------------------------------------------------
bool AlarakDefensiveItemCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    point pos;

    if (itemType == c_AlarakLastLaughItem) {
        // Blink to target position
        if (!HaveBeenAttackedRecently(aiUnit) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            return false;
        }

        pos = libAIAI_gf_HeroAIGetRetreatPosition(UnitGetOwner(aiUnit), c_AlarakLastLaughItemRange, null);
        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueReplace, null, pos);
    }

    return false;
}

//-------------------------------------------------------------------------------------------------
bool AlarakOffensiveItemCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {

    if (itemType == c_AlarakHastyBargainItem) {
        // Reduces the cooldown of the QWE abilities
        // Don't use if we are below 25% energy
        if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < 25.0) {
            return false;
        }

        // Don't use if not enough enemies around
        if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {
            return false;
        }

        // Don't use unless all three abilities are on cooldown
        // since the item is kiss/curse.
        // If any of these basic abilities are not on cooldown, return false.
        if (!libCore_gf_IsAbilityOnCooldown(aiUnit, c_AB_AlarakDiscordStrike)
         || !libCore_gf_IsAbilityOnCooldown(aiUnit, c_AB_AlarakTelekinesis)
         || !libCore_gf_IsAbilityOnCooldown(aiUnit, c_AB_AlarakLightningSurge)) {
            return false;
        }

        return UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);;
    }

    return false;
}

//-------------------------------------------------------------------------------------------------
void AIThinkAlarak (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (UseItem(player, aiUnit, scanGroup, AlarakDefensiveItemCallback)) {
        return;
    }

    if (UseItem(player, aiUnit, scanGroup, AlarakOffensiveItemCallback)) {
        return;
    }

    if (AlarakTelekinesis(player, aiUnit, scanGroup)) {
        return;
    }

    if (AlarakDiscordStrike(player, aiUnit, scanGroup)) {
        return;
    }

    if (AlarakLightningSurge(player, aiUnit, scanGroup)) {
        return;
    }

    if (UnitHasBehavior2(aiUnit, c_AlarakDeadlyChargeActive)) {
        AlarakDeadlyChargeThink(player, aiUnit, scanGroup);
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player)) {
        if (AlarakDeadlyCharge(player, aiUnit, scanGroup)) {
            return;
        }

        if (AlarakCounterStrike(player, aiUnit, scanGroup)) {
            return;
        }
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}