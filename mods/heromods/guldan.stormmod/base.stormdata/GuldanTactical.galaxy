//---------------------------------------------------------------------------------------------
// Gul'dan Tactical
//---------------------------------------------------------------------------------------------

// Abilities and Behaviors
const string c_AB_GuldanFelFlame                        = "GuldanFelFlame";
const string c_AB_GuldanDrainLife                       = "GuldanDrainLife";
const string c_AB_GuldanCorruption                      = "GuldanCorruption";
const string c_AB_GuldanLifeTap                         = "GuldanLifeTap";
const string c_AB_GuldanHorrify                         = "GuldanHorrify";
const string c_AB_GuldanRainOfDestruction               = "GuldanRainOfDestruction";
const string c_GuldanDrainLifeActiveBehavior            = "GuldanDrainLifeChannel";
const string c_GuldanRainOfDestructionActiveBehavior    = "GuldanRainOfDestructionChannel";
const string c_GuldanDemonicCircleActive                = "GuldanDemonicCircleController";

// Items (CUnit IDs of the items)
const string c_GuldanConsumeSoul                        = "GuldanConsumeSoul";
const string c_GuldanHealthstone                        = "GuldanHealthstone";
const string c_GuldanDemonicCircleSummon                = "GuldanDemonicCircleSummon";
const string c_GuldanDemonicCircleTeleport              = "GuldanDemonicCircleTeleport";

// Talents and modifiers
const fixed c_GuldanGlyphOfDrainLifeModifier            = 1.25;
const string c_GuldanGlyphOfDrainLifeTalent             = "GuldanDrainLifeTalentGlyphofDrainLife";
const string c_GuldanDemonicCircleTalent                = "GuldanDemonicCircle";

// Range, Radius, Misc Variables
const fixed c_GuldanHighEnergyPercent                               = 75.0;
const fixed c_GuldanMediumEnergyPercent                             = 55.0;
const fixed c_GuldanLowEnergyPercent                                = 20.0;
const fixed c_GuldanHealthstoneUseThreshold                         = 50.0;
const fixed c_GuldanDemonicCircleUseThreshold                       = 30.0;
const fixed c_GuldanDemonicCircleCastTime                           = 1.25;
const fixed c_GuldanConsumeSoulUseThreshold                         = 80.0;
const fixed c_GuldanFelFlameRange                                   = 8.0;
const fixed c_GuldanFelFlameOffsetSearchRadius                      = 1.5;
const fixed c_GuldanDrainLifeRange                                  = 5.5;
const fixed c_GuldanDrainLifeMinimumHealth                          = 90.0;
const fixed c_GuldanDrainLifeChannelDuration                        = 3.25;
const fixed c_GuldanCorruptionRange                                 = 7.0;
const fixed c_GuldanCorruptionRadius                                = 1.5;
const fixed c_GuldanHorrifyRange                                    = 10.0;
const fixed c_GuldanHorrifyRadius                                   = 3.5;
const fixed c_GuldanHorrifyLeadScalar                               = 1.75;
const fixed c_GuldanRainOfDestructionRange                          = 10.0;
const fixed c_GuldanRainOfDestructionRadius                         = 11.0;
const fixed c_GuldanRainOfDestructionChannelDuration                = 7.25;
const fixed c_GuldanConsumeSoulRange                                = 5.5;
bool[libCore_gv_bALMaxPlayers + 1] GuldanCastingDemonicCircle;
bool[libCore_gv_bALMaxPlayers + 1] GuldanDemonicCircleActive;

//---------------------------------------------------------------------------------------------
bool GuldanFelFlame (int player, unit aiUnit, unitgroup scanGroup) {
    // Cone damage spell in front of Gul'dan
    order spellOrd;
    unit targetEnemy;
    fixed energy;
    fixed minCreeps;
    fixed minMinions;
    point inFrontofHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GuldanFelFlame, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Prefer close, weak enemy hero
    query.lv_maxDistance = c_GuldanFelFlameRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;

    // Find weak hero
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // if no hero found, find a minion
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);

        // Early out if the unit is not valid
        if (!UnitIsValid(targetEnemy)) {
                // Can we cast on a tower?
                targetEnemy = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
                if (targetEnemy != null) {
                    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
                }
            return false;
        }

        energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
        // Set thresholds for use on minions based on energy level
        if (energy > c_GuldanHighEnergyPercent) {
            minCreeps = c_Storm_AI_AtLeast1Creep;
            minMinions = c_Storm_AI_AtLeast2Minions;
        }
        else if (energy > c_GuldanLowEnergyPercent) {
            minCreeps = c_Storm_AI_AtLeast1Creep;
            minMinions = c_Storm_AI_AtLeast3Minions;
        }
        else {
            minCreeps = c_Storm_AI_AtLeast1Creep;
            minMinions = c_Storm_AI_AtLeast4Minions;
        }

        if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetEnemy), c_GuldanFelFlameOffsetSearchRadius, 0, minCreeps, minMinions)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool GuldanDrainLife (int player, unit aiUnit, unitgroup scanGroup) {
    // Deal continuous damage while healing yourself
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    fixed abilityRange;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GuldanDrainLife, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Define the ability range
    abilityRange = c_GuldanDrainLifeRange;
    // Modify range based on talent
    if (PlayerHasTalent(player, c_GuldanGlyphOfDrainLifeTalent)) {
        abilityRange *= c_GuldanGlyphOfDrainLifeModifier;
    }

    query.lv_maxDistance = abilityRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;

    // Try to find the best hero to target
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // Check our health is low enough to use on a minion before finding minion to cast on
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) >= c_GuldanDrainLifeMinimumHealth) {
            return false;
        }

        // Since we haven't found a hero, we now look for a healthy minion to drain
        query.lv_healthFactor = c_Storm_AI_StronglyPreferHealthyTargets;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)){
            return false;
        }
    }

    // 3.25 becaues it's the full duration of Drain Life channel (3),
    // with a bit of additional time
    HeroClaimForTactical(player, c_GuldanDrainLifeChannelDuration, true);
    // Don't use HeroIssueOrder for channeling because it
    // does work that isnt relevant to channeling
    OrderSetTargetUnit(spellOrd, targetEnemy);
    UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);

    return true;
}

//---------------------------------------------------------------------------------------------
bool GuldanCorruption (int player, unit aiUnit, unitgroup scanGroup) {
    // Create a series of AOE effects that move away from the caster
    // enemies hit gain a DoT.
    // I am treating the ability like a small AoE ability.
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GuldanCorruption, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = c_GuldanCorruptionRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;

    // Cast on a weak enemy hero if possible
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // only use on minions/creep if we can hit a hero or a group of minions
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)
         || !EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetEnemy), c_GuldanCorruptionRadius, 0, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast2Minions)){
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool GuldanHorrify (int player, unit aiUnit, unitgroup scanGroup) {
    // AoE ability that silences and fears enemies in an area
    order spellOrd;
    unitgroup nearbyEnemies;
    unitgroup nearbyEnemyHeroes;
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    point leadPoint;
    point enemyPoint;
    point playerPoint;
    bool castBetweenCasterAndTarget;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GuldanHorrify, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    playerPoint = UnitGetPosition(aiUnit);
    // do we need to save ourselves by fearing a close target away from us?
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth
     && AnyHeroesInArea(scanGroup, playerPoint, c_GuldanHorrifyRadius)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, playerPoint);
    }

    // if there isn't a team fight nearby, we get out early
    if (!TeamFightInArea(player, scanGroup, playerPoint, c_Storm_AI_DefaultTeamfightRange)){
        return false;
    }

    // If we are being outnumbered in a team fight (probably retreating)
    // we strongly prefer to cast on closer, healthy targets and fear them away from us
    // otherwise we pick on any clumped up backline
    if (CountTeamOutnumberedBy(player, scanGroup, playerPoint, c_GuldanHorrifyRange) >= 1) {
        query.lv_maxDistance = c_GuldanHorrifyRange;
        query.lv_healthFactor = c_Storm_AI_PreferHealthyTargets;
        query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
        // used when we calculate our target lead if we want to
        // fear them away from us because we are outnumbered
        castBetweenCasterAndTarget = true;
    }
    else {
        // we compensate our ability range for our lead vector offset.
        // if we don't do this our caster will try to move forward before trying to cast
        // and that can cause our ability to be incorrectly interrupted by other orders
        query.lv_maxDistance = c_GuldanHorrifyRange - c_GuldanHorrifyLeadScalar;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_distanceFactor = c_Storm_AI_PreferDistantTargets;
        // fear them towards us because we outnumber them
        castBetweenCasterAndTarget = false;
    }

    // Find a hero target
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    // Validate our initial unit
    if (!UnitIsValid(targetEnemy)) {
         return false;
    }

    // lead the ability since we want to fear enemies towards our caster point
    enemyPoint = UnitGetPosition(targetEnemy);
    leadPoint = LeadPoint(playerPoint, enemyPoint, targetEnemy, c_GuldanHorrifyLeadScalar, false, castBetweenCasterAndTarget);
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, leadPoint);
}

//---------------------------------------------------------------------------------------------
bool GuldanRainOfDestruction (int player, unit aiUnit, unitgroup scanGroup) {
    // Large, long lasting channeled AOE that deals damage to eveything in the area
    order spellOrd;
    unitgroup nearbyEnemies;
    unitgroup nearbyEnemyHeroes;
    point centerOfUnitGroup;
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GuldanRainOfDestruction, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Define all the ability range from the constant:
    // prefer closer, unhealthy targets
    query.lv_maxDistance = c_GuldanRainOfDestructionRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;

    // Find a hero target
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    // Validate our initial unit is valid and there are
    // at least 3 enemy heroes in the impact radius
    if (!UnitIsValid(targetEnemy)
     || !EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetEnemy), c_GuldanRainOfDestructionRadius, c_Storm_AI_AtLeast3Heroes, 0, 0)) {
         return false;
    }

    // Find any nearby targets to our initial target and create a unit group
    nearbyEnemies = UnitsInArea(scanGroup, UnitGetPosition(targetEnemy), c_GuldanRainOfDestructionRadius);
    // scrub unit group for heroes only
    nearbyEnemyHeroes = UnitGroupFilterHeroes(nearbyEnemies);
    // Find the center of our group of enemy heroes and find the center between them
    centerOfUnitGroup = UnitGroupCenterOfGroup(nearbyEnemyHeroes);
    // claim for tactical for the duration of the channel, plus 0.25 seconds extra
    HeroClaimForTactical(player, c_GuldanRainOfDestructionChannelDuration, true);
    // Don't use HeroIssueOrder for channeling since it does things irrelevant to channeling
    // Set cast point to center of unit group and issue the spell order
    OrderSetTargetPoint(spellOrd, centerOfUnitGroup);
    UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);

    return true;
}

//---------------------------------------------------------------------------------------------
bool GuldanLifeTap (int player, unit aiUnit, unitgroup scanGroup) {
    // Converts life to mana
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GuldanLifeTap, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Don't tap if we aren't too low on mana
    if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) > c_GuldanMediumEnergyPercent) {
        return false;
    }

    // Don't tap if we are near death
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool GuldanStopChannel (int player, unit aiUnit, unitgroup scanGroup) {

    // exit early if we are currently casting Demonic Circle
    if (GuldanCastingDemonicCircle[player] == true) {
        return false;
    }

    // We reclaim Gul'dan from tactical if he no longer has the channel behavior
    // for either Drain Life or Rain of Destruction
    // and he is still in cast tactical
    if (libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSCastTactical
     && !UnitHasBehavior2(aiUnit, c_GuldanRainOfDestructionActiveBehavior)
     && !UnitHasBehavior2(aiUnit, c_GuldanDrainLifeActiveBehavior)) {
        HeroReleaseFromTactical(player);
        return true;
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool GuldanDefensiveItemCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    unitgroup minionGroup;

    if (itemType == c_GuldanConsumeSoul) {
        // Destroy an enemy minion to gain health, use liberally whenever we are near minions
        // and try to target the healthy ones
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < c_GuldanConsumeSoulUseThreshold) {
            query.lv_maxDistance = c_GuldanConsumeSoulRange;
            query.lv_healthFactor = c_Storm_AI_StronglyPreferHealthyTargets;
            // We only look for minions since this can only be used on minions (biological)
            minionGroup = UnitGroupFilterMinions(scanGroup);
            targetEnemy = FindBestTacticalTarget(minionGroup, aiUnit, query);
            if (UnitIsValid(targetEnemy)) {
                return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, targetEnemy, null);
            }
        }
    }

    if (itemType == c_GuldanHealthstone) {
        // Heal for 30% of your total health if we are low on health
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < c_GuldanHealthstoneUseThreshold) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }

    if (itemType == c_GuldanDemonicCircleTeleport) {
        // This item is only usuable if we have an active portal, should we use it?
        // If our health is very low, use to escape
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < c_GuldanDemonicCircleUseThreshold) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueReplace);
            // Teleporting destroys the current Demonic Circle
            GuldanDemonicCircleActive[player] = false;
            return true;
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool GuldanDemonicCircleSummonUseCheck (int player, unit aiUnit, unitgroup scanGroup, order ord) {
    // Creates a portal that Gul'dan can teleport back to that does not expire. Try to place
    // a portal near a friendly tower

    // reset our fake cast time
    GuldanCastingDemonicCircle[player] = false;

    // We don't have a portal active, only place a new one if we have enough health (> 35%), bellow
    // which the AI will try to retreat. We never want to place a portal down if we are retreating.
    if (libAIAI_gv_aIHeroes[player].lv_heroState != libAIAI_ge_HeroAIStates_HSRetreat) {

        // Only place if we are protected by a friendly tower nearby (9)
        if (!libAIAI_gf_HeroAIUnitProtectedByTower(aiUnit, libAIAI_gv_aIHeroFarFromTowerDistance)) {
            return false;
        }

        // set this bool to true so our stopChannel function doesn't kill it early
        GuldanCastingDemonicCircle[player] = true;
        // we claim for tactical since this is a weird item with a cast time
        // so we treat it like a channel
        HeroClaimForTactical(player, c_GuldanDemonicCircleCastTime, true);
        UnitIssueOrder(aiUnit, ord, c_orderQueueReplace);
        return true;
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool GuldanUseDemonicCircleSummon (int player, unit aiUnit, unitgroup scanGroup) {

    // This is a weird item with a cast time.
    // A bit of duplicated code from UseItem since
    // we don't need to do all of the work of that function since,
    // and we already know the item type and order.
    order ord;
    unit invItem;
    string itemType;
    int itemIdx = 1;

    // If bool true, early out since we don't want to place a new portal
    if (GuldanDemonicCircleActive[player]) {
        return false;
    }

    // Early out if this player doesn't have the Demonic Circle talent
    if (!PlayerHasTalent(player, c_GuldanDemonicCircleTalent)){
        return false;
    }

    // else we make sure we don't have the portal active behavior before continuing
    if (UnitHasBehavior2(aiUnit, c_GuldanDemonicCircleActive)) {
        // Early out since we have the portal active behavior
        GuldanDemonicCircleActive[player] = true;
        return false;
    }

    // Now that we know we don't have a portal placed already, let's place one
    ord = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemInstant);

    // Find demonic circle item
    while (itemIdx <= libCore_gv_bALPlayerActiveInventorySlots) {
        invItem = UnitInventoryItem(aiUnit, itemIdx);
        itemIdx += 1;

        if (!UnitIsValid(invItem)) {
            continue;
        }

        itemType = UnitGetType(invItem);

        if (itemType != c_GuldanDemonicCircleSummon) {
            continue;
        }

        OrderSetTargetItem(ord, invItem);
        if (!UnitOrderIsValid(aiUnit, ord)) {
            return false;
        }

        // Check if we should use the item
        return GuldanDemonicCircleSummonUseCheck(player, aiUnit, scanGroup, ord);

    }

    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkGuldan (int player, unit aiUnit, unitgroup scanGroup) {

    if (GuldanStopChannel(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (GuldanUseDemonicCircleSummon(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (UseItem(player, aiUnit, scanGroup, GuldanDefensiveItemCallback)) {
        return;
    }

    if (GuldanDrainLife(player, aiUnit, scanGroup)) {
        return;
    }

    if (GuldanFelFlame(player, aiUnit, scanGroup)) {
        return;
    }

    if (GuldanCorruption(player, aiUnit, scanGroup)) {
        return;
    }

    if (GuldanLifeTap(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player)) {
        if (GuldanHorrify(player, aiUnit, scanGroup)) {
            return;
        }

        if (GuldanRainOfDestruction(player, aiUnit, scanGroup)) {
            return;
        }
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}