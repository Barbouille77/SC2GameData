//-------------------------------------------------------------------------------------------------
// D.Va Tactical
//-------------------------------------------------------------------------------------------------

// Abilities and Behaviors
const string c_AB_DVaPilotTorpedoDash                           = "DVaPilotTorpedoDash";
const string c_DVaPilotTorpedoDashTalent                     = "DVaPilotTorpedoDash";
const string c_AB_DVaPilotConcussivePulse                       = "DVaPilotConcussivePulse";
const string c_DVaPilotConcussivePulseTalent                 = "DVaPilotConcussivePulse";
const string c_AB_DVaPilotBigShot                               = "DVaPilotBigShot";
const string c_DVaPilotBigShotTalent                         = "DVaBigShot";
const fixed c_DVaPilotBigShotRange                              = 15.0;
const string c_AB_DVaPilotCallMech                              = "DVaPilotCallMech";
const string c_AB_DVaPilotCallMechMEKAfall                      = "DVaPilotCallMechMEKAfall";
const string c_DVaPilotCallMechMEKAfallTalent                   = "DVaPilotCallMechMEKAfall";
const fixed c_DVaMechCallMechMEKAfallRange                      = 6.0;

//---------------------------------------------------------------------------------------------
bool DVaPilotTorpedoDash (int player, unit aiUnit, unitgroup scanGroup) {
    // Dash to target location
    point retreatPos;
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;
    point targetPosition;

    if (PlayerHasTalent(player, c_DVaPilotTorpedoDashTalent)){
        //immediately bail out if we don't have the appropriate talent
        return false;
    }

    spellOrd = StormHeroAICreateOrder(player, c_AB_DVaPilotTorpedoDash, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // Jump towards your spawn for safety
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 7.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Don't jump into battle near a tower or low health
    if(CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, 75.0)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find a target hero
    query.lv_minDistance = 4.5;
    query.lv_maxDistance = 8;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxHealthPercent = 40;
    targetEnemy = FindBestTacticalTarget (scanGroup, aiUnit, query);


    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    // If the target has too many allies around, don't engage
    targetPosition = UnitGetPosition(targetEnemy);
    if (EnoughEnemiesInArea(scanGroup, targetPosition, 4, c_Storm_AI_AtLeast3Heroes, 0, 0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, targetPosition);
}

//---------------------------------------------------------------------------------------------
bool DVaPilotConcussivePulse (int player, unit aiUnit, unitgroup scanGroup) {
    // pushes back all enemies in a cone and deals damage
    order ord;
    unit targetEnemy;
    fixed directionAngle;
    point heroPos;
    point inFrontOfHero;
    Storm_AI_TargetQueryOptions query;

    if (PlayerHasTalent(player, c_DVaPilotConcussivePulseTalent)){
        //immediately quit if we don't have the talent
        return false;
    }

    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        //if we are so low on health that we are running away, skip this and favor loading into the mech
        return false;
    }

    ord = StormHeroAICreateOrder(player, c_AB_DVaPilotConcussivePulse, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Only push away units if they are attacking you
    if (!HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }

    // find a target enemy
    query.lv_maxDistance = 6.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    // check how many enemies are in that direction
    heroPos = UnitGetPosition(aiUnit);
    directionAngle = AngleBetweenPoints(heroPos, UnitGetPosition(targetEnemy));
    inFrontOfHero = PointWithOffsetPolar(heroPos, 3, directionAngle);

    if (!EnoughEnemiesInArea(scanGroup, inFrontOfHero, 3.5, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast4Creeps, c_Storm_AI_AtLeast8Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, inFrontOfHero);
 }

//---------------------------------------------------------------------------------------------
bool DVaPilotBigShot (int player, unit aiUnit, unitgroup scanGroup) {
    // Skill-shot, high damage
    order spellOrd;
    unit targetEnemy;
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;

    if (PlayerHasTalent(player, c_DVaPilotBigShotTalent)){
        //exit immediately if we do not have the talent
        return false;
    }

    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        //if we are so low on health that we are running away, skip this and favor loading into the mech
        return false;
    }

    spellOrd = StormHeroAICreateOrder(player, c_AB_DVaPilotBigShot, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Shoot any nearby enemy 
    query.lv_maxHealthPercent = healthReq;
    query.lv_maxDistance = c_DVaPilotBigShotRange;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;

    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);


    // If we are retreating, don't fire.
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {      
        return false;
    }


    if (!UnitIsValid(targetEnemy)) {
        // Shoot a minion if we can't find a hero 

        query.lv_maxHealthPercent = 100;
        query.lv_minScore = 0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool DVaPilotCallMech(int player, unit aiUnit, unitgroup scanGroup, bool DVaIsActiveTeamfight){
    order spellOrd;

    if (PlayerHasTalent(player, c_DVaPilotCallMechMEKAfallTalent)){
        //immediately kill this if they have MEKAfall
        return false;
    }

    spellOrd = StormHeroAICreateOrder(player, c_AB_DVaPilotCallMech, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (DVaIsActiveTeamfight){
    //if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {
        HeroClaimForTactical(player, 1.25, false);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
    }

    // activate regardless of situation if we are low on health 
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_endOffensiveHealth) {
        HeroClaimForTactical(player, 1.25, false);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
    }


    return false;
}

//---------------------------------------------------------------------------------------------
bool DVaPilotCallMechMEKAfall(int player, unit aiUnit, unitgroup scanGroup, bool DVaIsActiveTeamfight){
    order spellOrd;
    unit targetEnemy;
    point targetPoint;
    Storm_AI_TargetQueryOptions query;


    if (!PlayerHasTalent(player, c_DVaPilotCallMechMEKAfallTalent)){
        //immediately kill this if they do not have MEKAfall
        return false;
    }

    spellOrd = StormHeroAICreateOrder(player, c_AB_DVaPilotCallMechMEKAfall, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // try and find the most valueable place to drop MEKAfall
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    query.lv_maxDistance = c_DVaMechCallMechMEKAfallRange;
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;

    // Activate if there is a team fight 
    if (DVaIsActiveTeamfight){
    //if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {
        // we are healthy, so we can be pickier about where we drop it. hit at least a full hero.
        query.lv_minScore = c_Storm_AI_FullHeroScore;

        targetEnemy = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }

        if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetEnemy), 3.0, c_Storm_AI_AtLeast1HighValueHero, c_Storm_AI_AtLeast4Creeps, c_Storm_AI_AtLeast6Minions)) {
            return false;
        }

        HeroClaimForTactical(player, 1.25, false);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, targetEnemy, null); 
    }

    // activate regardless of situation if we are low enough on health to flee
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_endOffensiveHealth) {
        //cast on the best tactical unit in range in this siutation (no minScore for this one)
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);

        if (!UnitIsValid(targetEnemy)) {
            //if there is nothing, and we still need to cast it, just cast it at yourself
            targetPoint = UnitGetPosition(aiUnit);
            HeroClaimForTactical(player, 1.25, false);
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, targetPoint);
        }

        targetPoint = UnitGetPosition(targetEnemy);
        HeroClaimForTactical(player, 1.25, false);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, targetPoint);
    }

    return false;
}

//-------------------------------------------------------------------------------------------------
// Mech Tactical Functions
//-------------------------------------------------------------------------------------------------
// Abilities and Behaviors
const string c_AB_DVaMechDefenseMatrix                          = "DVaMechDefenseMatrixOn";
const fixed c_DVaMechDefenseMatrixRange                         = 7.0; 
const fixed c_DVaMechDefenseMatrixRadius                        = 3.5;
const fixed c_DVaMechDefenseMatrixSearchOffset                  = 3.5;
fixed[libCore_gv_bALMaxPlayers + 1] DVaMechDefenseMatrixCastAngle;
const fixed c_DVaMechDefenseMatrixDuration                      = 3.0;
const fixed c_DVaMechDefenseMatrixDurationGetThroughThis            = 6.0;
const string c_DVaDefenseMatrixGetThroughThis                       ="DVaDefenseMatrixGetThroughThis";
unit[libCore_gv_bALMaxPlayers + 1] DVaMechDefenseMatrixTarget;
const string c_DVaDefenseMatrixOff                              ="DVaMechDefenseMatrixOff";
const string c_DVaDefenseMatrixActive                           ="DVaMechDefenseMatrixChannelling";

const string c_AB_DVaMechBunnyHop                               ="DVaMechBunnyHopHeroic";
const string c_DVaBunnyHopActive                                ="DvaMechBunnyHopActive";
const fixed c_DVaMechBunnyHopRadius                             =5.0;
const fixed c_AB_DVaMechBunnyHopDuration                        =4.0;

const string c_AB_SelfDestruct                                  ="DVaMechSelfDestruct";
// this is NOT the radius matching the search, this is the radius she checks to see if she should cast it. So this a bit smaller
const fixed c_DVaMechSelfDestructRadius                         =5.5;

const fixed c_DVaMechBoosterDuration                            = 2.0;
const string c_AB_DVaMechBoosters                               ="DVaBoostersOn";
const string c_AB_DVaMechBoostersOff                            ="DVaBoostersOff";
const string c_DVaMechBoostersActive                            ="DVaBoostersActive";
bool[libCore_gv_bALMaxPlayers + 1] DVaMechUseBoostersForOffense;



//---------------------------------------------------------------------------------------------
bool DVaMechDefenseMatrix (int player, unit aiUnit, unitgroup scanGroup) {
    // Debuffs all enemies in front of hero over next few seconds
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;
    order spellOrd;
    point targetPos;
    fixed targetValueRequirement;
    fixed defenseMatrixTacticalTakeoverTime;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DVaMechDefenseMatrix, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = c_DVaMechDefenseMatrixRange;

    targetHero = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetHero)) {
        return false;
    }

    targetValueRequirement = c_Storm_AI_AtLeast2Heroes;

    // define requirements for casting on our health. If we are healthy, save defense matrix for 2+ heroes, if we are weak, loosen the cast to only a single hero 
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroMediumHealthPercent) {
        targetValueRequirement = c_Storm_AI_AtLeast1Hero;
    }

    // if we have a hero within range, scan defense matrix's potential coverage area, offset towards the hero found by 1/2 of it's range, and scan for a circle in the middle with a radius of half the range
    targetPos = PointWithOffsetPolar(UnitGetPosition(aiUnit), c_DVaMechDefenseMatrixSearchOffset, AngleBetweenPoints(UnitGetPosition(aiUnit), UnitGetPosition(targetHero)));
    if (!EnoughEnemiesInArea(scanGroup, targetPos, c_DVaMechDefenseMatrixRadius, targetValueRequirement, 0.0, 0.0)) {
        return false;
    }

    // Only set up tracking if our health is high enough (so we can still use this while fleeing, but won't turn/chase unless we are healthy)
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth){
        attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
        if (UnitOrderIsValid(aiUnit, attackOrd)) {
            //attack order is valid, store the angle of our cast, takeover from tactical, and cast
            defenseMatrixTacticalTakeoverTime = c_DVaMechDefenseMatrixDuration;
            //figure out which timer to use
            if(PlayerHasTalent(player, c_DVaDefenseMatrixGetThroughThis)){
                defenseMatrixTacticalTakeoverTime = c_DVaMechDefenseMatrixDurationGetThroughThis;
            }

            DVaMechDefenseMatrixTarget[player] = targetHero;
            DVaMechDefenseMatrixCastAngle[player] = AngleBetweenPoints(UnitGetPosition(targetHero), UnitGetPosition(aiUnit));
            HeroClaimForTactical(player, defenseMatrixTacticalTakeoverTime, false);
            return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, null);
        }
    }

    //not attack order (We aren't returning to base), so turn on matrix for our retreat
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetHero, null);
}

//-------------------------------------------------------------------------------------------------
bool DVaMechBunnyHop (int player, unit aiUnit, unitgroup scanGroup) {

    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DVaMechBunnyHop, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast if there is a weak hero
    query.lv_maxDistance = c_DVaMechBunnyHopRadius;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);

    if (UnitIsValid(targetEnemy)) {
        HeroClaimForTactical(player, c_DVaMechBoosterDuration, false); 
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), c_DVaMechBunnyHopRadius, c_Storm_AI_AtLeast2Heroes, c_Storm_AI_AtLeast3Creeps, c_Storm_AI_AtLeast8Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetEnemy, null);
}

bool DVaMechSelfDestruct (int player, unit aiUnit, unitgroup scanGroup, bool DVaIsActiveTeamfight) {

    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SelfDestruct, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // if there is a team fight
    if (DVaIsActiveTeamfight){
    //if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {

        //must have at least 2 heroes within (medium) detonation range 
        if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), c_DVaMechSelfDestructRadius, c_Storm_AI_AtLeast2Heroes, 0.0, 0.0)) {
            return false;
        }
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    return false;
}

//-------------------------------------------------------------------------------------------------
bool DVaMechBoosters (int player, unit aiUnit, unitgroup scanGroup, bool DVaIsActiveTeamfight) {
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DVaMechBoosters, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // check for retreating case first.
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueAddToFront);
    }

    //check for team fight usability if we are healthy enough to go in and maintain for a little while
    if(UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    // if there is a team fight, find the lowest target hero to and dash for them 
    if (DVaIsActiveTeamfight){
    //if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {

        query.lv_maxDistance = 9.0;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
        query.lv_lineOfSightRequired = true;

        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);

            if (!UnitIsValid(targetEnemy)) {
                return false;
            }
            HeroClaimForTactical(player, c_DVaMechBoosterDuration, false);
            DVaMechUseBoostersForOffense[player] = true;
            return UnitIssueOrder(aiUnit, spellOrd, c_orderQueueAddToFront);
    }

    return false;
}

//-------------------------------------------------------------------------------------------------
void AIDVaMechChannelBoosters (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;
    fixed DVaCurrentHealthValue;

    // Move to the closest enemy
    query.lv_maxDistance = 5.5;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;

    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        query.lv_minScore = 0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    }

    DVaCurrentHealthValue = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    //if my target is valid, and i'm over 60% health. then be aggressive.
    if (UnitIsValid(targetEnemy) && DVaCurrentHealthValue > libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        ord = StormHeroAICreateOrder(player, c_Storm_AB_Move, 0);
        if (!UnitOrderIsValid(aiUnit, ord)) {
            return;
        }

        OrderSetTargetPoint(ord, UnitGetPosition(targetEnemy));
        if (!UnitOrderIsValid(aiUnit, ord)) {
            return;
        }
        UnitIssueOrder(aiUnit, ord, c_orderQueueReplace);
    }
    else if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        // no valid targets, and we still have decent amount of health. Then cancel out.
        HeroReleaseFromTactical(player);
        ord = StormHeroAICreateOrder(player, c_AB_DVaMechBoostersOff, 0);
        DVaMechUseBoostersForOffense[player] = false;

        if (!UnitOrderIsValid(aiUnit, ord)) {
            return;
        }

        HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
    } else {
        // if we are under 60%, don't cancel, but end our control and let the strategic handle our retreat. 
        HeroReleaseFromTactical(player);
        DVaMechUseBoostersForOffense[player] = false;
    }

}

//-------------------------------------------------------------------------------------------------
void AIDVaMechDefenseMatrix (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;
    point DVaDefenseMatrixMoveToPoint;

    //load target enemy
    targetEnemy = DVaMechDefenseMatrixTarget[player];

    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth){
        //Health too low, bail out!!
        HeroReleaseFromTactical(player);
        ord = StormHeroAICreateOrder(player, c_DVaDefenseMatrixOff, 0);
        HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueReplace, null, null);
        return;
    }

    //make sure it's valid, if not search for someone else to focus on 
    if (!UnitIsValid(targetEnemy)) {
        //unit not valid - release tactical and cancel out
        HeroReleaseFromTactical(player);
        ord = StormHeroAICreateOrder(player, c_DVaDefenseMatrixOff, 0);
        HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueReplace, null, null);
        return;
    }

    //if unit is valid, decide where to move to based on the position of the current target, the offset to the center of the defense matrix area, and the angle that our defense matrix is cast
    ord = StormHeroAICreateOrder(player, c_Storm_AB_Move, 0);
    DVaDefenseMatrixMoveToPoint = PointWithOffsetPolar(UnitGetPosition(targetEnemy), c_DVaMechDefenseMatrixSearchOffset, DVaMechDefenseMatrixCastAngle[player]);
    OrderSetTargetPoint(ord, DVaDefenseMatrixMoveToPoint);

    UnitIssueOrder(aiUnit, ord, c_orderQueueReplace);
}

//-------------------------------------------------------------------------------------------------
void AIDVaBunnyHop (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth){
        //Health too low, give control back to strategic and run away (while bunny hopping)
        HeroReleaseFromTactical(player);
        return;
    }

    query.lv_maxDistance = 7.0;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_lineOfSightRequired = true;
    query.lv_minScore = c_Storm_AI_FullHeroScore;

    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        //unit not valid - release tactical and cancel out
        HeroReleaseFromTactical(player);
        ord = StormHeroAICreateOrder(player, c_AB_DVaMechBunnyHop, 1);
        HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
        return;
    }

    //if unit is valid, move to them based on the position of the evaluated target
    ord = StormHeroAICreateOrder(player, c_Storm_AB_Move, 0);
    OrderSetTargetPoint(ord, UnitGetPosition(targetEnemy));
    UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
}

//-------------------------------------------------------------------------------------------------
// Pilot Think Function
//-------------------------------------------------------------------------------------------------
void AIThinkHeroDVaPilot (int player, unit aiUnit, unitgroup scanGroup) {
    bool DVaIsTeamFightActive;

    if (libNtve_gf_UnitIsInsideTransport(aiUnit)
     || IsClaimedForTactical(player)) {
            // skip the tactical if we are inside of the transport, there's no need for us to think while inside. 
            // or we just called down a mech. This works for DVa pilot since no pilot ability
            // claims DVa for tactical. We cannot do this with mech, though, since many abilities
            // claim the mech for tactical.
            return;
    }

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if(UseDefensiveItem (player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player)) {
        if (DVaPilotBigShot(player, aiUnit, scanGroup)) {
            return;
        }
    }

    if (DVaPilotConcussivePulse(player, aiUnit, scanGroup)) {
        return;
    }

    if (DVaPilotTorpedoDash(player, aiUnit, scanGroup)) {
        return;
    }

    //Only used in the below two functions, check here so we can only check once. 
    DVaIsTeamFightActive = TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange);

    if (DVaPilotCallMech(player, aiUnit, scanGroup, DVaIsTeamFightActive)){
        return;
    }

    if (DVaPilotCallMechMEKAfall(player, aiUnit, scanGroup, DVaIsTeamFightActive)){
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//-------------------------------------------------------------------------------------------------
// Mech Think Function
//-------------------------------------------------------------------------------------------------
void AIThinkHeroDVaMech (int player, unit aiUnit, unitgroup scanGroup) {
    bool DVaIsTeamFightActive;

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    // Skip cases for when the mech is summoning/detonating/etc
    if(UnitHasBehavior2(aiUnit, "PermanentlyUncommandable")
    || UnitHasBehavior2(aiUnit, "DVaMechCallMechStartingUpStun")
    || UnitHasBehavior2(aiUnit, "DVaMechCallMechStartingUpStunMEKAfall")
    || UnitHasBehavior2(aiUnit, "DVaMEKAfallImpactSelfStun")) {
        //skip tactical if we are summoning down (the mech exists, and is uncommandable for a set amount of time once created)
        return;
    }

    if(UnitHasBehavior2(aiUnit, "IgnoredByTowerAI") == true){
        //skip if we are in self-destruct mode
        return;
    }


    if(UnitHasBehavior2(aiUnit, "DvaMechBunnyHopActive") == true){
        AIDVaBunnyHop(player, aiUnit, scanGroup);
        return;
    }

    if (UnitHasBehavior(aiUnit, c_DVaMechBoostersActive) == true && DVaMechUseBoostersForOffense[player] == true) {
        AIDVaMechChannelBoosters(player, aiUnit, scanGroup);
        return;
    } else {
        //make sure this is false if the behavior falls off between think loops
        DVaMechUseBoostersForOffense[player] = false;
    }

    if (UnitHasBehavior(aiUnit, c_DVaDefenseMatrixActive) == true) {
        AIDVaMechDefenseMatrix(player, aiUnit, scanGroup);
        return;
    }

    if (UnitHasBehavior(aiUnit, c_DVaBunnyHopActive) == true) {
        AIDVaBunnyHop(player, aiUnit, scanGroup);
        return;
    }

    if(UseDefensiveItem (player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    //boosters is the first time we need this, so by not checking until here, we assure that we aren't running this pointlessly
    DVaIsTeamFightActive = TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange);

    if(DVaMechBoosters(player, aiUnit, scanGroup, DVaIsTeamFightActive)){
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player)) {
        if(DVaMechBunnyHop(player, aiUnit, scanGroup)){
            return;
        }
    }

    if(DVaMechSelfDestruct(player, aiUnit, scanGroup, DVaIsTeamFightActive)){
        return;
    }

    if(DVaMechDefenseMatrix(player, aiUnit, scanGroup)){
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}
