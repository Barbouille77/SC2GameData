//---------------------------------------------------------------------------------------------
// Tracer Tactical
//---------------------------------------------------------------------------------------------

// Abilities
const string c_AB_TracerBlink           = "TracerBlink";
const string c_AB_TracerMelee           = "TracerMelee";
const string c_AB_TracerRecall          = "TracerRecall";
const string c_AB_TracerPulseBomb       = "TracerPulseBomb";
const string c_AB_TracerReload          = "TracerReload";

// Radii
const fixed c_TracerBlinkRange          = 6.0;
const fixed c_TracerMeleeRange          = 2.25;
const fixed c_TracerPulseBombRange      = 3.5;
const fixed c_TracerPulseBombRadius     = 2.5;
const fixed c_TracerPulseBombCenter     = 0.75;

// Behaviors and talents
const string c_TrackerRecallHealth      = "TracerTotalRecallRecall";

// Cast Times
const fixed c_TracerReloadTime = 0.75;
const fixed c_TracerRewindTime = 3.0;

//-------------------------------------------------------------------------------------------------
bool TracerBlink (int player, unit aiUnit, unitgroup scanGroup) {    
    // Blink to target location, very short cooldown, multiple charges
    point retreatPos;
    order spellOrd;
    order attackOrd;
    unit targetEnemy;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TracerBlink, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 60.0) {
        // Jump towards your spawn for safety
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, c_TracerBlinkRange, null); 

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Don't jump into battle near a tower or low health
    if(CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, 75.0)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find a target hero 
    targetEnemy = FindClosestWeakHero(scanGroup, aiUnit, 3.0, 8.0, 40.0, -1, -1, c_Storm_AI_LOS_Optional);
    if (!UnitIsValid(targetEnemy)) { 
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, UnitGetPosition(targetEnemy));
}

//-------------------------------------------------------------------------------------------------
bool TracerMelee (int player, unit aiUnit, unitgroup scanGroup) {
    // short cooldown melee, gains pulse bomb charges
    // auto-targets closest target preferring heroes

    // for now always cast this if we can (no real downside)
    // TODO: add AoE logic if we have BulletSpray talent (melee AoE talent)
    
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TracerMelee, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//-------------------------------------------------------------------------------------------------
bool TracerRecall (int player, unit aiUnit, unitgroup scanGroup) {
    // Tracer does a cleanse and teleports to the point she was at 3-4 seconds ago, restores health as well with 20 talent    
    order spellOrd;
    int recallIndex;
    fixed curLife;
    fixed healthGain;
    point recallPos;
    point retreatPos;
    fixed distFromCurPos;
    fixed distFromRecallPos;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TracerRecall, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    recallIndex = libTrac_gf_HeroTracerRecallDetermineIndex(player);

    if (recallIndex == -1) {
        return false;
    }
    
    // If recall wound regain a decent chunk of health (at least 15%), choose to recall now.
    curLife = UnitGetPropertyFixed(aiUnit, c_unitPropLife, c_unitPropCurrent);
    if (PlayerHasTalent(player, c_TrackerRecallHealth) == true) {
        healthGain = libTrac_gv_tracerRecallRecordVariable[player][recallIndex].lv_health - curLife;
        if (healthGain >= UnitGetPropertyFixed(aiUnit, c_unitPropLifeMax, c_unitPropCurrent) * 0.15) {
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
        }
    }

    // TODO: should we add logic for we're under attack, retreating, blink is on cooldown and recall would help get away?
    // Seems like a rare case and it'd be bad to recall then immediately get stunned/snared.
    
    // TODO: add logic for offensive use of recall?

    if (!UnitHasDebuffThatCanBeCleansed(aiUnit)) {
        return false;
    }

    if (!HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifeExpected, c_unitPropCurrent) >= curLife) {
        return false;
    }

    // we're under attack with at least one debuff or have a dot ticking
    // recall as long as the other location is at least a bit back toward safety
    recallPos = libTrac_gv_tracerRecallRecordVariable[player][recallIndex].lv_position;
    retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 12.0, null);
    distFromCurPos = DistanceBetweenPoints( UnitGetPosition(aiUnit), retreatPos);
    distFromRecallPos = DistanceBetweenPoints( recallPos, retreatPos);

    if (distFromCurPos < distFromRecallPos) {
        // the recall position is further away from retreating, 
        // for now don't use it as we don't want to recall toward enemies
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//-------------------------------------------------------------------------------------------------
bool TracerPulseBomb (int player, unit aiUnit, unitgroup scanGroup) {
    // Place bomb that after a delay sucks in all nearby units and detonates, leaving units stunned
    order spellOrd;
    unit targetHero;
    point targetPos;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TracerPulseBomb, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    
    query.lv_minDistance = 0.0;
    query.lv_maxDistance = c_TracerPulseBombRange;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    query.lv_maxHealthPercent = 100.0;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) { 
        return false;
    }

    // Only cast if there are other nearby enemies for it to hit also
    targetPos = UnitGetPosition(targetHero);
    if (!EnoughEnemiesInArea(scanGroup, targetPos, c_TracerPulseBombRadius, c_Storm_AI_AtLeast2Heroes, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast2Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//-------------------------------------------------------------------------------------------------
bool TracerReload (int player, unit aiUnit, unitgroup scanGroup) {
    // Reloads our weapon ammo, might as well do this anytime there are no nearby enemies.
    // TODO: Consider adding logic to do this anytime we're not attacking?     
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TracerReload, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    
    if (UnitGroupCount(scanGroup, c_unitCountAlive) > 0) {
        return false;
    }
    
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//-------------------------------------------------------------------------------------------------
void AIThinkTracer (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (TracerRecall(player, aiUnit, scanGroup)) {
        return;
    }

    if (TracerBlink(player, aiUnit, scanGroup)) {
        return;
    }

    if (TracerReload(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TracerPulseBomb(player, aiUnit, scanGroup)) {
        return;
    }

    if (TracerMelee(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}







