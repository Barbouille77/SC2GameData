//---------------------------------------------------------------------------------------------
// Samuro Tactical
//---------------------------------------------------------------------------------------------
// Abilities
const string c_AB_SamuroWindwalk     =            "SamuroWindwalk";
const string c_AB_SamuroMirrorImage  =            "SamuroMirrorImage";
const string c_AB_SamuroCriticalStrike   =        "SamuroCriticalStrikeDummy";
const string c_AB_SamuroBladestorm   =            "SamuroBladeStormDummy";
const string c_AB_SamuroBladestormCancel =        "SamuroBladestormCancel";
const string c_AB_SamuroIllusionMaster =          "SamuroIllusionMaster";


const fixed c_BladestormDuration                    = 12;
const fixed c_SamuroBladestormRadius                = 4;
//Used for Image Swapping
const fixed c_SamuroIllusionMasterRange             = 12;

// Behaviors
const string c_SamuroBladestorm    =              "SamuroBladestorm";
const string c_SamuroCriticalStrike =             "SamuroCriticalStrike";
const string c_SamuroCriticalStrikeActivated =    "SamuroCriticalStrikeActivated";

//---------------------------------------------------------------------------------------------
unit FindNearestMirrorImage (int player, unit aiUnit, unitgroup scanGroup) {
    unitgroup nearHeroes;
    unit toReturn = null;
    fixed bestDistanceSquared = 999;
    fixed compareDistanceSquared;
    int iterIndex;
    unit image;
    int groupCount;

    // Get all allied heroes nearby
    nearHeroes = AllyHeroUnitsInArea(player, UnitGetPosition(aiUnit), c_SamuroIllusionMasterRange);
    
    // What if empty?
    if (UnitGroupCount(nearHeroes, c_unitCountAll) == 0) {
        return toReturn;
    }
    
    // Iterate the unit group and find nearest
    groupCount = UnitGroupCount(nearHeroes, c_unitCountAll);
    for (iterIndex = 1; iterIndex < groupCount; iterIndex += 1) {
        image = UnitGroupUnit(nearHeroes, iterIndex);
        
        if (UnitGetType(image) != c_AB_SamuroMirrorImage) {
            // Continue means skip the rest of the loop
            continue;
        }
        
        if (UnitGetOwner(image) != player) {
            continue;
        }
        
        // We know that this is a mirror image. 
        // Now compare distances. DistanceSquared is faster than distance. 
        compareDistanceSquared = 
            DistanceSquaredBetweenPoints(UnitGetPosition(aiUnit), UnitGetPosition(image));

        if (compareDistanceSquared < bestDistanceSquared) {
            bestDistanceSquared = compareDistanceSquared;
            toReturn = image;
        }
        
    }
    return toReturn;
}

//---------------------------------------------------------------------------------------------
bool SamuroMirrorImage (int player, unit aiUnit, unitgroup scanGroup) {
    // Creates mirror images to decoy and distract enemies
    // if we've been damaged recently use MirrorImage to try to take damage instead
    order ord;

    ord = StormHeroAICreateOrder(player, c_AB_SamuroMirrorImage, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // If we haven't been damaged in the last 5 seconds, save this spell
    if (!HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }

    return HeroIssueOrder (player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool SamuroCriticalStrike (int player, unit aiUnit, unitgroup scanGroup) {
    // We always want to use this, as long we currently don't have the Crit behavior,
    order spellOrd;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SamuroCriticalStrike, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Don't use if we already have Crit
    if (UnitHasBehavior(aiUnit, c_SamuroCriticalStrike) || UnitHasBehavior(aiUnit, c_SamuroCriticalStrikeActivated)){
        return false;
    }
 
    // Don't use if retreating
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }
    
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool SamuroWindwalk (int player, unit aiUnit, unitgroup scanGroup) {
    // Gain cloaking & movement speed boost
    order ord;

    ord = StormHeroAICreateOrder(player, c_AB_SamuroWindwalk, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }
    
    // Use when at low health to run away safely
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }
    return HeroIssueOrder (player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool SamuroIllusionMaster (int player, unit aiUnit, unitgroup scanGroup) {
    // Swap Samuro with a target Mirror Image
    // Used to confuse the enemy, or to cleanse debuffs
    order spellOrd;
    unit nearestMirrorImage = null;
    
    spellOrd = StormHeroAICreateOrder(player, c_AB_SamuroIllusionMaster, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
        }
    // Save this unless we've been attacked recently or have a debuff
    if (!HaveBeenAttackedRecently(aiUnit) && !UnitHasDebuffThatCanBeCleansed(aiUnit)) {
        return false;
    }    

    nearestMirrorImage = FindNearestMirrorImage(player, aiUnit, scanGroup);
    if (!UnitIsValid(nearestMirrorImage)) {
        return false;
    }
    
    return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, nearestMirrorImage, null);
}

//---------------------------------------------------------------------------------------------
bool SamuroBladestorm (int player, unit aiUnit, unitgroup scanGroup) {
    // PBAOE  Heroic that damages nearby enemies. Moves with Samuro.
    // If there are at least X nearby enemies and Bladestorm to damage them all
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    order spellOrd;
    
    spellOrd = StormHeroAICreateOrder(player, c_AB_SamuroBladestorm, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    
     // Only cast if we are healthy enough to maintain for a little while
    if(UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }
        
    // Activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_SamuroBladestormRadius)) {
        return false;
    }
    
    return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//--------------------------------------------------------------------------------------------
void AICancelSamuroBladestorm (int player, unit aiUnit, unitgroup scanGroup) {
    // If we have no target or we need to start escaping, cancel
    order cancelOrd = StormHeroAICreateOrder(player, c_AB_SamuroBladestormCancel, 0);
    if (!UnitOrderIsValid(aiUnit, cancelOrd)) {
        return;
    }

    UnitIssueOrder(aiUnit, cancelOrd, c_orderQueueReplace);
    
    HeroReleaseFromTactical(player);
}

//--------------------------------------------------------------------------------------------
void AIChannelSamuroBladestorm (int player, unit aiUnit, unitgroup scanGroup) {
    Storm_AI_TargetQueryOptions query;
    order ord;
    unit targetEnemy;

    // If we've been attacked and have low life, cancel.
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        AICancelSamuroBladestorm(player, aiUnit, scanGroup);
        return;
    }

    // Find a valid target.
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;    

    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        AICancelSamuroBladestorm(player, aiUnit, scanGroup);
        return;
    }

    // Move to the targetted enemy.
    ord = StormHeroAICreateOrder(player, c_Storm_AB_Move, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        AICancelSamuroBladestorm(player, aiUnit, scanGroup);
        return;
    }

    OrderSetTargetUnit(ord, targetEnemy);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        AICancelSamuroBladestorm(player, aiUnit, scanGroup);
        return;
    }
     
    UnitIssueOrder(aiUnit, ord, c_orderQueueReplace);

    // Pauses Tactical AI for the duration 
    HeroClaimForTactical(player, 1.25, false);
    
    HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkSamuro (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UnitHasBehavior(aiUnit, c_SamuroBladestorm) == true) {
        AIChannelSamuroBladestorm(player, aiUnit, scanGroup);
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }
    
    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (SamuroMirrorImage(player, aiUnit, scanGroup)) {
        return;
    }
    
    //Illusion Master has a very low cooldown and should be used frequently
    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && SamuroIllusionMaster(player, aiUnit, scanGroup)) {
        return;
    }

     if (SamuroWindwalk(player, aiUnit, scanGroup)) {
        return;
    }
     
    if (SamuroCriticalStrike(player, aiUnit, scanGroup)){
        return;
    }
    
    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && SamuroBladestorm(player, aiUnit, scanGroup)) {
        return;
    }
    
    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}
