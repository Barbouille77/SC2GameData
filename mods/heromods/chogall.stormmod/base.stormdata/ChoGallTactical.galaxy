//---------------------------------------------------------------------------------------------
// Cho Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_ChoSurgingFist = "ChoSurgingFistCast";
const string c_AB_ChoSurgingFistExecute = "ChoSurgingFistExecute";
const string c_AB_ChoConsumingBlaze = "ChoConsumingBlaze";
const string c_AB_ChoRuneBomb = "ChoRuneBomb";
const string c_AB_ChoUpheaval = "ChoUpheaval";
const string c_AB_ChoHammerOfTwilight = "ChoHammerOfTwilight";

// Behaviors
const string c_ChoSurgingFistPreExecute = "ChoSurgingFistCastActorBehavior";
const string c_ChoSurgingFistNoInput = "ChoSurgingFistInitialFakeCast";

// radii
const fixed c_ChoConsumingBlazeRadius = 5.0;
const fixed c_ChoSurgingFistRadius = 7.0;
const fixed c_ChoUpheavalRadius = 13.0;
const fixed c_ChoHalfUpheavalRadius = 7.5;
const fixed c_ChoHammerRadius = 3.0;
const fixed c_RuneExplosionRadius = 2.0;
const fixed c_DreadOrbRadius = 2.0;
const fixed c_ShadowFlameRadius = 2.0;

// Unit name constants
const string c_ChoRuneBombUnitNameDefault = "ChoRuneBomb";
const string c_ChoRuneBombUnitNameReturn = "ChoRuneBombReturn";

//---------------------------------------------------------------------------------------------
// Gall Tactical Constants
//---------------------------------------------------------------------------------------------
const string c_AB_GallTwistingNether = "GallTwistingNether";
const string c_AB_GallTwistingNetherActivated = "GallTwistingNetherActivated";
const string c_AB_GallShadowboltVolley = "GallShadowboltVolley";
const string c_AB_GallShadowFlame = "GallShadowflame";
const string c_AB_GallHurryUpOaf = "GallHurryUpOaf";
const string c_AB_GallRunicBlast = "GallRunicBlast";
const string c_AB_GallChaosBarrage = "GallDreadOrb";
const string c_AB_GallTurn = "GallTurn";

// Ranges/times
const fixed c_ShadowFlameRange = 11.0;
const fixed c_ChaosBarrageMaxRange = 15.0;
const fixed c_ChaosBarrageCloseRange = 6.0;
const fixed c_TwistingNetherRadius = 5.0;
const fixed c_ShadowboltVolleyRange = 16.0;
const fixed c_ShadowboltTacticalLength = 4.0;
const fixed c_RunicBlastSearchRadius = 12.0;
const fixed c_ShadowboltCastTime = 1.0625;
const fixed c_SurgingFistTacticalCastTime = 1.0;
const fixed c_GallMoveDoofusRange = 5.0;
// Behavior
const string c_RunicBlastBehavior = "ChoRuneBombExists";
const string c_ShadowboltVolleyBehavior = "GallShadowboltVolleyCaster";

// PROTOTYPES
bool GallTwistingNether(int player, unit aiUnit, unitgroup scanGroup, point targetPoint);
const string c_TwistingNetherChannelBehavior = "GallTwistingNetherChannelingBehavior";


//---------------------------------------------------------------------------------------------
bool ChoSurgingFist (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    unit target;
    point targetPos;
    fixed ratio;
    Storm_AI_TargetQueryOptions query;
    bool nullTarget = false;
    // save self first
    // If we dont have this behavior, we need to cast SurgingFist
    if (!UnitHasBehavior2(aiUnit, c_ChoSurgingFistPreExecute)) {
        spellOrd = StormHeroAICreateOrder(player, c_AB_ChoSurgingFist, 0);
        nullTarget = true;
    }
    else {
        spellOrd = StormHeroAICreateOrder(player, c_AB_ChoSurgingFistExecute, 0);
    }

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (HaveBeenAttackedRecently(aiUnit)
        && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        if (nullTarget) {
            targetPos = null;
        }
        else {
            targetPos = AIPositionAlongPath(player, UnitGetPosition(aiUnit), libAIAI_gf_HeroAIGetRetreatPosition(player, c_ChoSurgingFistRadius, null), c_ChoSurgingFistRadius, true, true);
        }

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, targetPos);
    }

    // Not low health, is there a low health enemy nearby?
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = c_ChoSurgingFistRadius;
    query.lv_minDistance = 3.5;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroHighHealthPercent;
    query.lv_ignoreTargetsBehindGate = true;
    query.lv_adjustScoreCallback = Storm_AI_IgnoreTargetsInAOEDangerousToUs;
    target = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(target)) {
        return false;
    }

    targetPos = UnitGetPosition(target);

    ratio = libAIAI_gf_HeroAIDangerRatioEval(libGame_gv_players[player].lv_faction, targetPos, c_ChoSurgingFistRadius);

    if (ratio < libAIAI_gv_aIHeroEnterCombatEvalRatio) {
        return false;
    }

    if (nullTarget) {
        targetPos = null;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool ChoConsumingBlaze (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ChoConsumingBlaze, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), c_ChoConsumingBlazeRadius, c_Storm_AI_AtLeast2Heroes, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool ChoRuneBomb (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    unit target;
    point targetPos;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ChoRuneBomb, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    target = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (target == null) {
        return false;
    }

    targetPos = UnitGetPosition(target);
    if (!EnoughEnemiesInArea(scanGroup, targetPos, c_RuneExplosionRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        return false;
    }
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool ChoUpheaval (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    region potentialDeathArea;
    unit potentialTarget;
    Storm_AI_TargetQueryOptions query;
    int teamNumber;
    fixed ratio;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ChoUpheaval, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = c_ChoUpheavalRadius;
    query.lv_minDistance = 0.0;
    query.lv_ignoreTargetsBehindGate = true;
    query.lv_ignoreTargetsBehindAlliedGate = true;
    potentialTarget = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(potentialTarget)) {
        return false;
    }

    if (!RequiredEnemyPlayerCountInArea(2, scanGroup, UnitGetPosition(potentialTarget), c_ChoHalfUpheavalRadius)
     || !RequiredAllyPlayerCountInArea(3, player, UnitGetPosition(aiUnit), c_ChoUpheavalRadius)) {
        return false;
    }

    ratio = libAIAI_gf_HeroAIDangerRatioEval(libGame_gv_players[player].lv_faction, UnitGetPosition(potentialTarget), c_ChoUpheavalRadius);
    if (ratio < libAIAI_gv_aIHeroEnterCombatEvalRatio) {
        return false;
    }

    if (libAIAI_gf_HeroAIIsPlayerActive(libGDHL_gv_chogallPairs[teamNumber].lv_gallPlayer, libAIAI_gv_heroAIComputerPlayerType)) {
        teamNumber = libGame_gf_TeamNumberOfPlayer(player);
        GallTwistingNether(libGDHL_gv_chogallPairs[teamNumber].lv_gallPlayer, libGDHL_gv_chogallPairs[teamNumber].lv_gallUnit, scanGroup, UnitGetPosition(potentialTarget));
    }
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(potentialTarget));
}

//---------------------------------------------------------------------------------------------
bool ChoHammerOfTwilight (int player, unit aiUnit, unitgroup scanGroup) {

    order spellOrd;
    unit potentialTarget;
    unit lastAttacker;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ChoHammerOfTwilight, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)
        || UnitHasBehavior2(libGDHL_gv_chogallPairs[libGame_gf_TeamNumberOfPlayer(player)].lv_gallUnit, c_TwistingNetherChannelBehavior)) {
        return false;
    }

    if (HaveBeenAttackedRecently(aiUnit)
        && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        lastAttacker = AILastAttacker(aiUnit);
        if (UnitIsValid(lastAttacker)) {
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(lastAttacker));
        }
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = c_ChoHammerRadius;
    query.lv_ignoreTargetsBehindGate = true;
    query.lv_ignoreTargetsBehindAlliedGate = true;
    query.lv_adjustScoreCallback = Storm_AI_IgnoreTargetsInAOEDangerousToThem;
    potentialTarget = FindBestHero(scanGroup, aiUnit, query);

    if (UnitIsAlive(potentialTarget)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, potentialTarget, UnitGetPosition(potentialTarget));
    }

    return false;
}

void AIThinkCho (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    // When cho is molten surging, he can technically receive orders
    // With this behavior, the UI prevents abilities, so we mimic that in AI
    if (UnitHasBehavior2(aiUnit, c_ChoSurgingFistNoInput)) {
        return;
    }

    if (ChoConsumingBlaze(player, aiUnit, scanGroup)) {
        return;
    }

    if (ChoRuneBomb(player, aiUnit, scanGroup)) {
        return;
    }

    if (ChoSurgingFist(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && ChoHammerOfTwilight(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && ChoUpheaval(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}



//---------------------------------------------------------------------------------------------
// Gall Tactical
//---------------------------------------------------------------------------------------------
unitfilter c_Storm_AI_UncommandableFilter = UnitFilter(
        (1 << c_targetFilterUncommandable),
        0,
        0,
        0);

unit GallGetRune (int player, unit aiUnit) {

    string defaultName;
    string returnName;
    unitgroup runeGroup;
    int runeCount;
    int teamNumber;

    teamNumber = libGame_gf_TeamNumberOfPlayer(player);

    defaultName = c_ChoRuneBombUnitNameDefault;
    returnName = c_ChoRuneBombUnitNameReturn; 

    runeGroup = UnitGroup(defaultName, libGDHL_gv_chogallPairs[teamNumber].lv_choPlayer, RegionCircle(UnitGetPosition(libGDHL_gv_chogallPairs[teamNumber].lv_choUnit), c_RunicBlastSearchRadius), c_Storm_AI_UncommandableFilter, 1);
    runeCount = UnitGroupCount(runeGroup, c_unitCountAll);

    if (runeCount > 0) {
        return UnitGroupUnit(runeGroup, 1);
    }

    return null;
}

bool GallUseItems (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    order ordTarget;
    order ordTogOn;
    int itemIdx;
    unit invItem;
    string itemType;
    unit targetEnemy;
    unit choUnit = libGDHL_gv_chogallPairs[libGame_gf_TeamNumberOfPlayer(player)].lv_choUnit;

    Storm_AI_TargetQueryOptions query;

    ord = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemInstant);
    ordTarget = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemTarget);
    ordTogOn = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemTogOn);

    while (itemIdx <= libCore_gv_bALPlayerActiveInventorySlots) {
        invItem = UnitInventoryItem(aiUnit, itemIdx);
        itemIdx = itemIdx + 1;

        if (!UnitIsValid(invItem)) {
            continue;

        }

        OrderSetTargetItem(ord, invItem);
        OrderSetTargetItem(ordTarget, invItem);
        OrderSetTargetItem(ordTogOn, invItem);
        if (!UnitOrderIsValid(aiUnit, ord) && !UnitOrderIsValid(aiUnit, ordTarget) && !UnitOrderIsValid(aiUnit, ordTogOn)) {
            continue;

        }

        itemType = UnitGetType(invItem);

        if (itemType == "GallTheWillofGallItemUnit") {
            if (HaveBeenAttackedRecently(choUnit)
                && UnitGetPropertyFixed(choUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroLowHealthPercent) {
                return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);

            }

        }
        else if (itemType == "GallShoveItemUnit") {
            // If in AOE
            if (libAIAI_gf_HeroAIIsPointInAOEDangerousToFaction(UnitGetPosition(choUnit), libAIAI_gv_aIHeroAvoidAOEAvoidExtraDistance, libGame_gv_players[player].lv_faction)
                || (HaveBeenAttackedRecently(choUnit)
                && UnitGetPropertyFixed(choUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroLowHealthPercent)) {
                return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueReplace, null, libAIAI_gf_HeroAIGetRetreatPosition(player, c_GallMoveDoofusRange, null));

            }

            query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
            // We icnrease the c_gallMoveDoofusRange by 30% to consider heroes outside of his normal range, this will put him in a more advantageous position
            query.lv_maxDistance = c_GallMoveDoofusRange  * 1.3;
            query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
            targetEnemy = FindBestHero(scanGroup, aiUnit, query);

            if (!UnitIsValid(targetEnemy)) {
                return false;

            }
            return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueReplace, null, UnitGetPosition(targetEnemy));
        }

    }
    return false;

}

//---------------------------------------------------------------------------------------------
bool GallTwistingNether (int player, unit aiUnit, unitgroup scanGroup, point targetPoint) {
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GallTwistingNether, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (RequiredEnemyPlayerCountInArea(2, scanGroup, targetPoint, c_TwistingNetherRadius)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
// Leave this unchanged because if we predict with the above function, then this should be called soon
bool GallTwistingNetherActivated (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GallTwistingNetherActivated, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (RequiredEnemyPlayerCountInArea(2, scanGroup, UnitGetPosition(aiUnit), c_TwistingNetherRadius)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool GallShadowboltVolleyActive (int player, unit aiUnit, unitgroup scanGroup) {
    // Update direction of shadow bolt
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;
   
    query.lv_maxHealthPercent = 100.0;
    query.lv_maxDistance = c_ShadowboltVolleyRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return UnitUpdateChanneledOrderTarget(aiUnit, UnitGetPosition(targetEnemy));

}


//---------------------------------------------------------------------------------------------
bool GallShadowboltVolley (int player, unit aiUnit, unitgroup scanGroup) {
    // Update direction of breath cone or cancel if very low health
    order spellOrd;
    unit targetEnemy;
    order cancelOrd;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GallShadowboltVolley, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxHealthPercent = 100.0;
    query.lv_maxDistance = c_ShadowboltVolleyRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    if (!RequiredEnemyPlayerCountInArea(2, scanGroup, UnitGetPosition(targetEnemy), 4.0)) {
        return false;
    }

    OrderSetTargetPoint(spellOrd, UnitGetPosition(targetEnemy));
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    HeroClaimForTactical(player, c_ShadowboltCastTime, false);
    // Don't use HeroIssueOrder for channeling
    UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    return true;

}

//---------------------------------------------------------------------------------------------
bool GallShadowFlame (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit target;
    point targetPos;
    spellOrd = StormHeroAICreateOrder(player, c_AB_GallShadowFlame, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = c_ShadowFlameRange - 1.0;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    target = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (target == null) {
        // try for a tower if no enemies are around
        target = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
        if (target == null) {
            return false;
        }
        // don't test for minions, just blast the tower
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(target));
    }

    targetPos = UnitGetPosition(target);
    if (!EnoughEnemiesInArea(scanGroup, targetPos, c_ShadowFlameRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast2Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool GallDreadOrb (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit target;
    point targetPos;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GallChaosBarrage, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = c_ChaosBarrageMaxRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    target = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (target == null) {
        // try for a tower if no enemies are around
        target = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
        if (target == null) {
            return false;
        }
        // don't test for minions, just blast the tower
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(target));
    }

    targetPos = UnitGetPosition(target);
    if (!EnoughEnemiesInArea(scanGroup, targetPos, c_DreadOrbRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast2Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool GallHurryUpOaf (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    unit target;
    int teamNumber;
    teamNumber = libGame_gf_TeamNumberOfPlayer(player);

    spellOrd = StormHeroAICreateOrder(player, c_AB_GallHurryUpOaf, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }


    if (libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSFocusHero) {
        // Issue the order
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    if (HaveBeenAttackedRecently(libGDHL_gv_chogallPairs[teamNumber].lv_choUnit)
        && UnitGetPropertyFixed(libGDHL_gv_chogallPairs[teamNumber].lv_choUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[libGDHL_gv_chogallPairs[teamNumber].lv_choPlayer].lv_returnToSpawnHealth) {
        // Issue the order
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    return false;
}
//---------------------------------------------------------------------------------------------
bool GallRunicBlast (int player, unit aiUnit, unitgroup scanGroup) {
    unit rune;
    point runePosition;
    order spellOrd;
    unit target;

    rune = GallGetRune(player, aiUnit);
    if (rune == null) {
        return false;
    }

    spellOrd = StormHeroAICreateOrder(player, c_AB_GallRunicBlast, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    runePosition = UnitGetPosition(rune);

    if (!EnoughEnemiesInArea(scanGroup, runePosition, c_RuneExplosionRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast2Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}


void AIThinkGall (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }
    // No return catch because we want to cast this with other abilities
    GallHurryUpOaf(player, aiUnit, scanGroup);

    if (GallRunicBlast(player, aiUnit, scanGroup)) {
        return;
    }
    //We always check this first because we might need to prioritize activating twisting nether to kill who is in range.
    if (libAIAI_gf_HeroAIShouldUseUltimates(player)
        && (GallTwistingNether(player, aiUnit, scanGroup, UnitGetPosition(aiUnit)) || GallTwistingNetherActivated(player, aiUnit, scanGroup))) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player))  {
        if (UnitHasBehavior2(aiUnit, c_ShadowboltVolleyBehavior)
            && GallShadowboltVolleyActive(player, aiUnit, scanGroup)) {
            return;
        }

        if (GallShadowboltVolley(player, aiUnit, scanGroup)) {
            return;
        }
    }

    if (GallShadowFlame(player, aiUnit, scanGroup)) {
        return;
    }

    if (GallDreadOrb(player, aiUnit, scanGroup)) {
        return;
    }

    // Call GallUseItems because he has only 1 shared item and this can prevent needless UseOffensiveItem calls.
    if (GallUseItems(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}