//--------------------------------------------------------------------------------------------------
// Storm Tactical Hero AI
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
// Function prototypes
//--------------------------------------------------------------------------------------------------

// The prototype for function callbacks that can adjust a target unit's score from inside FindBestUnit()
fixed Storm_AI_AdjustScore (unitgroup scanGroup, int player, unit aiUnit, unit targetUnit, fixed targetScore, point targetPosition);

// Prototype for callbacks to check item usage.
bool Storm_AI_CheckUseItem (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff);

//--------------------------------------------------------------------------------------------------
// Structs
//--------------------------------------------------------------------------------------------------

// Storm_AI_TargetQueryOptions is used by FindBestUnit() to determine what units are valid and how to score them.
// Units are scored based on units having a default score value of 1.0,
// multiplied by their AIEvaluationFactor property, which is typically 1.0 for heroes.
// If minDistance or maxDistance are not set, they do not restrict the targets considered.
// If distanceFactor is not set, then distance does not alter the score of targets considered.
// If distanceFactor is positive, and maxDistance is set, then units at minDistance have a score
// increased by distanceFactor, and units at maxDistance have no score increase. Units in
// between are interpolated between the two extremes.
// If distanceFactor is negative, and maxDistance is set, then units at maxDistance have a score
// increased by abs(distanceFactor), interpolated to units at minDistance which have no score increase.
// If minHealthPercent or maxHealthPercent are not set, they do not restrict the targets considered.
// If healthFactor is not set, then health does not alter the score of targets considered.
// If healthFactor is positive then units at minHealthPercent have a score increased by healthFactor,
// interpolated to units at maxHealthPercent (or 100.0) which have no score increase.
// If healthFactor is negative, then units at maxHealthPercent (or 100.0) have a score
// increased by abs(healthFactor), and units at minHealthPercent having no score increase. Units in
// between are interpolated between the two extremes.
// PreferedRole refers to the pre-defined roles (Warrior, Support, Specialist, etc...).
// If roleFactor is Not 0, then roleFactor will be added to all units matching the role specified in preferedRole,
// meaning positive values in roleFactor will increase the score of matching units, while negative values will decrease it.
// MinScore is the score required for a target to be valid (unscaled by distance or health).
// Set to c_Storm_AI_FullHeroScore to require the target's AIEvaluationFactor is at least 1.0.
// AdjustScoreCallback can be set to a callback which can modify all target unit scores in a custom way.
// The callback function could set the score for a unit to c_Storm_AI_InvalidScore to ignore the unit.
// If Line of Sight is required, then targets behind other targets (from the point of view of the
// aiUnit attacking) will be discarded.
// If ignoreTargetsBehindGate is true, then targets behind enemy gates (from the point of view of the
// aiUnit attacking) will be discarded.
// If projectedTargetDistance is > 0, then when filtering out targets behind gates,
// the point tested for being behind a gate will be projected behind the target by the given distance.
// If projectedTargetDistance is < 0, then it will project the target position towards the attacker.
struct Storm_AI_TargetQueryOptions {
    fixed lv_minDistance;
    fixed lv_maxDistance;
    fixed lv_distanceFactor;
    fixed lv_minHealthPercent;
    fixed lv_maxHealthPercent;
    fixed lv_healthFactor;
    fixed lv_minScore;
    fixed lv_projectedTargetDistance;
    int lv_matchingRole;
    fixed lv_roleFactor;
    funcref<Storm_AI_AdjustScore> lv_adjustScoreCallback;
    bool lv_lineOfSightRequired;
    bool lv_ignoreTargetsBehindGate;
    bool lv_ignoreTargetsBehindAlliedGate;
}; // If you add to this, update ResetTargetQueryOptions!

//--------------------------------------------------------------------------------------------------
// Copies of constants to avoid including another file, must match original definitions
//--------------------------------------------------------------------------------------------------

const string c_Storm_AB_Attack = "attack";
const string c_Storm_AB_Move = "move";

//--------------------------------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------------------------------

const string c_AbathurUltimateEvolutionControlBehavior    = "AbathurUltimateEvolutionControlBehavior";

// When comparing best targets, the target has a default score of c_Storm_AI_FullHeroScore and the
// range and health can offset it. The ratio between these values can change how much range and health
// affects target preference.
const fixed c_Storm_AI_StronglyPreferCloserTargets = 1.0;
const fixed c_Storm_AI_PreferCloserTargets = 0.25;
const fixed c_Storm_AI_PreferDistantTargets = -0.25;
const fixed c_Storm_AI_StronglyPreferDistantTargets = -1.0;
const fixed c_Storm_AI_StronglyPreferUnhealthyTargets = 1.0;
const fixed c_Storm_AI_PreferUnhealthyTargets = 0.25;
const fixed c_Storm_AI_PreferHealthyTargets = -0.25;
const fixed c_Storm_AI_StronglyPreferHealthyTargets = -1.0;
const fixed c_Storm_AI_StronglyPreferMathchingRoleTargets = 1.0;
const fixed c_Storm_AI_PreferMathchingRoleTargets = 0.25;
const fixed c_Storm_AI_AvoidMathchingRoleTargets = -0.25;
const fixed c_Storm_AI_StronglyAvoidMathchingRoleTargets = -1.0;
const fixed c_Storm_AI_InvalidScore = -9999.0;
const fixed c_Storm_AI_FullHeroScore = 1.0;
const fixed c_Storm_AI_AtLeastMiniHero = 0.5;
const fixed c_Storm_AI_AtLeast1Hero = 1.0;
const fixed c_Storm_AI_AtLeast1HighValueHero = 1.25;
const fixed c_Storm_AI_AtLeast2Heroes = 2.0;
const fixed c_Storm_AI_AtLeast3Heroes = 3.0;
const fixed c_Storm_AI_AtLeast1Creep = 1.0;
const fixed c_Storm_AI_AtLeast2Creeps = 2.0;
const fixed c_Storm_AI_AtLeast3Creeps = 3.0;
const fixed c_Storm_AI_AtLeast4Creeps = 4.0;
const fixed c_Storm_AI_AtLeast1Minion = 1.0;
const fixed c_Storm_AI_AtLeast2Minions = 2.0;
const fixed c_Storm_AI_AtLeast3Minions = 3.0;
const fixed c_Storm_AI_AtLeast4Minions = 4.0;
const fixed c_Storm_AI_AtLeast5Minions = 5.0;
const fixed c_Storm_AI_AtLeast6Minions = 6.0;
const fixed c_Storm_AI_AtLeast7Minions = 7.0;
const fixed c_Storm_AI_AtLeast8Minions = 8.0;
const fixed c_Storm_AI_AtLeast9Minions = 9.0;
const fixed c_Storm_AI_DefaultTeamfightRange = 10.0;

const bool c_Storm_AI_AllowAnyHealing = true;
const bool c_Storm_AI_OnlyEssentialHealing = false;
const bool c_Storm_AI_LOS_Required = true;
const bool c_Storm_AI_LOS_Optional = false;

const fixed c_Storm_AI_HeavilyLosingTeamfight  = 2.0;
const fixed c_Storm_AI_LosingTeamfight         = 1.3;
const fixed c_Storm_AI_HeavilyWinningTeamfight = 0.1;
const fixed c_Storm_AI_WinningTeamfight        = .7;
const fixed c_Storm_AI_EvenTeamfight           = 1.0;
const fixed c_Storm_AI_AnyWinningCondition     = 0.0;
const fixed c_Storm_AI_AnyLosingCondition      = 2500.0;

// compare against this to detect an invalid ref because we can't use null or nullref
funcref<Storm_AI_AdjustScore> Storm_AI_AdjustScoreInvalidRef; // can't be const for some obscure reason.

//--------------------------------------------------------------------------------------------------
// Static data
//--------------------------------------------------------------------------------------------------

// Helper function to make filter creation easier.
unitfilter MakeSimpleAttributeUnitFilter(int attribute) {
    return UnitFilter(
        (1 << attribute),
        0,
        0,
        (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32))
    );
}
unitfilter c_Storm_AI_HeroFilter = MakeSimpleAttributeUnitFilter(c_targetFilterHeroic);
unitfilter c_Storm_AI_MinionFilter = UnitFilter(
    (1 << c_targetFilterMinion),
    0,
    0,
    (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterMerc - 32)) | (1 << (c_targetFilterInvulnerable - 32)) | (1 << (c_targetFilterPassive - 32)) | (1 << (c_targetFilterBenign - 32))
);

// Only non-benign and non-passive creeps are considered because we don't want to attack them with tactical unless they've been initiated
unitfilter c_Storm_AI_AggroCreepFilter = UnitFilter(
    (1 << c_targetFilterCreep),
    0,
    0,
    (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32)) | (1 << (c_targetFilterPassive - 32)) | (1 << (c_targetFilterBenign - 32))
);
unitfilter c_Storm_AI_LanerCreepFilter = UnitFilter(
    (1 << c_targetFilterMerc),
    0,
    0,
    (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32)) | (1 << (c_targetFilterPassive - 32)) | (1 << (c_targetFilterBenign - 32))
);
unitfilter c_Storm_AI_TowerFilter = MakeSimpleAttributeUnitFilter(c_targetFilterTower);
unitfilter c_Storm_AI_StructureFilter = MakeSimpleAttributeUnitFilter(c_targetFilterStructure);
unitfilter c_Storm_AI_PassiveCreepFilter = UnitFilter(
    (1 << c_targetFilterCreep),
    (1 << (c_targetFilterPassive - 32)),
    0,
    (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32))
);
unitfilter c_Storm_AI_AttackableFilter = UnitFilter(
    0,
    0,
    0,
    (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32)) | (1 << (c_targetFilterPassive - 32)) | (1 << (c_targetFilterBenign - 32))
);

//--------------------------------------------------------------------------------------------------
// Variables
//--------------------------------------------------------------------------------------------------

unit[libCore_gv_bALMaxPlayers] abathurSymbioteUnit;
unit[libCore_gv_bALMaxPlayers] abathurUltimateEvolutionUnit;

//--------------------------------------------------------------------------------------------------
//  Tactical Helper Functions
//--------------------------------------------------------------------------------------------------
void ResetTargetQueryOptions (structref<Storm_AI_TargetQueryOptions> options) {
    options.lv_minDistance = 0.0;
    options.lv_maxDistance = 0.0;
    options.lv_distanceFactor = 0.0;
    options.lv_minHealthPercent = 0.0;
    options.lv_maxHealthPercent = 0.0;
    options.lv_healthFactor = 0.0;
    options.lv_minScore = 0.0;
    options.lv_projectedTargetDistance = 0.0;
    options.lv_matchingRole = -1; //Using -1 because 0 is used for warriors
    options.lv_roleFactor = 0.0;
    options.lv_adjustScoreCallback = Storm_AI_AdjustScoreInvalidRef;
    options.lv_lineOfSightRequired = false;
    options.lv_ignoreTargetsBehindGate = false;
    options.lv_ignoreTargetsBehindAlliedGate = false;
}

//---------------------------------------------------------------------------------------------
int GetOpposingFactionAITeamDataIndex (int faction) {
    //libGame_gv_teams, for some reason, is a 1-based array, so we need to return the correct
    //index which is defined by libGame_gv_teamOrderIndex_C and libGame_gv_teamChaosIndex_C
    //in case the indexing ever changes in the future.
    if (faction == libGame_ge_Faction_Order) {
        return libGame_gv_teamChaosIndex_C;
    }
    else {
        return libGame_gv_teamOrderIndex_C;
    }
}

//---------------------------------------------------------------------------------------------
int GetOpposingFaction (int faction) {
    if (faction == libGame_ge_Faction_Order) {
        return libGame_ge_Faction_Chaos;
    }
    else {
        return libGame_ge_Faction_Order;
    }
}

//---------------------------------------------------------------------------------------------
fixed Storm_AI_IgnoreTargetsInAOEDangerousToThem (unitgroup scanGroup, int player, unit aiUnit, unit targetUnit, fixed targetScore, point targetPosition) {
    if (libAIAI_gf_HeroAIIsPointInAOEDangerousToFaction(targetPosition, libAIAI_gv_aIHeroAvoidAOEAvoidExtraDistance, GetOpposingFaction(libGame_gv_players[player].lv_faction))) {
        return c_Storm_AI_InvalidScore;
    }
    return targetScore;
}

//---------------------------------------------------------------------------------------------
fixed Storm_AI_IgnoreTargetsInAOEDangerousToUs (unitgroup scanGroup, int player, unit aiUnit, unit targetUnit, fixed targetScore, point targetPosition) {
    if (libAIAI_gf_HeroAIIsPointInAOEDangerousToFaction(targetPosition, libAIAI_gv_aIHeroAvoidAOEAvoidExtraDistance, libGame_gv_players[player].lv_faction)) {
        return c_Storm_AI_InvalidScore;
    }
    return targetScore;
}

//---------------------------------------------------------------------------------------------
order StormHeroAICreateOrder (int player, string abilLink, int abilIndex) {
    abilcmd cmd = AbilityCommand(abilLink, abilIndex);
    order ord;
    if (cmd == c_nullCmd) {
        return null;
    }
    ord = Order(cmd);
    OrderSetPlayer(ord, player);
    return ord;
}

//---------------------------------------------------------------------------------------------
bool IsClaimedForTactical (int player) {
    return libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSCastTactical;
}

//---------------------------------------------------------------------------------------------
void HeroClaimForTactical (int player, fixed duration, bool endIfIdleOrVeryInjured) {
    if (libAIAI_gv_aIHeroes[player].lv_heroState != libAIAI_ge_HeroAIStates_HSCastTactical) {
        libAIAI_gf_HeroAIChangeState(player, libAIAI_ge_HeroAIStates_HSCastTactical);
    }
    libAIAI_gv_aIHeroes[player].lv_castTacticalTimeout = TimerGetElapsed(libGame_gv_gameTimer) + duration;
    libAIAI_gv_aIHeroes[player].lv_castTacticalEndIfIdleOrVeryInjured = endIfIdleOrVeryInjured;
}

//---------------------------------------------------------------------------------------------
void HeroReleaseFromTactical (int player) {
    libAIAI_gf_HeroAIReturnToCurrentObjective(player);
}

void HeroFocusOnHero (int player, unit targetHero) {
    if (libAIAI_gv_aIHeroFocusWeakHeroes[libAIAI_gv_aIHeroes[player].lv_difficulty]
        && libAIAI_gf_HeroAIIsHigherPriority(player, libAIAI_ge_HeroAIPriority_PushLanePushWithTeam)
        && libAIAI_gf_HeroAIHeroCanBeFocused(targetHero)) {
        libAIAI_gf_HeroAIChangeState(player, libAIAI_ge_HeroAIStates_HSFocusHero);
        libAIAI_gv_aIHeroes[player].lv_targetHero = targetHero;
        libAIAI_gv_aIHeroes[player].lv_targetHeroCheckPosition = null;
        libAIAI_gv_aIHeroes[player].lv_focusHeroTimeout = (TimerGetElapsed(libGame_gv_gameTimer) + libAIAI_gv_aIHeroFocusHeroMaxChaseTime);
    }
}

//---------------------------------------------------------------------------------------------
bool HeroIssueOrder (int player, unit aiUnit, order spellOrd, order attackOrd, int addToFront, unit targetUnit, point pos) {
    // Make AI miss skillshots
    point fudgedTargetPos;

    if (pos != null) {
        fudgedTargetPos = libAIAI_gf_HeroAIFudgeTargetPosition(player, pos);
    }

    // Set the target of the attack order
    if (attackOrd != null) {
        if (targetUnit != null) {
            OrderSetTargetUnit(attackOrd, targetUnit);
        }
        else if (fudgedTargetPos != null) {
            OrderSetTargetPoint(attackOrd, fudgedTargetPos);
        }

        if (UnitIssueOrder(aiUnit, attackOrd, c_orderQueueReplace)) {
            addToFront = c_orderQueueAddToFront;
        }
    }

    libAIAI_gf_HeroAIUpdateNextSpellCheckTime(player);

    // Cast the ability
    if (spellOrd != null) {
        // Set the target of the spell order
        if (fudgedTargetPos != null) {
            OrderSetTargetPoint(spellOrd, fudgedTargetPos);
        }
        else if (targetUnit != null) {
            OrderSetTargetUnit(spellOrd, targetUnit);
        }

        return UnitIssueOrder(aiUnit, spellOrd, addToFront);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
point MovePointTowardsPoint (point p1, point p2, fixed dist) {
    fixed dx;
    fixed dy;
    fixed t;

    dx = PointGetX(p2) - PointGetX(p1);
    dy = PointGetY(p2) - PointGetY(p1);
    t = SquareRoot(dx * dx + dy * dy);
    if(t == 0.0) {
        return p1;
    }
    t = dist / t;
    return Point(PointGetX(p1) + t * dx, PointGetY(p1) + t * dy);
}

//---------------------------------------------------------------------------------------------
point PointScaleFixed (point p, fixed scalar) {
    return Point(PointGetX(p) * scalar, PointGetY(p) * scalar);
}

//---------------------------------------------------------------------------------------------
point PointNegate (point p) {
    return Point(-PointGetX(p), -PointGetY(p));
}

//---------------------------------------------------------------------------------------------
// Returns the magnitude of the potential orthogonal vector in 3d.
fixed PointCrossProduct2D(point p1, point p2) {
    return (PointGetX(p1) * PointGetY(p2)) - (PointGetY(p1) * PointGetY(p2));
}

//---------------------------------------------------------------------------------------------
// Meant for vectors, obviously, but we only have a single point type in Galaxy.
fixed PointDotProduct (point p1, point p2) {
    return (PointGetX(p1) * PointGetX(p2)) + (PointGetY(p1) * PointGetY(p2));
}

//---------------------------------------------------------------------------------------------
point PointAddition (point p1, point p2) {
    return Point(PointGetX(p1) + PointGetX(p2), PointGetY(p1) + PointGetY(p2));
}

//---------------------------------------------------------------------------------------------
point PointSubtraction (point p1, point p2) {
    return Point(PointGetX(p1) - PointGetX(p2), PointGetY(p1) - PointGetY(p2));
}

//---------------------------------------------------------------------------------------------
// NOTE: vec should not be (0.0, 0.0) because a null point will be returned and accessing it will generate an error message.
point TacticalNormalize (point vec) {
    fixed length;

    length = SquareRoot(PointGetX(vec) * PointGetX(vec) + PointGetY(vec) * PointGetY(vec));
    if(length == 0.0) {
        return c_nullPoint;
    }
    return Point(PointGetX(vec) / length, PointGetY(vec) / length);
}

//---------------------------------------------------------------------------------------------
point ProjectPointOntoLine (point p1, point p2, point t) {
    // Projects a point onto a line between p1 & p2 (that extends beyond both ends).
    fixed diffx;
    fixed diffy;
    fixed length;
    point axis;
    point line;
    fixed projMag;
    point final;

    // Get the unit line segment axis
    diffx =  PointGetX(p2) - PointGetX(p1);
    diffy = PointGetY(p2) - PointGetY(p1);
    length = SquareRoot(diffx * diffx + diffy * diffy);

    if (length == 0.0) {
        return p1;
    }

    axis = Point(diffx / length, diffy / length);

    // Project point we are testing onto the axis
    line = Point(PointGetX(t) - PointGetX(p1), PointGetY(t) - PointGetY(p1));
    projMag = PointGetX(axis) * PointGetX(line) + PointGetY(axis) * PointGetY(line);

    final = Point(PointGetX(p1) + PointGetX(axis) * projMag, PointGetY(p1) + PointGetY(axis) * projMag);
    return final;
}

//---------------------------------------------------------------------------------------------
bool LineSegmentCollide (point p1, point p2, point t, fixed r) {
    // Test if point t is inside a line segment from p1 to p2 that extends r in both directions normal to the segment axis (squared off capsule)
    fixed diffx;
    fixed diffy;
    fixed length;
    point axis;
    point line;
    fixed projMag;
    point orth;
    fixed orthMagSquare;

    // Get the unit line segment axis
    diffx =  PointGetX(p2) - PointGetX(p1);
    diffy = PointGetY(p2) - PointGetY(p1);
    length = SquareRoot(diffx * diffx + diffy * diffy);

    if (length == 0.0) {
        return false;
    }

    axis = Point(diffx / length, diffy / length);

    // Project point we are testing onto the axis
    line = Point(PointGetX(t) - PointGetX(p1), PointGetY(t) - PointGetY(p1));
    projMag = PointGetX(axis) * PointGetX(line) + PointGetY(axis) * PointGetY(line);

    // The projection of the point onto the line segment axis is not on the line segment,
    // so it does not collide with the line segment
    if (projMag < 0.0 || projMag > length) {
        return false;
    }

    // Check if it is within the radius of the line
    orth = Point(PointGetX(line) - PointGetX(axis) * projMag, PointGetY(line) - PointGetY(axis) * projMag);
    orthMagSquare = PointGetX(orth) * PointGetX(orth) + PointGetY(orth) * PointGetY(orth);

    // The test point is further than r away from the line segment, so it does not collide with it
    if (orthMagSquare > r * r) {
        return false;
    }

    return true;
}

//---------------------------------------------------------------------------------------------
point LeadPoint (point startingPoint, point endingPoint, unit targetUnit, fixed scalar, bool useTargetFacing, bool rotateVector180Degrees) {
    // Returns a lead vector.
    // bool useTargetFacing TRUE if we want to lead based on target facing, FALSE if we want to
    // place the lead point along a line from startingPoint to endingPoint that
    // extends beyond endingPoint.
    // Bool rotateVector180Degrees TRUE if we want the lead point to be facing the opposite
    // direction from its original. For example if useTargetFacing is FALSE and
    // rotateVector180Degrees is TRUE then our lead point no longer extend beyond endingPoint,
    // instead we force the lead point to always be placed along a line between
    // startingPoint and endingPoint.
    point leadPoint;

    if (!useTargetFacing) {
        // create the vector from startingPoint to endingPoint
        leadPoint = TacticalNormalize(PointSubtraction(endingPoint, startingPoint));

        // If rotateVector180Degrees is TRUE,
        // the placement of the ability should be between the caster and target in the
        // hopes that we can force them to stop chasing.
        if (rotateVector180Degrees) {
            leadPoint = PointNegate(leadPoint);
        }

        // scale our vector and combine its magnitude with that of the endingPoint vector
        leadPoint = PointScaleFixed(leadPoint, scalar);
        leadPoint = PointAddition(endingPoint, leadPoint);
    }
    else {
        // create the vector from endingPoint with a magnitude in the direction of
        // the targetUnit's facing
        leadPoint = PointWithOffsetPolar(endingPoint, scalar, UnitGetFacing(targetUnit));
    }

    return leadPoint;
}

//---------------------------------------------------------------------------------------------
bool HaveBeenAttackedRecently (unit aiUnit) {
    if (UnitTestState(aiUnit, c_unitStateHallucination)) {
        return AILastAttack(aiUnit) >= (AIGetTime() - 3.0);
    }
    else {
        return libAIAI_gf_HeroAIHeroHasBeenAttackedRecently(UnitGetOwner(aiUnit), 3.0);
    }
}

//---------------------------------------------------------------------------------------------
unitgroup UnitsInArea (unitgroup group, point center, fixed radius) {
    return UnitGroupFilterRegion(group, RegionCircle(center, radius), 0);
}

//---------------------------------------------------------------------------------------------
unitgroup AllyUnitsInArea (int player, point center, fixed radius) {
    return UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), null, c_noMaxCount);
}

//---------------------------------------------------------------------------------------------
unitgroup AllyHeroUnitsInArea (int player, point center, fixed radius) {
    return UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), c_Storm_AI_HeroFilter, c_noMaxCount);
}

//---------------------------------------------------------------------------------------------
unitgroup AllyMinionUnitsInArea (int player, point center, fixed radius) {
    return UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), c_Storm_AI_MinionFilter, c_noMaxCount);
}

//---------------------------------------------------------------------------------------------
bool AnyAllyHeroUnitsInArea (int player, point center, fixed radius) {
    return UnitGroupCount(UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), c_Storm_AI_HeroFilter, 1), c_unitCountAll) > 0;
}

//---------------------------------------------------------------------------------------------
bool AnyAllyMinionUnitsInArea (int player, point center, fixed radius) {
    return UnitGroupCount(UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), c_Storm_AI_MinionFilter, 1), c_unitCountAll) > 0;
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterHeroes (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_HeroFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterMinions (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_MinionFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterHeroOrMinion (unitgroup group) {
    unitgroup result = UnitGroupFilterHeroes(group);
    UnitGroupAddUnitGroup(result, UnitGroupFilterMinions(group));
    return result;
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterAggroCreeps (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_AggroCreepFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterLanerCreeps (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_LanerCreepFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterAggroCreepsOrLanerCreeps (unitgroup group) {
    unitgroup result = UnitGroupFilterAggroCreeps(group);
    UnitGroupAddUnitGroup(result, UnitGroupFilterLanerCreeps(group));
    return result;
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterTowers (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_TowerFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterStructures (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_StructureFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterAttackable (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_AttackableFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupUnitsInRing (unitgroup scanGroup, point p, fixed innerRadius, fixed outerRadius) {
    int i;
    unit currUnit;
    int count;
    fixed squaredRadius = innerRadius * innerRadius;
    unitgroup toReturn = UnitGroupEmpty();
    unitgroup enemyGroup;
    unitgroup circleGroup;

    enemyGroup = UnitGroupFilterHeroes(scanGroup);
    UnitGroupAddUnitGroup(enemyGroup, UnitGroupFilterAggroCreeps(scanGroup));
    UnitGroupAddUnitGroup(enemyGroup, UnitGroupFilterMinions(scanGroup));

    circleGroup = UnitsInArea(enemyGroup, p, outerRadius);

    count = UnitGroupCount(circleGroup, c_unitCountAll);
    for (i = 1; i <= count; i += 1) {
        currUnit = UnitGroupUnit(circleGroup, i);
        if (DistanceSquaredBetweenPoints(p, UnitGetPosition(currUnit)) >= squaredRadius) {
            UnitGroupAdd(toReturn, currUnit);
        }
    }
    return toReturn;
}

//---------------------------------------------------------------------------------------------
const int c_towerNearbyDist = 12;
unit GetNearbyTower (unit aiUnit, unitgroup group) {
    unitgroup tower = UnitGroupFilterRegion(UnitGroupFilterTowers(group), RegionCircle(UnitGetPosition(aiUnit), c_towerNearbyDist), 1);

    if (UnitGroupCount(tower, c_unitCountAll) > 0) {
        return UnitGroupUnit(tower, 1);
    }

    return null;
}

//---------------------------------------------------------------------------------------------
bool CheckIfTooLowHealthOrNearbyTower (unit aiUnit, unitgroup scanGroup, fixed minHealth) {
    unit nearbyTower;
    fixed curHealth = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);

    if (curHealth < minHealth) {
        return true;
    }

    nearbyTower = GetNearbyTower(aiUnit, scanGroup);
    if (UnitIsValid(nearbyTower)) {
        return true;
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool IsTargetAcrossGate (unit aiUnit, unit target, unitgroup relevantUnits, fixed projectedTargetDistance) {
    int blockingIndex;
    unit blockingUnitToCheck;
    point blockingUnitToCheckPosition;
    fixed blockingUnitToCheckFacing;
    fixed gateCrossSelf;
    point gateFacingVector;
    point gateAxis;
    point gateToSelf;
    point gateToTarget;
    fixed gateCrossTarget;
    point unitPosition;
    point targetPosition;
    bool blocked = false;

    unitPosition = UnitGetPosition(aiUnit);
    targetPosition = UnitGetPosition(target);
    for (blockingIndex = 1; blockingIndex <= UnitGroupCount(relevantUnits, c_unitCountAll); blockingIndex += 1) {
        blockingUnitToCheck = UnitGroupUnit(relevantUnits, blockingIndex);

        if (target == blockingUnitToCheck
            || !UnitIsAlive(blockingUnitToCheck)) {
            continue;
        }

        if (!UnitTypeTestFlag(UnitGetType(blockingUnitToCheck), c_unitFlagTownStructureGate)) {
            continue;
        }

        blockingUnitToCheckPosition = UnitGetPosition(blockingUnitToCheck);
        blockingUnitToCheckFacing = UnitGetFacing(blockingUnitToCheck);
        // We get the facing first
        gateFacingVector = Point(Cos(blockingUnitToCheckFacing), Sin(blockingUnitToCheckFacing));
        // We swap x and y and negate one so that we rotate 90 degrees because we want a vector along the length of the gate
        gateAxis = Point(-PointGetY(gateFacingVector), PointGetX(gateFacingVector));

        // get the cross product of ourself relative to the gate and the gate's axis.
        gateToSelf = Point(PointGetX(unitPosition) - PointGetX(blockingUnitToCheckPosition), PointGetY(unitPosition) - PointGetY(blockingUnitToCheckPosition));
        gateCrossSelf = PointGetX(gateAxis) * PointGetY(gateToSelf) - PointGetY(gateAxis) * PointGetX(gateToSelf);

        // optionally move targetPosition further away from unitPosition so that we test a point behind the target from our perspective.
        if (projectedTargetDistance != 0.0) {
            targetPosition = MovePointTowardsPoint(targetPosition, unitPosition, -projectedTargetDistance);
        }

        // Check which direction we need to move the unit
        if (((PointGetX(gateFacingVector) * PointGetX(gateToSelf)) + (PointGetY(gateFacingVector) * PointGetY(gateToSelf))) > 0.0) {
            // Facing out, negate and scale it
            gateFacingVector = Point(-PointGetX(gateFacingVector) * 2.0, -PointGetY(gateFacingVector) * 2.0);
        }
        else {
            gateFacingVector = Point(PointGetX(gateFacingVector) * 2.0, PointGetY(gateFacingVector) * 2.0);
        }
        // Add the scaled normal to the point to make the buffer zone.
        targetPosition = Point(PointGetX(targetPosition) + PointGetX(gateFacingVector), PointGetY(targetPosition) + PointGetY(gateFacingVector));

        // get the cross product of the target relative to the gate and the gate's axis.
        gateToTarget = Point(PointGetX(targetPosition) - PointGetX(blockingUnitToCheckPosition), PointGetY(targetPosition) - PointGetY(blockingUnitToCheckPosition));
        gateCrossTarget = PointGetX(gateAxis) * PointGetY(gateToTarget) - PointGetY(gateAxis) * PointGetX(gateToTarget);

        // If the cross products have a different sign (multiply to be negative), then they are on opposite sides of the gate
        if (gateCrossSelf * gateCrossTarget < 0.0) {
            blocked = true;
            break;
        }
    }

    return blocked;
}

//---------------------------------------------------------------------------------------------
bool IsTargetBlocked (point startPosition, point targetPosition, unitgroup scanGroup, unit ignoreUnit) {
    bool blocked;
    unit blockingUnitToCheck;
    int blockingIndex;

    // check if any of the units in the scan group intersect the line segment connecting the two points with a width of 1.5
    blockingIndex = UnitGroupCount(scanGroup, c_unitCountAll);
    blocked = false;
    // check all the units in the area
    while (blockingIndex > 0) {
        blockingUnitToCheck = UnitGroupUnit(scanGroup, blockingIndex);
        blockingIndex = blockingIndex - 1;

        if (ignoreUnit == blockingUnitToCheck) {
            continue;
        }

        if (LineSegmentCollide(startPosition, targetPosition, UnitGetPosition(blockingUnitToCheck), 1.5)) {
            blocked = true;
            break;
        }
    }

    return blocked;
}

//---------------------------------------------------------------------------------------------
unit FindBestUnit (unitgroup testGroup, unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    point unitPosition;
    int unitCount;
    int player;
    unit nearestUnit;
    fixed nearestHeroDistance;

    point inFrontofUnit;
    region inFrontRegion;
    unitgroup unitsInTheWayGroup;
    unitgroup minionsInTheWayGroup;
    unit target;
    fixed targetHealthPercent;
    point targetPosition;
    fixed targetDistance;
    fixed targetScore;
    fixed inverseHealthRange;
    bool lineOfSightRequired;

    unit bestUnit;
    fixed bestScore;

    bestScore = c_Storm_AI_InvalidScore; // Scaled score may be negative so we set our starting best score to a massively negative number.
    unitPosition = UnitGetPosition(aiUnit);
    player = UnitGetOwner(aiUnit);
    unitCount = UnitGroupCount(testGroup, c_unitCountAll);
    // setup the inverse health range such that incorrect configuration results in a 0 score modification
    // and we assume a maximum of 100 if no maximum is set.
    inverseHealthRange = 0.0;
    if (options.lv_maxHealthPercent > options.lv_minHealthPercent) {
        inverseHealthRange = 1.0 / (options.lv_maxHealthPercent - options.lv_minHealthPercent);
    }
    else if (options.lv_minHealthPercent < 100.0) {
        inverseHealthRange = 1.0 / (100.0 - options.lv_minHealthPercent);
    }

    lineOfSightRequired = options.lv_lineOfSightRequired && libAIAI_gv_aIHeroLineUpClearShotForSkillShots[libAIAI_gv_aIHeroes[player].lv_difficulty];

    // check all the units in the area
    while (unitCount > 0) {
        target = UnitGroupUnit(testGroup,unitCount);
        unitCount = unitCount - 1;

        // make sure unit is alive
        if (!UnitIsAlive(target)) {
            continue;
        }

        // make sure it is within the health percent constraints
        targetHealthPercent = UnitGetPropertyFixed(target, c_unitPropLifePercent, c_unitPropCurrent);
        if (targetHealthPercent < options.lv_minHealthPercent || (options.lv_maxHealthPercent > 0.0 && targetHealthPercent > options.lv_maxHealthPercent)) {
            continue;
        }

        targetPosition = UnitGetPosition(target);
        targetDistance = DistanceBetweenPoints(unitPosition, targetPosition);
        targetDistance = targetDistance - UnitGetPropertyFixed(target, c_unitPropRadius, c_unitPropCurrent);
        if (targetDistance < 0.0) {
            targetDistance = 0.0; // clamp because negative distances cause units to be excluded
        }

        // make sure it is within the distance constraint
        if (targetDistance < options.lv_minDistance || (options.lv_maxDistance > 0.0 && targetDistance > options.lv_maxDistance)) {
            continue;
        }

        // setup the basic unit score
        targetScore = c_Storm_AI_FullHeroScore * UnitGetPropertyFixed(target, c_unitPropAIEvaluationFactor, c_unitPropCurrent);

        // check the unscaled targetScore against the minscore so that scaling can't make a unit seem valid even though we shouldn't ever target it.
        if (targetScore < options.lv_minScore) {
            continue;
        }

        // add to the score based on distance
        if (options.lv_maxDistance > 0.0 && options.lv_maxDistance > options.lv_minDistance) {
            if (options.lv_distanceFactor > 0.0) {
                targetScore = targetScore + options.lv_distanceFactor * (options.lv_maxDistance - targetDistance) / (options.lv_maxDistance - options.lv_minDistance);
            }
            else if (options.lv_distanceFactor < 0.0) {
                targetScore = targetScore - options.lv_distanceFactor * (targetDistance - options.lv_minDistance) / (options.lv_maxDistance - options.lv_minDistance);
            }
        }

        // add to the score based on health
        if (options.lv_healthFactor > 0.0) {
            targetScore = targetScore + options.lv_healthFactor * (options.lv_maxHealthPercent - targetHealthPercent) * inverseHealthRange;
        }
        else if (options.lv_healthFactor < 0.0) {
            targetScore = targetScore - options.lv_healthFactor * (targetHealthPercent - options.lv_minHealthPercent) * inverseHealthRange;
        }

        // add to the score based on role
        if (options.lv_roleFactor != 0.0 && options.lv_matchingRole == libGame_gv_players[UnitGetOwner(target)].lv_heroData.lv_class) {
            targetScore = targetScore + options.lv_roleFactor;
        }

        // optionally run a callback to adjust the score for various reasons, e.g. chilled targets get 1.5 score. The callback can also filter by setting the score to c_Storm_AI_InvalidScore.
        if (options.lv_adjustScoreCallback != Storm_AI_AdjustScoreInvalidRef) {
            targetScore = options.lv_adjustScoreCallback(scanGroup, player, aiUnit, target, targetScore, targetPosition);
        }

        // If the score is worse than what we have, then skip the target.
        if (targetScore < bestScore) {
            continue;
        }

        // make sure it there is a clear shot between the units if requested
        // replace with something better later
        if (lineOfSightRequired && IsTargetBlocked(unitPosition, targetPosition, scanGroup, target)) {
            continue;
        }

        // Make sure there is no allied gate between us and the target for abilities that cannot be used through them
        if (options.lv_ignoreTargetsBehindAlliedGate
            && IsTargetAcrossGate(aiUnit, target, UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(unitPosition, options.lv_maxDistance), c_Storm_AI_StructureFilter, c_noMaxCount), options.lv_projectedTargetDistance)) {
              continue;
        }
        // make sure there is no enemy gate between us and the target (this assumes we will not get onto the bad side of a gate).
        // replace with something better later
        if (options.lv_ignoreTargetsBehindGate
            && IsTargetAcrossGate(aiUnit, target, scanGroup, options.lv_projectedTargetDistance)) {
            continue;
        }

        bestUnit = target;
        bestScore = targetScore;
    }

    return bestUnit;
}

//---------------------------------------------------------------------------------------------
// DEPRECATED
unit FindClosestWeakUnit (unitgroup testGroup, unitgroup scanGroup, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    Storm_AI_TargetQueryOptions options;

    // maxHealth and minMissingHealth aren't set anywhere, so they are not part of the new API.
    options.lv_minDistance = minDist;
    options.lv_maxDistance = maxDist;
    options.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    //options.lv_minHealthPercent = 0.0;
    options.lv_maxHealthPercent = maxHealthPercent;
    options.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    options.lv_lineOfSightRequired = clearShot;
    //options.lv_ignoreTargetsBehindGate = false;

    return FindBestUnit(testGroup, scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
unitgroup FilterBadHeroTargets (unitgroup scanGroup, int player) {
    int unitCount;
    unit unitToCheck;
    fixed healthPercent;

    // Avoid targetting weak human heroes
    if (!libAIAI_gv_aIHeroCastAbilitiesOnWeakHumanHeroes[libAIAI_gv_aIHeroes[player].lv_difficulty]) {
        unitCount = UnitGroupCount(scanGroup, c_unitCountAll);
        while (unitCount > 0) {
            unitToCheck = UnitGroupUnit(scanGroup, unitCount);
            unitCount = unitCount - 1;

            if (UnitTypeTestAttribute(UnitGetType(unitToCheck), c_unitAttributeHeroic) == false) {
                continue;
            }

            if (libAIAI_gf_HeroAIIsPlayerActive(UnitGetOwner(unitToCheck), libAIAI_gv_heroAIHumanPlayerType) == false) {
                continue;
            }

            healthPercent =  UnitGetPropertyFixed(unitToCheck, c_unitPropLifePercent, c_unitPropCurrent);
            if (healthPercent > 25.0) {
                continue;
            }

            UnitGroupRemove(scanGroup, unitToCheck);
        }
    }

    return scanGroup;
}

//---------------------------------------------------------------------------------------------
// Heroes are ranked based on health, distance, and the unit's AIEvaluationFactor
// e.g. (healers are worth more, misha is worth less)
unit FindBestHero (unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    return FindBestUnit(FilterBadHeroTargets(UnitGroupFilterHeroes(scanGroup), UnitGetOwner(aiUnit)), scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
// Minions are ranked based on health, distance, and the unit's AIEvaluationFactor
unit FindBestMinion (unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    return FindBestUnit(UnitGroupFilterMinions(scanGroup), scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
// Creeps are ranked based on health, distance, and the unit's AIEvaluationFactor
unit FindBestAggroCreep (unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    return FindBestUnit(UnitGroupFilterAggroCreeps(scanGroup), scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
// Creeps are ranked based on health, distance, and the unit's AIEvaluationFactor
// We don't want creeps with c_targetFilterUser1 because they're special map creeps.
unit FindBestPassiveCampCreep (unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    return FindBestUnit(UnitGroupFilter(null, c_playerAny, scanGroup, c_Storm_AI_PassiveCreepFilter, 0), scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
// Units are ranked based on health, distance, and the unit's AIEvaluationFactor
unit FindBestTacticalTarget (unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    unitgroup targets;
    unit target;

    // search heroes first
    targets = FilterBadHeroTargets(UnitGroupFilterHeroes(scanGroup), UnitGetOwner(aiUnit));
    target = FindBestUnit(targets, scanGroup, aiUnit, options);
    if (target != null) {
        return target;
    }

    // otherwise try aggro creeps
    targets = UnitGroupFilterAggroCreeps(scanGroup);
    target = FindBestUnit(targets, scanGroup, aiUnit, options);
    if (target != null) {
        return target;
    }

    // otherwise try minions
    targets = UnitGroupFilterMinions(scanGroup);
    return FindBestUnit(targets, scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
unit FindClosestWeakHero (unitgroup scanGroup, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    unitgroup targets = FilterBadHeroTargets(UnitGroupFilterHeroes(scanGroup), UnitGetOwner(aiUnit));
    return FindClosestWeakUnit(targets, scanGroup, aiUnit, minDist, maxDist, maxHealthPercent, maxHealth, minMissingHealth, clearShot);
}

//---------------------------------------------------------------------------------------------
unit FindClosestWeakMinion (unitgroup scanGroup, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    return FindClosestWeakUnit(UnitGroupFilterMinions(scanGroup), scanGroup, aiUnit, minDist, maxDist, maxHealthPercent, maxHealth, minMissingHealth, clearShot);
}

//---------------------------------------------------------------------------------------------
unit FindClosestWeakHeroOrMinion (unitgroup scanGroup, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    unitgroup targets = FilterBadHeroTargets(UnitGroupFilterHeroOrMinion(scanGroup), UnitGetOwner(aiUnit));
    return FindClosestWeakUnit(targets, scanGroup, aiUnit, minDist, maxDist, maxHealthPercent, maxHealth, minMissingHealth, clearShot);
}

//---------------------------------------------------------------------------------------------
unit FindClosestWeakTower (unitgroup scanGroup, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    return FindClosestWeakUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, minDist, maxDist, maxHealthPercent, maxHealth, minMissingHealth, clearShot);
}

//---------------------------------------------------------------------------------------------
unit FindCoreInGroup (unitgroup scanGroup, int player, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, bool clearShot) {
    fixed targetHealthPercent;
    point unitPosition;
    point targetPosition;
    fixed targetDistance;
    int teamIndex = GetOpposingFactionAITeamDataIndex(libGame_gv_players[player].lv_faction);
    unit target = libGame_gv_teams[teamIndex].lv_core;
    if (!UnitIsValid(target) || !UnitGroupHasUnit(scanGroup, target)) {
        return null;
    }

    // make sure it is within the health percent constraints
    targetHealthPercent = UnitGetPropertyFixed(target, c_unitPropLifePercent, c_unitPropCurrent);
    if (maxHealthPercent > 0.0 && targetHealthPercent > maxHealthPercent) {
        return null;
    }

    unitPosition = UnitGetPosition(aiUnit);
    targetPosition = UnitGetPosition(target);
    targetDistance = DistanceBetweenPoints(unitPosition, targetPosition);
    targetDistance = targetDistance - UnitGetPropertyFixed(target, c_unitPropRadius, c_unitPropCurrent);
    if (targetDistance < 0.0) {
        targetDistance = 0.0; // clamp because negative distances cause units to be excluded
    }

    // make sure it is within the distance constraint
    if (targetDistance < minDist || (maxDist > 0.0 && targetDistance > maxDist)) {
        return null;
    }

    //check line of sight if requested
    if (clearShot && IsTargetBlocked(unitPosition, targetPosition, scanGroup, target)) {
        return null;
    }

    return target;
}

//---------------------------------------------------------------------------------------------
unit FindClosestWeakTowerOrCore (unitgroup scanGroup, int player, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    unit target = FindClosestWeakUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, minDist, maxDist, maxHealthPercent, maxHealth, minMissingHealth, clearShot);
    if (!UnitIsValid(target)) {
        target = FindCoreInGroup(scanGroup, player, aiUnit, minDist, maxDist, maxHealthPercent, clearShot);
    }

    return target;
}

//---------------------------------------------------------------------------------------------
unit FindClosestGate (unitgroup scanGroup, unit aiUnit, fixed maxDistance) {
    point unitPosition;
    int targetCount;
    unit target;
    fixed targetDistance;
    unit bestTarget;
    fixed bestDistance = maxDistance;
    unitgroup targets = UnitGroupFilterStructures(scanGroup);

    unitPosition = UnitGetPosition(aiUnit);
    targetCount = UnitGroupCount(targets, c_unitCountAll);

    // check all the units in the area
    while (targetCount > 0) {
        target = UnitGroupUnit(targets, targetCount);
        targetCount = targetCount - 1;

        // make sure unit is a valid gate
        if (!UnitIsValid(target)  || !UnitTypeTestFlag(UnitGetType(target), c_unitFlagTownStructureGate)) {
            continue;
        }

        targetDistance = DistanceBetweenPoints(unitPosition, UnitGetPosition(target));

        // make sure it is within the distance constraint
        if (targetDistance > bestDistance) {
            continue;
        }

        bestTarget = target;
        bestDistance = targetDistance;
    }

    return bestTarget;
}

//---------------------------------------------------------------------------------------------
unit FindStrongestNearbyAllyHero (int player, unit aiUnit, fixed maxDist, fixed minHealthPercent, bool excludeSelf) {
    // chosen by hitpoints, but at least a certain health percent
    region r;
    unitgroup nearbyAllies;
    int allyCount;
    unit unitToCheck;
    fixed unitHealth;
    fixed unitHealthPercent;
    unit resultUnit;
    fixed resultHealth = -1.0;

    // find nearby allied heroes
    r = RegionCircle(UnitGetPosition(aiUnit), maxDist);
    nearbyAllies = UnitGroupAlliance(player, c_unitAllianceAlly, r, null, c_noMaxCount);
    nearbyAllies = UnitGroupFilterHeroes(nearbyAllies);

    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally heroes in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies,allyCount);
        allyCount = allyCount - 1;

        if (excludeSelf && aiUnit == unitToCheck) {
            continue;
        }

        unitHealthPercent = UnitGetPropertyFixed(unitToCheck, c_unitPropLifePercent, c_unitPropCurrent);

        if (unitHealthPercent < minHealthPercent) {
            continue;
        }

        unitHealth = UnitGetPropertyFixed(unitToCheck, c_unitPropLife, c_unitPropCurrent);

        if (unitHealth > resultHealth) {
            resultUnit = unitToCheck;
            resultHealth = unitHealth;
        }
    }

    return resultUnit;
}

//---------------------------------------------------------------------------------------------
unit FindWeakestNearbyAllyHero (int player, unit aiUnit, fixed maxDist, fixed maxHealthPercent, fixed minMissingHealth, bool excludeSelf) {
    region r;
    unitgroup nearbyAllies;
    int allyCount;
    unit unitToCheck;
    fixed unitHealthPercent;
    unit resultUnit;
    fixed resultHealthPercent = maxHealthPercent;

    // find nearby allied heroes
    r = RegionCircle(UnitGetPosition(aiUnit), maxDist);
    nearbyAllies = UnitGroupAlliance(player, c_unitAllianceAlly, r, null, c_noMaxCount);
    nearbyAllies = UnitGroupFilterHeroes(nearbyAllies);

    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally heroes in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies,allyCount);
        allyCount = allyCount - 1;

        if (excludeSelf && aiUnit == unitToCheck) {
            continue;
        }

        unitHealthPercent = UnitGetPropertyFixed(unitToCheck, c_unitPropLifePercent, c_unitPropCurrent);

        if (unitHealthPercent < resultHealthPercent) {
            resultUnit = unitToCheck;
            resultHealthPercent = unitHealthPercent;
        }
    }

    return resultUnit;
}

//---------------------------------------------------------------------------------------------
unit FindBestHealTarget (int player, unit aiUnit, fixed maxDist, bool allowAnyHealing, bool excludeSelf) {
    region r;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unitgroup nearbyAllies;
    fixed humanHealBonus;
    int allyCount;
    unit unitToCheck;
    bool unitIsAI;
    fixed unitHealthPercent;
    unit bestUnit;
    bool bestUnitIsAI;
    fixed bestUnitHealthPercent;

    // find nearby allied heroes
    r = RegionCircle(UnitGetPosition(aiUnit), maxDist);
    nearbyAllies = UnitGroupAlliance(player, c_unitAllianceAlly, r, null, c_noMaxCount);
    nearbyAllies = UnitGroupFilterHeroes(nearbyAllies);

    if (excludeSelf) {
        UnitGroupRemove(nearbyAllies, aiUnit);
    }

    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally heroes in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies,allyCount);
        allyCount = allyCount - 1;
        if (!UnitIsValid(unitToCheck)) {
            continue;
        }

        unitHealthPercent = UnitGetPropertyFixed(unitToCheck, c_unitPropLifePercent, c_unitPropCurrent);

        unitIsAI = libAIAI_gf_HeroAIIsPlayerActive(UnitGetOwner(unitToCheck), libAIAI_gv_heroAIComputerPlayerType);
        if (!unitIsAI && (energy > libAIAI_gv_aIHeroLowEnergyPercent)) {
            humanHealBonus = 10.0;
        } else {
            humanHealBonus = 0.0;
        }

        if ((allowAnyHealing && unitHealthPercent <= 98.0)
            || unitHealthPercent < (65.0 + humanHealBonus)
            || (HaveBeenAttackedRecently(unitToCheck) && unitHealthPercent < (75.0 + (humanHealBonus/2.0)))) {
            // Check if this is better than our current best target
            if (UnitIsValid(bestUnit)) {
                // Prioritize human heroes over AI
                if (!unitIsAI && bestUnitIsAI) {
                    if (unitHealthPercent > bestUnitHealthPercent + libAIAI_gv_aIHeroPrioritizeHealingHumanAlliesThreshold[libAIAI_gv_aIHeroes[player].lv_difficulty]) {
                        continue;
                    }
                }
                else {
                    if (unitHealthPercent > bestUnitHealthPercent) {
                        continue;
                    }
                }
            }

            bestUnit = unitToCheck;
            bestUnitIsAI = unitIsAI;
            bestUnitHealthPercent = unitHealthPercent;
        }
    }

    return bestUnit;
}

//---------------------------------------------------------------------------------------------
fixed GetTotalLifeHealInBlast (int player, unit aiUnit, fixed maxDist, fixed healPerHero) {
    region r;
    unitgroup nearbyAllies;
    fixed unitHealthMax;
    fixed unitHealthExpected;
    fixed totalLifeHeal = 0.0;

    int allyCount;
    unit unitToCheck;

    // find nearby allied heroes
    r = RegionCircle(UnitGetPosition(aiUnit), maxDist);
    nearbyAllies = UnitGroupAlliance(player, c_unitAllianceAlly, r, null, c_noMaxCount);
    nearbyAllies = UnitGroupFilterHeroes(nearbyAllies);

    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally heroes in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies,allyCount);
        allyCount = allyCount - 1;

        if(UnitIsValid(unitToCheck)) {
            // This uses the expected final health value to decide how much healing can be done.
            unitHealthMax = UnitGetPropertyFixed(unitToCheck, c_unitPropLifeMax, c_unitPropCurrent);
            unitHealthExpected = UnitGetPropertyFixed(unitToCheck, c_unitPropLife, c_unitPropCurrent) + UnitGetPropertyFixed(unitToCheck, c_unitPropLifeExpected, c_unitPropCurrent);
            // Clamp to positive healing values because unitHealthExpected may be larger than unitHealthMax
            totalLifeHeal += MaxF(0, MinF(healPerHero, unitHealthMax - unitHealthExpected));
        }
    }

    return totalLifeHeal;
}

//---------------------------------------------------------------------------------------------
unit FindWeakestNearbyAllyTowers (int player, unit aiUnit, fixed maxDist, fixed maxHealthPercent, fixed minMissingHealth) {
    region r;
    unitgroup nearbyAllies;
    int allyCount;
    unit unitToCheck;
    fixed unitHealthPercent;
    unit resultUnit;
    fixed resultHealthPercent = maxHealthPercent;

    // find nearby allied towers
    r = RegionCircle(UnitGetPosition(aiUnit), maxDist);
    nearbyAllies = UnitGroupAlliance(player, c_unitAllianceAlly, r, null, c_noMaxCount);
    nearbyAllies = UnitGroupFilterTowers(nearbyAllies);

    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally towers in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies,allyCount);
        allyCount = allyCount - 1;

        unitHealthPercent = UnitGetPropertyFixed(unitToCheck, c_unitPropLifePercent, c_unitPropCurrent);

        if (unitHealthPercent < resultHealthPercent) {
            resultUnit = unitToCheck;
            resultHealthPercent = unitHealthPercent;
        }
    }

    return resultUnit;
}

//---------------------------------------------------------------------------------------------
unit FindClosestAllyMinion (int player, point center, fixed maxDist) {
    unitgroup nearbyAllies;
    unitgroup nearbyAllyMinions;
    int allyMinionCount;

    unit unitToCheck;
    point unitToCheckPosition;
    fixed unitToCheckDistance;

    unit resultUnit = null;
    fixed resultDistance = 999.0;

    nearbyAllies = AllyUnitsInArea(player, center, maxDist);
    nearbyAllyMinions = UnitGroupFilterMinions(nearbyAllies);
    allyMinionCount = UnitGroupCount(nearbyAllyMinions, c_unitCountAll);

    // check all the ally minions in the area
    while (allyMinionCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllyMinions, allyMinionCount);
        allyMinionCount = allyMinionCount - 1;

        unitToCheckPosition = UnitGetPosition(unitToCheck);
        unitToCheckDistance = DistanceBetweenPoints(center, unitToCheckPosition);

        if (unitToCheckDistance < resultDistance) {
            resultUnit = unitToCheck;
            resultDistance = unitToCheckDistance;
        }
    }

    return resultUnit;
}

//---------------------------------------------------------------------------------------------
int CountHeroesInGroup (unitgroup group) {
    return UnitGroupCount(UnitGroupFilterHeroes(group), c_unitCountAll);
}

//---------------------------------------------------------------------------------------------
int CountMinionsInGroup (unitgroup group) {
    return UnitGroupCount(UnitGroupFilterMinions(group), c_unitCountAll);
}

//---------------------------------------------------------------------------------------------
int CountCreepsInGroup (unitgroup group) {
    return UnitGroupCount(UnitGroupFilterAggroCreepsOrLanerCreeps(group), c_unitCountAll);
}

//---------------------------------------------------------------------------------------------
int CountHeroesInArea (unitgroup scanGroup, point center, fixed radius) {
    return UnitGroupCount(UnitsInArea(UnitGroupFilterHeroes(scanGroup), center, radius), c_unitCountAll);
}

//---------------------------------------------------------------------------------------------
bool AnyHeroesInArea (unitgroup scanGroup, point center, fixed radius) {
    return UnitGroupCount(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), RegionCircle(center, radius), 1), c_unitCountAll) > 0;
}

//---------------------------------------------------------------------------------------------
bool AnyEnemiesInArea (unitgroup scanGroup, point center, fixed radius) {
    region r = RegionCircle(center, radius);
    return (UnitGroupCount(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), r, 1), c_unitCountAll) > 0)
        || (UnitGroupCount(UnitGroupFilterRegion(UnitGroupFilterMinions(scanGroup), r, 1), c_unitCountAll) > 0)
        || (UnitGroupCount(UnitGroupFilterRegion(UnitGroupFilterAggroCreeps(scanGroup), r, 1), c_unitCountAll) > 0);
}

//---------------------------------------------------------------------------------------------
bool AnyAttackableUnitsInArea (unitgroup scanGroup, point center, fixed radius) {
    region r = RegionCircle(center, radius);
    return (UnitGroupCount(UnitGroupFilterRegion(UnitGroupFilterAttackable(scanGroup), r, 1), c_unitCountAll) > 0);
}

//---------------------------------------------------------------------------------------------
fixed EvalTargets (unitgroup targets) {
    int index;
    unit currentUnit;
    fixed score = 0.0;

    index = UnitGroupCount(targets, c_unitCountAll);
    while (index > 0) {
        currentUnit = UnitGroupUnit(targets, index);
        index -= 1;
        score += UnitGetPropertyFixed(currentUnit,  c_unitPropAIEvaluationFactor, c_unitPropCurrent);
    }
    return score;
}

//---------------------------------------------------------------------------------------------
// Returns true if the area has the required number of heroes, or the required number of minions,
// or a combination of the two, where the ratio of required minions to heroes is used to determine
// whether the number of minions plus heroes meets the threshold for the number of heroes.
// Note that units have an AIEvaluationFactor which may influence their worth.
bool EnoughEnemiesInArea (unitgroup scanGroup, point center, fixed radius, fixed minHeroes, fixed minAggroCreeps, fixed minMinions) {
    unitgroup enemies;
    fixed score = 0.0;

    enemies = UnitsInArea(scanGroup, center, radius);

    if (minHeroes != 0.0) {
        score += EvalTargets(UnitGroupFilterHeroes(enemies)) / minHeroes;
    }

    if (minAggroCreeps != 0.0) {
        score += UnitGroupCount(UnitGroupFilterAggroCreepsOrLanerCreeps(enemies), c_unitCountAll) / minAggroCreeps;
    }

    if (minMinions != 0.0) {
        score += UnitGroupCount(UnitGroupFilterMinions(enemies), c_unitCountAll) / minMinions;
    }
    // we account for precision loss so that 1/3 + 1/3 + 1/3 will return true
    return score >= 0.99;
}

//---------------------------------------------------------------------------------------------
// DEPRECATED - USE EnoughEnemiesInArea INSTEAD
int CountEnemiesInArea (unitgroup scanGroup, point center, fixed radius, int heroValue, int minionValue) {
    unitgroup enemies;
    int heroes;
    int minions;

    enemies = UnitsInArea(scanGroup, center, radius);
    heroes = CountHeroesInGroup(enemies);
    minions = CountMinionsInGroup(enemies);

    return heroValue * heroes + minionValue * minions;
}

//---------------------------------------------------------------------------------------------
int CountPlayersInUnitGroup (unitgroup group) {
    int index;
    int playerCount;
    int playerIndex;
    bool[libCore_gv_bALMaxPlayers + 1] playerSeen;

    playerCount = 0;
    index = UnitGroupCount(group, c_unitCountAll);

    for (; index > 0; index -= 1) {
        playerIndex = UnitGetOwner(UnitGroupUnit(group, index));

        // Filter out units not controlled by an active AI or human player
        if (playerIndex > libCore_gv_bALMaxPlayers) {
            continue;
        }

        // Update the count of unique players
        if (playerSeen[playerIndex] == false) {
            playerSeen[playerIndex] = true;
            playerCount += 1;
        }
    }

    return playerCount;
}

//---------------------------------------------------------------------------------------------
bool RequiredPlayerCountInUnitGroup (unitgroup group, int requiredPlayerCount) {
    int index;
    int playerCount;
    int playerIndex;
    bool[libCore_gv_bALMaxPlayers + 1] playerSeen;

    playerCount = 0;
    index = UnitGroupCount(group, c_unitCountAll);

    // If checking for absence of units, return true when nothing is found
    if (index == 0 && requiredPlayerCount == 0) {
        return true;
    }

    // Otherwise
    for (; index > 0; index -= 1) {
        playerIndex = UnitGetOwner(UnitGroupUnit(group, index));

        // Filter out units not controlled by an active AI or human player
        if (playerIndex > libCore_gv_bALMaxPlayers) {
            continue;
        }

        // Update the count of unique players
        if (playerSeen[playerIndex] == false) {
            playerCount += 1;
            if (playerCount >= requiredPlayerCount) {
                return true;
            }
            playerSeen[playerIndex] = true;
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
// When a positive integer is returned, it corresponds to how many heroes the player's enemy
// team outnumbers the player's team by.
// When a negative integer is returned, it corresponds to how many heroes the player's team
// outnumbers the enemy's team by.
int CountTeamOutnumberedBy (int player, unitgroup scanGroup, point center, fixed radius) {
    int enemyHeroCount;
    int allyHeroCount;

    enemyHeroCount = CountPlayersInUnitGroup(UnitGroupFilterHeroes(UnitsInArea(scanGroup, center, radius)));
    allyHeroCount = CountPlayersInUnitGroup(UnitGroupFilterHeroes(AllyUnitsInArea(player, center, radius)));

    return enemyHeroCount - allyHeroCount;
}

//---------------------------------------------------------------------------------------------
bool TeamFightInArea (int player, unitgroup scanGroup, point center, fixed radius) {
    region r = RegionCircle(center, radius);
    return RequiredPlayerCountInUnitGroup(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), r, c_noMaxCount), 2)
        && RequiredPlayerCountInUnitGroup(UnitGroupAlliance(player, c_unitAllianceAlly, r, c_Storm_AI_HeroFilter, c_noMaxCount), 2);
}

//-------------------------------------------------------------------------------------------------
bool ShouldLeavePassiveMount (int player, unit aiUnit, unitgroup scanGroup) {
    Storm_AI_TargetQueryOptions query;
    unit target;

    // If theres a teamfight beneath me, aggro creeps, or an enemy less than 5%
    if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 6.0)) {
        return true;
    }

    if (EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 6.0, 0, 1, 2)) {
        return true;
    }

    // Not low health, is there a low health enemy nearby?
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = 10;
    query.lv_maxHealthPercent = 5.0; // Super low on purpose
    query.lv_ignoreTargetsBehindGate = true;
    target = FindBestHero(scanGroup, aiUnit, query);

    if (target != null) {
        return true;
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool TeamFightInAllyAndEnemyAreas (int player, unitgroup scanGroup, point allyCenter, fixed allyRadius, point enemyCenter, fixed enemyRadius) {
    return RequiredPlayerCountInUnitGroup(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), RegionCircle(enemyCenter, enemyRadius), c_noMaxCount), 2)
        && RequiredPlayerCountInUnitGroup(UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(allyCenter, allyRadius), c_Storm_AI_HeroFilter, c_noMaxCount), 2);
}

//---------------------------------------------------------------------------------------------
bool TeamFightInAreaWithEnemyRadius(int player, unitgroup scanGroup, point center, fixed allyRadius, fixed enemyRadius) {
    return RequiredPlayerCountInUnitGroup(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), RegionCircle(center, enemyRadius), c_noMaxCount), 2)
        && RequiredPlayerCountInUnitGroup(UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, allyRadius), c_Storm_AI_HeroFilter, c_noMaxCount), 2);
}

//---------------------------------------------------------------------------------------------
bool RequiredEnemyPlayerCountInArea (int requiredPlayerCount, unitgroup scanGroup, point center, fixed radius) {
    return RequiredPlayerCountInUnitGroup(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), RegionCircle(center, radius), c_noMaxCount), requiredPlayerCount);
}

//---------------------------------------------------------------------------------------------
bool RequiredAllyPlayerCountInArea (int requiredPlayerCount, int player, point center, fixed radius) {
    return RequiredPlayerCountInUnitGroup(UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), c_Storm_AI_HeroFilter, c_noMaxCount), requiredPlayerCount);
}

//---------------------------------------------------------------------------------------------
unit FindUnitOfType (unitgroup scanGroup, int type) {
    int iterIndex;
    int targetUnitOwner;
    unit targetUnit;

    for (iterIndex = 1; iterIndex <= UnitGroupCount(scanGroup, c_unitCountAll); iterIndex += 1) {
        targetUnit = UnitGroupUnit(scanGroup, iterIndex);
        targetUnitOwner = UnitGetOwner(targetUnit);
        if (targetUnitOwner <= libCore_gv_bALMaxPlayers) {
            if (libGame_gv_players[targetUnitOwner].lv_heroData.lv_class == type) {
                return targetUnit;
            }
        }
    }
    return null;
}

//---------------------------------------------------------------------------------------------
bool TowardFarSideOfTheMap (int player, unit aiUnit) {
    point currentPos = UnitGetPosition(aiUnit);

    if (libCore_gf_TestLocationClosertoFactionSide(currentPos, libGame_gv_players[player].lv_faction, 0.8)) {
        return false;
    }
    return true;
}

//---------------------------------------------------------------------------------------------
bool UnitHasDebuffThatCanBeCleansed (unit unitToCheck) {
    int behaviourCount;
    int behaviorIndex;
    string behavior;
    int validatorCount;
    int validatorIndex;
    string validator;
    string scope;

    // Check for behaviors with Cleanse as a RemoveValidator
    behaviourCount = UnitBehaviorCountAll(unitToCheck);
    for ( behaviorIndex = 1 ; behaviorIndex <= behaviourCount ; behaviorIndex += 1 ) {
        behavior = UnitBehaviorGet(unitToCheck, behaviorIndex);
        scope = CatalogEntryScope(c_gameCatalogBehavior, behavior);
        if (CatalogFieldExists(scope, "RemoveValidatorArray")) {
            validatorCount = CatalogFieldValueCount(c_gameCatalogBehavior, behavior, "RemoveValidatorArray", c_playerAny);
            for ( validatorIndex = 1 ; validatorIndex <= validatorCount ; validatorIndex += 1) {
                validator = CatalogFieldValueGet(c_gameCatalogBehavior, behavior, "RemoveValidatorArray[" + IntToString((validatorIndex - 1)) + "]", c_playerAny);
                if (validator == "TargetCleanseDebuffRemoval") {
                    return true;
                }
            }
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
unit GetAllyToCleanse (int player, unit aiUnit) {
    unitgroup nearbyAllies;
    int allyCount;
    unit unitToCheck;

    nearbyAllies = AllyUnitsInArea(player, UnitGetPosition(aiUnit), 9.0);
    nearbyAllies = UnitGroupFilterHeroes(nearbyAllies);
    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally heroes in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies, allyCount);
        allyCount = allyCount - 1;

        if ((unitToCheck != aiUnit) && UnitHasDebuffThatCanBeCleansed(unitToCheck)) {
            return unitToCheck;
        }
    }

    return null;
}

//---------------------------------------------------------------------------------------------
int GetAbilitiesOnCooldown (int player) {
    int abilitiesOnCooldown = 0;
    int abilityIndex = 0;

    while (abilityIndex < 3) {
        if (libCore_gf_IsAbilityOnCooldown(libGame_gv_players[player].lv_heroUnit, AbilityCommandGetAbility(libAIAI_gv_aIHeroes[player].lv_castAbility[abilityIndex]))) {
            abilitiesOnCooldown = abilitiesOnCooldown + 1;
        }

        abilityIndex = abilityIndex + 1;
    }

    return abilitiesOnCooldown;
}

//---------------------------------------------------------------------------------------------
const string c_AB_UseItem = "StormInventory";

//---------------------------------------------------------------------------------------------
bool UseItem (int player, unit aiUnit, unitgroup scanGroup, funcref<Storm_AI_CheckUseItem> callback) {
    order ord;
    order ordTarget;
    order ordTogOn;
    order ordTogOff;
    unit invItem;
    string itemType;
    int itemIdx = 1;

    if (UnitTestState(aiUnit, c_unitStateHallucination)) {
        return false;
    }

    ord = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemInstant);
    ordTarget = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemTarget);
    ordTogOn = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemTogOn);
    ordTogOff = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemTogOff);
    while (itemIdx <= libCore_gv_bALPlayerActiveInventorySlots) {
        invItem = UnitInventoryItem(aiUnit, itemIdx);
        itemIdx = itemIdx + 1;

        if (!UnitIsValid(invItem)) {
            continue;
        }

        OrderSetTargetItem(ord, invItem);
        OrderSetTargetItem(ordTarget, invItem);
        OrderSetTargetItem(ordTogOn, invItem);
        OrderSetTargetItem(ordTogOff, invItem);
        if (!UnitOrderIsValid(aiUnit, ord)
         && !UnitOrderIsValid(aiUnit, ordTarget)
         && !UnitOrderIsValid(aiUnit, ordTogOn)
         && !UnitOrderIsValid(aiUnit, ordTogOff)) {
            continue;
        }

        itemType = UnitGetType(invItem);
        if (callback(player, aiUnit, scanGroup, itemType, ord, ordTarget, ordTogOn, ordTogOff)) {
            return true;
        }
    }
    return false;
}
//---------------------------------------------------------------------------------------------
// Item Abilities Tactical
//---------------------------------------------------------------------------------------------

const string c_FlashOfTheStorms = "FlashoftheStorms";

bool ItemFlashOfTheStorms(int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    point pos;
        // Blink to target position
        if (!HaveBeenAttackedRecently(aiUnit) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            return false;
        }
        pos = libAIAI_gf_HeroAIGetRetreatPosition(UnitGetOwner(aiUnit), 9.0, null);
        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueReplace, null, pos);
}

//---------------------------------------------------------------------------------------------
bool DefensiveItemCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    int itemIdx = 1;
    int towerIdx = 0;
    int tryIdx = 0;
    int callbackIdx = 0;
    fixed curHealth;
    fixed targetHealth;
    point pos;
    unit target;
    int unitGroupIndex;
    fixed chargesUsed;
    unit currentUnit;
    Storm_AI_TargetQueryOptions query;

    if (itemType == "TalentFirstAid" || itemType == "BarbarianFerociousHealingItem" || itemType == "CrusaderLawsOfHopeItem") {
        // Self heal
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 60.0) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "TalentArcanePower") {
        // Self restore
        if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < 50.0) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "ZagaraRapidIncubationItem") {
        // Channel to regenrate health and energy
        // Do not channel if being attacked
        if (!HaveBeenAttackedRecently(aiUnit) && (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 70.0 || UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < 50.0)) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "ChoTalentMoltenBlock") {
        // This code is very similar to below, but I removed the required allies because Cho is often alone
        // I also increased the health at which he will use this ability to make it a bit more offensive.
        // I also allow there to only be one hero nearby because molten block pulses with damage, so it's worth it regardless (but more optimal with more).
        if (HaveBeenAttackedRecently(aiUnit)
         && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 35.0
         && AnyHeroesInArea(scanGroup, UnitGetPosition(aiUnit), 7.5)) {
            UnitIssueOrder(aiUnit, ordTogOn, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "TalentBucketIceBlock" || itemType == "ImprovedIceBlockUnit" || itemType == "RexxarFeignDeath") {
        // Become invulnerable if you become very low health during a team fight
        if (HaveBeenAttackedRecently(aiUnit)
         && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 20.0
         && TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 9.0)) {
            UnitIssueOrder(aiUnit, ordTogOn, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "TalentStoneskin" || itemType == "KaelthasArcaneBarrierItem" || itemType == "SonyaTalentNervesOfSteel" || itemType == "TalentHardenedShield") {
        // Place a temporary shield on self
        if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 70.0) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "SonyaTalentIgnorePain") {
        // Place a temporary shield on self
        if (HaveBeenAttackedRecently(aiUnit)
         && (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 85.0
          || RequiredEnemyPlayerCountInArea(2, scanGroup, UnitGetPosition(aiUnit), 7.0))) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "TalentBucketSprint" || itemType == "KerriganQueensRush") {
        // Temporarily increase movement speed
        if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "TalentBerserk") {
        // Temporarily increase movement and attack speed
        // Use to flee faster
        if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }

        // Use in a team fight
        if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 9.0)) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }

        return false;
    }
    else if (itemType == "TalentImposingPresence") {

        // Use in a team fight
        if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 5.0)) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }

        return false;
    }
    else if (itemType == "TalentBloodForBlood" || itemType == "AzmodanSinforSinItem") {
        // Steals percentage of enemy's life from their maximum health capacity
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > 60.0) {
            return false;
        }

        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 6.0;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_minScore = c_Storm_AI_FullHeroScore; // prefer full hero for maximum steal
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "KerriganEssenceForEssenceItem") {
        // Steals percentage of enemies life as shields
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth || !HaveBeenAttackedRecently(aiUnit)) {
            return false;
        }

        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 6.0;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_minScore = c_Storm_AI_FullHeroScore; // prefer full hero for maximum steal
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "TalentBucketCalldownMule") {
        // Calls down a MULE to repair an ally tower
        target = FindWeakestNearbyAllyTowers(player, aiUnit, 15.0, 70.0, -1.0);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "FlashoftheStorms") {
        // Blink to target position

        return ItemFlashOfTheStorms(player, aiUnit, scanGroup, itemType, ord, ordTarget, ordTogOn, ordTogOff);

    }
    else if (itemType == "TalentBucketHealingWard" || itemType == "ShamanHealingWard") {
        // Place a healing ward
        target = FindWeakestNearbyAllyHero(player, aiUnit, 7.0, 70.0, -1.0, false);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueReplace, null, UnitGetPosition(target));
    }
    else if (itemType == "AzmodanGluttonousWardItem") {
        // Place a ward that heals self and your summoned units
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroMediumHealthPercent || !HaveBeenAttackedRecently(aiUnit)) {
            return false;
        }

        if (!AnyHeroesInArea(scanGroup, UnitGetPosition(aiUnit), 7.0)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueReplace, null, UnitGetPosition(aiUnit));
    }
    else if (itemType == "TalentBucketStormShield") {
        // cast area sheild
        target = FindWeakestNearbyAllyHero(player, aiUnit, 7.5, 70.0, -1.0, false);
        if (!UnitIsValid(target) || !HaveBeenAttackedRecently(target)) {
            return false;
        }

        return UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
    }
    else if (itemType == "ProtectiveShield") {
        // Places a temporary shield on an ally
        // Find a weak ally under attack other than self
        target = FindWeakestNearbyAllyHero(player, aiUnit, 7.0, libAIAI_gv_aIHeroHighHealthPercent, -1.0, true);
        if (!UnitIsValid(target)) {
            return false;
        }

        // Don't bother if the ally is 'safe' (not being attacked and not critically low health)
        // Use the generic health threshold to teleport home because our target may not be AI, and using our own health threshold may not make sense for the other hero.
        if (!HaveBeenAttackedRecently(target) && UnitGetPropertyFixed(target, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroTeleportPercent[(libAIAI_gv_aIHeroes[player].lv_difficulty)]) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "TalentBucketCleanse") {
        target = GetAllyToCleanse(player, aiUnit);
        if (!UnitIsValid(target)) {
            return false;
        }
        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "MonkEpiphanyItem") {
        // don't use if we have plenty of energy and we have any dash charges left
        if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) > libAIAI_gv_aIHeroLowEnergyPercent) {
            chargesUsed = UnitGetChargeUsed(aiUnit, CatalogFieldValueGet(c_gameCatalogAbil, "MonkDash", "Cost[0].Charge.Link", c_playerAny));
            if (chargesUsed == 0.0) {
                return false;
            }
            if (CatalogFieldValueGetAsInt(c_gameCatalogAbil, "MonkDash", "Cost[0].Charge.CountMax", c_playerAny) > chargesUsed) {
                return false;
            }
        }
        return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
    }
    else if (itemType == "RexxarHardenedSkinItem") {
        // Use this if any hero unit for the player has been attacked and is low on health (rexxar or misha).
        for (unitGroupIndex = UnitGroupCount(libGame_gv_players[player].lv_heroUnitGroup, c_unitCountAll); unitGroupIndex > 0; unitGroupIndex = unitGroupIndex - 1) {
            currentUnit = UnitGroupUnit(libGame_gv_players[player].lv_heroUnitGroup, unitGroupIndex);
            if (HaveBeenAttackedRecently(currentUnit) && UnitGetPropertyFixed(currentUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
                return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
            }
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool UseDefensiveItem (int player, unit aiUnit, unitgroup scanGroup) {
    return UseItem(player, aiUnit, scanGroup, DefensiveItemCallback);
}

//---------------------------------------------------------------------------------------------
bool OffensiveItemCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    const fixed scoutDroneLaneDistance = 13.0;
    Storm_AI_TargetQueryOptions query;
    unit target;
    point pos;
    region r;
    int unitGroupIndex = 1;
    bool isInShrub = false;

    if (itemType == "TalentOverdrive" || itemType == "IcyVeins") {
        // Temporarily buff abilities if we are in a team fight
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
            return false;
        }

        if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < libAIAI_gv_aIHeroLowEnergyPercent) {
            return false;
        }

        if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 7.0)) {
            return false;
        }

        UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
        return true;
    }
    else if (itemType == "SearingAttacks" || itemType == "TyrandeSearingArrows") {
        // Temporarily buff auto-attacks if we are in a team fight
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
            return false;
        }

        if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 9.0)) {
            return false;
        }

        UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
        return true;
    }
    else if (itemType == "TalentRewind" || itemType == "ColdSnapUnit") {
        // Reduces the cooldown of the QWE abilities
        if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < 25.0) {
            return false;
        }

        // Don't use if not enough enemies around
        if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 8.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
            return false;
        }

        if (GetAbilitiesOnCooldown(player) < 2) {
            return false;
        }

        UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
        return true;
    }
    else if (itemType == "TalentBucketBribe" || itemType == "RaynorRaidersRecruitment" || itemType == "FaerieDragonPixieCharm") {
        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 6.0;
        query.lv_healthFactor = c_Storm_AI_PreferHealthyTargets;
        target = FindBestPassiveCampCreep(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "TalentBucketShrinkRay") {
        // Reduce an enemy heroes damage if we are in a team fight
        if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 7.0)) {
            return false;
        }

        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 6.5;
        query.lv_minScore = c_Storm_AI_FullHeroScore;
        query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "TalentBucketPromote" || itemType == "TalentInfestItem") {
        // Buff a ally minion
        target = FindClosestAllyMinion(UnitGetOwner(aiUnit), UnitGetPosition(aiUnit), 7.0);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "TalentBucketClairvoyance" || itemType == "RexxarFlare") {
        // NOTE: if this is changed to affect a much wider area, RexxarFlare should be separated out, because it only has a shortish range.
        // drops an area that reveals enemies
        // Use when we have been damaged a lot but there are no enemies in sight, and we are not near a tower
        pos = UnitGetPosition(aiUnit);
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth
            && CountEnemiesInArea(scanGroup, pos, 20.0, 1, 1) == 0
            && !UnitIsValid(GetNearbyTower(aiUnit, scanGroup))) {
            return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, null, pos);
        }

        // also check for decloaking nearby players
        target = libAIAI_gf_HeroAIGetCloakedEnemyToReveal(player);
        if (UnitIsAlive(target)) {
            if (HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, null, UnitGetPosition(target))) {
                libAIAI_gf_HeroAIResetRevealCloakedEnemyTimer(player);
                return true;
            }
        }

        // also check for enemy gates to reveal enemies behind
        target = FindClosestGate(scanGroup, aiUnit, 18.0); // within the range of RexxarFlare
        if (UnitIsAlive(target)) {
            return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, null, UnitGetPosition(target));
        }
    }
    else if (itemType == "ScoutingDroneItem" || itemType == "GallEyeOfKilroggItemUnit") {
        pos = UnitGetPosition(aiUnit);

        if (HaveBeenAttackedRecently(aiUnit)) {
            return false;
        }

        isInShrub = InShrub(pos);

        // If not in a shrub, calculate lane distance.
        if (!isInShrub) {
            libGame_gf_CalculateClosestLaneData(pos);
        }

        // Use is in shrub again to avoid going to the array.
        if (isInShrub
         || libGame_gv_closestLaneData.lv_laneData[libGame_gv_closestLaneData.lv_closestLane].lv_closestDist >= scoutDroneLaneDistance) {
            r = RegionCircle(pos, 15.0);
            // If we find an allied scouting drone, we exit early because we already have coverage.
            if (UnitGroupCount(UnitGroupFilterAlliance(UnitGroup("ScoutingDrone", c_playerAny, r, null, 0), player, c_unitAllianceAlly, 1), c_unitCountAll) > 0) {
                return false;
            }

            // If we find an allied scouting drone, we exit early because we already have coverage.
            if (UnitGroupCount(UnitGroupFilterAlliance(UnitGroup("GallEyeOfKilroggPlacedUnit", c_playerAny, r, null, 0), player, c_unitAllianceAlly, 1), c_unitCountAll) > 0) {
                return false;
            }
            return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, null, pos);
        }
    }
    else if (itemType == "AbathurLocustSwarm") {
        // Summons three locusts at target position
        pos = UnitGetPosition(aiUnit);

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, null, pos);
    }
    else if (itemType == "Envenom") {
        // Put a DoT on enemy hero
        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 5.0;
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_minScore = c_Storm_AI_FullHeroScore;
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "DiabloTalentLordOfTerror") {
        // Steal life from enemy hero
        ResetTargetQueryOptions(query);
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            query.lv_maxHealthPercent = 100.0;
        }
        else {
            query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
        }
        query.lv_maxDistance = 6.0;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_minScore = c_Storm_AI_FullHeroScore;
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
    }
    else if (itemType == "AzmodanSinsGraspItem") {
        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 8.0;
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }
        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool UseOffensiveItem (int player, unit aiUnit, unitgroup scanGroup) {
    return UseItem(player, aiUnit, scanGroup, OffensiveItemCallback);
}

//---------------------------------------------------------------------------------------------
bool RevealCloakedEnemies (int player, unit aiUnit, unitgroup scanGroup) {
    if (UnitTestState(aiUnit, c_unitStateHallucination)) {
        return false;
    }
    else {
        return libAIAI_gf_HeroAIRandomlyCastAbilityOnCloakedEnemy(player);
    }
}

//---------------------------------------------------------------------------------------------
bool HeroSkipTactical (int player, unit aiUnit) {
    abilcmd currentAbility;

    // Check if this is a valid AI controlled hero. Only allowing this for players 1-10 so that
    // all tactical functions don't have to worry about checking for players 11 and 12.
    if (player <= 0 || player > libCore_gv_bALMaxPlayers || libAIAI_gf_HeroAIIsAIEnabledForPlayer(player) == false) {
        return true;
    }

    // Special Hero
    if (UnitTestState(aiUnit, c_unitStateHallucination)) {
        // Abathur coppied hero
        if (UnitHasBehavior(aiUnit, c_AbathurUltimateEvolutionControlBehavior)) {
            abathurUltimateEvolutionUnit[player - 1] = aiUnit;
            return false;
        }

        return true;
    }
    // Regular hero
    else {
        // No tactical if the AI in the triggers doesn't want us to
        if (player <= libCore_gv_bALMaxPlayers) {
            if (libAIAI_gf_HeroAIShouldSkipTactical(player) == true) {
                return true;
            }

            // Only ignore spell casting delay for Defensive spells when there is a human ally on the team
            if (libAIAI_gf_HeroAITeamHasHumanPlayers(libGame_gv_players[player].lv_faction) == false && libAIAI_gv_aIHeroes[player].lv_nextOffensiveSpellCheckTime > TimerGetElapsed(libGame_gv_gameTimer)) {
                return true;
            }
        }

        if ((UnitOrder(aiUnit, 0) != null)) {
            currentAbility = OrderGetAbilityCommand(UnitOrder(aiUnit, 0));

            // No tactical while hearthing
            if (currentAbility == AbilityCommand("PortBackToBase", 0)) {
                return true;
            }

            // No tactical while capturing a map mechanic
            if (currentAbility == AbilityCommand("CaptureMacGuffin", 0) || currentAbility == AbilityCommand("CaptureMacGuffinTwo", 0)) {
                return true;
            }

            // No tactical while capturing a map vehicle (e.g. Sylvanas couldn't enter because of a 3-second cooldown ability).
            if (currentAbility == AbilityCommand("UseVehicle", 0)) {
                return true;
            }
        }

        // No tactical driving vehicle
        if (UnitHasBehavior(aiUnit, "UsingVehicle") == true) {
            return true;
        }

        //skip if we're dead.
        if(UnitIsAlive(aiUnit) == false){
            return true;
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool HeroSkipOffensiveTactical (int player, unit aiUnit) {
    // No tactical if we have already used a spell recently
    if (player > libCore_gv_bALMaxPlayers) {
        return false;
    }

    if (libAIAI_gv_aIHeroes[player].lv_nextOffensiveSpellCheckTime > TimerGetElapsed(libGame_gv_gameTimer)) {
        return true;
    }

    if ((UnitOrder(aiUnit, 0) != null)) {
        // No tactical while mounting
        if (OrderGetAbilityCommand(UnitOrder(aiUnit, 0)) == libAIAI_gv_aIHeroes[player].lv_mountAbility) {
            return true;
        }
    }

    // No tactical while mounted
    if (UnitHasBehavior(aiUnit, libAIAI_gv_aIHeroes[player].lv_mountBehavior) == true) {
        return true;
    }

    return false;
}

//---------------------------------------------------------------------------------------------
// This function will return the ratio of enemies to allies in the area, scaling up from 0.
// [0, 1) means allies are favored, 1 is even, (1, N] is Enemies are favored in a N to 1 advantage.
bool ShouldEnterTeamfight (int player, point position, unitgroup scanGroup, fixed minThreshold, fixed maxThreshold) {
    fixed enemyEvaluationFactor;
    fixed allyEvaluationFactor;
    fixed teamfightFactor;
    fixed fightRadius = 8.0;
    unitgroup nearbyEnemies;
    unitgroup nearbyAllies;
    int enemyHeroCount;
    int allyHeroCount;


    nearbyEnemies = UnitsInArea(scanGroup, position, fightRadius);
    enemyHeroCount = CountPlayersInUnitGroup(UnitGroupFilterHeroes(nearbyEnemies));
    // We count this as a small engagement, not teamfights
    if (enemyHeroCount < 3) {
        return false;
    }

    nearbyAllies = AllyUnitsInArea(player, position, fightRadius);
    allyHeroCount = CountPlayersInUnitGroup(UnitGroupFilterHeroes(nearbyAllies));
    if (allyHeroCount < 3) {
        return false;
    }

    // Tentatively include towers because we want to value teamfights under towers differently.
    enemyEvaluationFactor = libAIAI_gf_HeroAIEnemyEvalInCircle(player, position, fightRadius, true, false, false);
    allyEvaluationFactor = libAIAI_gf_HeroAIAllyEvalInCircle(player, position, fightRadius, true, false, false);

    if (allyEvaluationFactor == 0.0
        || enemyEvaluationFactor == 0.0) {
        return false;
    }

    teamfightFactor = enemyEvaluationFactor / allyEvaluationFactor;

    // Clamp it to our return values.
    return teamfightFactor >= minThreshold && teamfightFactor <= maxThreshold;
}

//---------------------------------------------------------------------------------------------
// Begin Hero Tactical
//---------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------
// Blank Tactical (used for heroes in development and places we intentionally want to disable tactical AI)
//---------------------------------------------------------------------------------------------
void AIThinkBlank (int player, unit aiUnit, unitgroup scanGroup) {
    return;
}

//---------------------------------------------------------------------------------------------
// Nova Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_NovaSnipeStorm         = "NovaSnipeStorm";
const string c_AB_NovaPinningShot        = "NovaPinningShot";
const string c_AB_NovaHoloDecoy          = "NovaHoloDecoy";
const string c_AB_NovaTripleTap          = "NovaTripleTap";
const string c_AB_NovaPrecisionStrike    = "NovaPrecisionStrike";

//---------------------------------------------------------------------------------------------
bool NovaSnipeStorm (int player, unit aiUnit, unitgroup scanGroup) {
    // Skill-shot, high damage single target
    order spellOrd;
    unit targetEnemy;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaSnipeStorm, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = 100.0;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }

    // Shoot any nearby enemy if there is a clear shot
    query.lv_maxDistance = 10.0;
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets; // the high dmg will be more effective on unhealthy targets
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // Shoot a minion if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        //set the target query options for finding the best minion to shoot.
        query.lv_maxHealthPercent = 100.0;
        targetEnemy = FindBestMinion(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool NovaPinningShot (int player, unit aiUnit, unitgroup scanGroup) {
    // Damage and slow enemy target
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaPinningShot, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = 100.0;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }

    // Use if there is a weak enemy nearby and attack them
    query.lv_maxDistance = 8.0;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets; // the slow will be more effective on closer targets
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // Shoot a minion if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        // set the options for finding the best minion
        query.lv_distanceFactor = 0.0;
        query.lv_maxHealthPercent = 100.0;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        targetEnemy = FindBestMinion(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool NovaHoloDecoy (int player, unit aiUnit, unitgroup scanGroup) {
    // Creates a copy of Nova at nearby position to fool enemies
    order ord;

    ord = StormHeroAICreateOrder(player, c_AB_NovaHoloDecoy, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Use when low health to run away safely
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, UnitGetPosition(aiUnit));
}

//---------------------------------------------------------------------------------------------
bool NovaTripleTap (int player, unit aiUnit, unitgroup scanGroup) {
    // Shoots three shots at target enemy after a short delay
    order spellOrd;
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaTripleTap, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Use if there is a weak enemy nearby and attack them
    query.lv_maxDistance = 12.0;
    query.lv_maxHealthPercent = 60.0;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to use heroic ability on main heroes
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool NovaPrecisionStrike (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals aoe damage/slows enemies and has unlimited range
    order spellOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaPrecisionStrike, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_minDistance = 1.0;
    query.lv_maxDistance = 500.0;
    query.lv_maxHealthPercent = 70.0;
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to use heroic ability on main heroes
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    // Only cast if it will hit many enemies
    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetHero), 5.0, c_Storm_AI_AtLeast2Heroes, 0.0, 8.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkNova (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (NovaHoloDecoy(player, aiUnit, scanGroup)) {
        return;
    }

    if (NovaPinningShot(player, aiUnit, scanGroup)) {
        return;
    }

    if (NovaSnipeStorm(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && NovaTripleTap(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && NovaPrecisionStrike(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Nova HoloClone Tactical
//---------------------------------------------------------------------------------------------
const string c_HoloDecoyNoMastery1Disabler      = "HoloDecoyNoMastery1Disabler";

//---------------------------------------------------------------------------------------------
bool NovaHoloCloneSnipe (int player, unit aiUnit, unitgroup scanGroup) {
    // Skill-shot, high damage single target
    order spellOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaSnipeStorm, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (targetEnemy == null) {
        targetEnemy = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
    }
    if (targetEnemy == null) {
        return false;
    }

    OrderSetTargetPoint(spellOrd, UnitGetPosition(targetEnemy));
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    return true;
}

//---------------------------------------------------------------------------------------------
bool NovaHoloClonePinningShot (int player, unit aiUnit, unitgroup scanGroup) {
    // Damage and slow enemy target
    order spellOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaPinningShot, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (targetEnemy == null) {
        targetEnemy = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
    }
    if (targetEnemy == null) {
        return false;
    }

    OrderSetTargetUnit(spellOrd, targetEnemy);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    return true;
}

//---------------------------------------------------------------------------------------------
void AIThinkNovaHoloClone (int player, unit aiUnit, unitgroup scanGroup) {
    // Only cast abilities if Nova has the HoloDecoy talent
    if (UnitHasBehavior(aiUnit, c_HoloDecoyNoMastery1Disabler) == true) {
        return;
    }

    if (NovaHoloCloneSnipe(player, aiUnit, scanGroup)) {
        return;
    }

    if (NovaHoloClonePinningShot(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Zeratul Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_ZeratulCleave             = "ZeratulCleave";
const string c_AB_ZeratulSingularitySpike   = "ZeratulSingularitySpike";
const string c_AB_ZeratulBlinkStorm         = "ZeratulBlinkStorm";
const string c_AB_ZeratulVoidPrison         = "ZeratulVoidPrison";
const string c_AB_ZeratulShadowAssault      = "ZeratulShadowAssault";

//---------------------------------------------------------------------------------------------
bool ZeratulCleave (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE cleave, damages nearby enemies
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    unit nearbyHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ZeratulCleave, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast if there is a weak hero
    query.lv_maxDistance = 3.0;
    query.lv_maxHealthPercent = 50.0;
    nearbyHero = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(nearbyHero)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Cast if there is a large number of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast3Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool ZeratulSingularitySpike (int player, unit aiUnit, unitgroup scanGroup) {
    // Skill-shot bomb that sticks to a target, after a delay it damages & slows the target
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ZeratulSingularitySpike, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = 100.0;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }

    query.lv_maxDistance = 8.0;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // Shoot a minion if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        // set the query options for targeting a minion
        query.lv_maxHealthPercent = 100.0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool ZeratulBlinkStorm (int player, unit aiUnit, unitgroup scanGroup) {
    // Teleports zeratul a short distance and cloaks him for a brief period

    // Two uses:
    //   Run away to live
    //   Catch a fleeing enemy hero
    unit targetEnemy;
    point retreatPos;
    order spellOrd;
    order attackOrd;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ZeratulBlinkStorm, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Retreat if you have low health
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // Blink back to retreat to safety
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 8.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Don't jump into battle if have low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find a target hero
    query.lv_minDistance = 2.0;
    query.lv_maxDistance = 8.0;
    query.lv_maxHealthPercent = 50.0;
    query.lv_ignoreTargetsBehindGate = true;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool ZeratulVoidPrison (int player, unit aiUnit, unitgroup scanGroup) {
    // creates a bubble that stuns all units inside, but also makes them invulnerable
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ZeratulVoidPrison, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // find a weak enemy who is getting away
    query.lv_minDistance = 2.0;
    query.lv_maxDistance = 5.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to cast heroic on a full hero.
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    if (HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null)) {
        HeroClaimForTactical(player, 0.25, false);
        return true;
    }
    return false;
}

//---------------------------------------------------------------------------------------------
bool ZeratulShadowAssault (int player, unit aiUnit, unitgroup scanGroup) {
    // Temporary cloak
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ZeratulShadowAssault, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use when low health to run away safely
    if (!HaveBeenAttackedRecently(aiUnit) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkZeratul (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (ZeratulBlinkStorm(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && ZeratulShadowAssault(player, aiUnit, scanGroup)) {
        return;
    }

    if (ZeratulCleave(player, aiUnit, scanGroup)) {
        return;
    }

    if (ZeratulSingularitySpike(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && ZeratulVoidPrison(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Sgt Hammer Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_SgtHammerSiegeMode            = "SgtHammerSiegeMode";
const string c_AB_SgtHammerTankMode             = "SgtHammerTankMode";
const string c_AB_SgtHammerConcussiveBlast      = "SgtHammerConcussiveBlast";
const string c_AB_SgtHammerMineField            = "SgtHammerSpiderMines";
const string c_AB_SgtHammerNapalmStrike         = "SgtHammerNapalmStrike";
const string c_AB_SgtHammerBluntForceGun        = "SgtHammerBluntForceGun";
const string c_AB_SgtHammerThrusters            = "SgtHammerThrusters";

//---------------------------------------------------------------------------------------------
bool SgtHammerThrusters (int player, unit aiUnit, unitgroup scanGroup) {
    // Increases movement speed
    // For now used only for fleeing
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SgtHammerThrusters, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Retreat if you have low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) >= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool SgtHammerSiegeMode (int player, unit aiUnit, unitgroup scanGroup) {
    // If Sgt Hammer is in tank mode, check if we should convert him to siege mode
    Storm_AI_TargetQueryOptions query;
    order spellOrd;
    order moveOrd;
    fixed range;
    fixed curHealth;
    unit tower;
    fixed dist;
    fixed directionAngle;
    point heroPos;
    point inFrontOfHero;
    point towerPos;
    int addToFront = c_orderQueueAddToFront;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SgtHammerSiegeMode, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // If we've been attacked recently then don't siege
    if (HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }

    // If low on health don't siege
    curHealth = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    if (curHealth < 50.0) {
        return false;
    }

    if (!libAIAI_gf_HeroAIIsSafe(player)) {
        return false;
    }

    heroPos = UnitGetPosition(aiUnit);
    range = libAIAI_gf_AIGetActiveWeaponRange(aiUnit) + 5.0;

    if (!EnoughEnemiesInArea(scanGroup, heroPos, range, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        // also check for creeps that are activated because we want to be able to siege during a camp attack.
        query.lv_maxDistance = range;
        if (!UnitIsValid(FindBestAggroCreep(scanGroup, aiUnit, query))) {
            // If not enough enemy around but near tower then still convert
            // The extra 5 range is used to find towers just outside of your siege range.
            query.lv_maxDistance = range + 5;
            query.lv_distanceFactor= c_Storm_AI_PreferCloserTargets;
            tower = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
            if (!UnitIsValid(tower)) {
                return false;
            }

            // Move away from tower towards max weapon range and then siege
            moveOrd = StormHeroAICreateOrder(player, c_Storm_AB_Move, 0);
            if (!UnitOrderIsValid(aiUnit, moveOrd)) {
                return false;
            }

            towerPos = UnitGetPosition(tower);
            dist = DistanceBetweenPoints(heroPos, towerPos) - range - 1.0;
            directionAngle = AngleBetweenPoints(heroPos, towerPos);
            inFrontOfHero = PointWithOffsetPolar(heroPos, dist, directionAngle);
            OrderSetTargetPoint(moveOrd, inFrontOfHero);
            if (!UnitOrderIsValid(aiUnit, moveOrd)) {
                return false;
            }
            UnitIssueOrder(aiUnit, moveOrd, c_orderQueueReplace);
            addToFront = c_orderQueueAddToEnd;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, addToFront, null, null);
 }

//---------------------------------------------------------------------------------------------
bool SgtHammerTankMode (int player, unit aiUnit, unitgroup scanGroup) {
    // If Sgt Hammer is in siege mode, check if we should convert him to tank mode
    order spellOrd;
    bool leaveSiege = false;
    fixed range;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SgtHammerTankMode, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // if we're trying to do something other than fighting, leave siege mode
    if (libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSFollowerGuardLeaderLeash) {
        leaveSiege = true;
    }
    // If we're low health, leave seige mode
    else if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 45.0) {
        leaveSiege = true;
    }
    // If it's not safe anymore, leave seige mode
    else if (!libAIAI_gf_HeroAIIsSafe(player)) {
        leaveSiege = true;
    }
    else {
        range = libAIAI_gf_AIGetActiveWeaponRange(aiUnit);
        if (range < 8) {
            range = 8;
        }

        // Leave siege if there is nothing left to attack
        if (!AnyEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), range)) {
            if (UnitGroupCount(UnitsInArea(UnitGroupFilterTowers(scanGroup), UnitGetPosition(aiUnit), range), c_unitCountAll) == 0) {
                leaveSiege = true;
            }
        }
    }

    if (!leaveSiege) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
}

//---------------------------------------------------------------------------------------------
bool SgtHammerConcussiveBlast (int player, unit aiUnit, unitgroup scanGroup) {
    // pushes back all enemies in a cone and deals damage
    order ord;
    unit targetEnemy;
    fixed directionAngle;
    point heroPos;
    point inFrontOfHero;
    Storm_AI_TargetQueryOptions query;

    ord = StormHeroAICreateOrder(player, c_AB_SgtHammerConcussiveBlast, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Only push away units if they are attacking you
    if (!HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }

    // find a target enemy
    query.lv_maxDistance = 6.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    // check how many enemies are in that direction
    heroPos = UnitGetPosition(aiUnit);
    directionAngle = AngleBetweenPoints(heroPos, UnitGetPosition(targetEnemy));
    inFrontOfHero = PointWithOffsetPolar(heroPos, 3, directionAngle);

    if (!EnoughEnemiesInArea(scanGroup, inFrontOfHero, 3.5, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast4Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, inFrontOfHero);
 }

//---------------------------------------------------------------------------------------------
bool SgtHammerSpiderMines (int player, unit aiUnit, unitgroup scanGroup) {
    // Drops mines at a nearby location
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unitgroup nearbyEnemies;
    unitgroup nearbyEnemyHeroes;
    unit targetEnemy;
    point center;
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SgtHammerMineField, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast on a weak enemy hero
    query.lv_maxDistance = 5.5;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(targetEnemy)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
    }

    // Center on heroes if any are nearby
    nearbyEnemies = UnitsInArea(scanGroup, UnitGetPosition(aiUnit), 5.5);
    nearbyEnemyHeroes = UnitGroupFilterHeroes(nearbyEnemies);

    if (UnitGroupCount(nearbyEnemyHeroes, c_unitCountAll) > 0) {
        center = UnitGroupCenterOfGroup(nearbyEnemyHeroes);
    }
    // Target minions instead
    else {
        query.lv_maxHealthPercent = 100.0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }

        center = UnitGetPosition(targetEnemy);
    }

    // Cast if there is a large number of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast2Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1HighValueHero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    if (!EnoughEnemiesInArea(scanGroup, center, 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, center);
 }

 //---------------------------------------------------------------------------------------------
bool SgtHammerNapalmStrike (int player, unit aiUnit, unitgroup scanGroup) {
    // Attack that damages all enemies in an area
    order ord;
    unitgroup largeScanGroup;
    unit targetEnemy;
    fixed range;
    Storm_AI_TargetQueryOptions query;

    ord = StormHeroAICreateOrder(player, c_AB_SgtHammerNapalmStrike, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    range = UnitAbilityEffectInstantGetRange(aiUnit, c_AB_SgtHammerNapalmStrike);

    // This skill's range is so large we have to scan a new larger scanGroup
    largeScanGroup = UnitGroupSearch(null, player, UnitGetPosition(aiUnit), range, UnitFilter((1 << c_targetFilterVisible) | (1 << c_targetFilterEnemy), 0, 0, 0), c_noMaxCount);

    // Find a target hero
    query.lv_maxDistance = range;
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to cast heroic on a full hero.
    targetEnemy = FindBestHero(largeScanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetEnemy), 3.0, c_Storm_AI_AtLeast1HighValueHero, 0.0, c_Storm_AI_AtLeast4Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
 }

//---------------------------------------------------------------------------------------------
bool SgtHammerBluntForceGun (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals damage to large area in front of hero
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    order spellOrd;
    point targetPosition;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SgtHammerBluntForceGun, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // use in a teamfight
    if (CountHeroesInGroup(scanGroup) < 2 || CountHeroesInGroup(AllyUnitsInArea(player, UnitGetPosition(aiUnit), 16.0)) < 2) {
        return false;
    }

    // Find a target hero
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to cast heroic on a full hero.
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    targetPosition = UnitGetPosition(targetEnemy);
    if (!EnoughEnemiesInArea(scanGroup, targetPosition, 4.0, c_Storm_AI_AtLeast2Heroes, 0.0, c_Storm_AI_AtLeast6Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPosition);
}

//---------------------------------------------------------------------------------------------
bool SgtHammerAttackUnitToDecloak(int player, unit aiUnit, unitgroup scanGroup) {
    // Attack a unit to decloak ourselves because when cloaked we do not acquire targets, and normal attack commands won't happen at long range
    order attackOrd;
    unit targetEnemy;
    unitgroup enemies;
    Storm_AI_TargetQueryOptions query;
    unitfilter filter = UnitFilter(0, 0, 0, (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32)) | (1 << (c_targetFilterPassive - 32)) | (1 << (c_targetFilterBenign - 32)));

    if (UnitTestState(aiUnit, c_unitStateCloaked)) {
        attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
        if (!UnitOrderIsValid(aiUnit, attackOrd)) {
            return false;
        }

        // We want to consider only those enemies that are not dead/hidden/invulnerable/passive/benign. This is because we want to include heroes, minions, summoned, towers, creeps
        // but not passive creeps and not destructible barrels (which are also passive).
        enemies = UnitGroupFilter(null, c_playerAny, scanGroup, filter, 0);
        query.lv_maxDistance = libAIAI_gf_AIGetActiveWeaponRange(aiUnit);
        targetEnemy = FindBestUnit(enemies, scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }

        OrderSetTargetUnit(attackOrd, targetEnemy);
        UnitIssueOrder(aiUnit, attackOrd, c_orderQueueReplace);
        return true;
    }
    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkSgtHammer (int player, unit aiUnit, unitgroup scanGroup) {
    if (libAIAI_gf_HeroAIIsAIEnabledForPlayer(player) == false) {
        return;
    }

    if (SgtHammerTankMode(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (SgtHammerThrusters(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (SgtHammerConcussiveBlast(player, aiUnit, scanGroup)) {
        return;
    }

    if (SgtHammerSiegeMode(player, aiUnit, scanGroup)) {
        return;
    }

    if (SgtHammerSpiderMines(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && SgtHammerNapalmStrike(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && SgtHammerBluntForceGun(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (SgtHammerAttackUnitToDecloak(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Tassadar Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_TassadarPlasmaShield          = "TassadarPlasmaShield";
const string c_AB_TassadarPsionicStorm          = "TassadarPsionicStorm";
const string c_AB_TassadarPsionicStormPT        = "TassadarPsionicStormSecondStrike";
const string c_AB_TassadarDimensionalShift      = "TassadarDimensionalShift";
const string c_AB_TassadarArchon                = "TassadarArchon";
const string c_AB_TassadarForceWall             = "TassadarForceWall";
const string c_AB_TassadarOracle                = "TassadarOracle";

//---------------------------------------------------------------------------------------------
bool TassadarPlasmaShield (int player, unit aiUnit, unitgroup scanGroup) {
    // Shields a single target for 10-15 seconds
    order ord;
    fixed curHealth;
    unit targetUnit;
    fixed targetHealth;

    ord = StormHeroAICreateOrder(player, c_AB_TassadarPlasmaShield, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // If low health shield ourself first
    curHealth = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    if (HaveBeenAttackedRecently(aiUnit) && curHealth < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, aiUnit, null)) {
            return true;
        }
    }

    // Find weakest nearby ally hero
    targetUnit = FindWeakestNearbyAllyHero(player, aiUnit, 10.0, curHealth - 10.0, -1.0, false);

    if (UnitIsValid(targetUnit)) {
        targetHealth = UnitGetPropertyFixed(targetUnit, c_unitPropLifePercent, c_unitPropCurrent);
        if (HaveBeenAttackedRecently(targetUnit) && targetHealth < 70.0) {
            if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null)) {
                return true;
            }
        }
    }

    // Else shield ourself
    if (HaveBeenAttackedRecently(aiUnit) && curHealth < 70.0) {
        if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, aiUnit, null)) {
            return true;
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool TassadarDimensionalShift (int player, unit aiUnit, unitgroup scanGroup) {
    // Become invisible/invincible and gain movement speed
    order ord;
    fixed energy;
    fixed health;

    energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    health = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    ord = StormHeroAICreateOrder(player, c_AB_TassadarDimensionalShift, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }
    // don't use if we're not being attacked.
    if (!HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }
    // When high energy, use to end offensives
    if ((energy > libAIAI_gv_aIHeroMediumEnergyPercent) && (health < libAIAI_gv_aIHeroes[player].lv_endOffensiveHealth)) {
        return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
    }

    // Use when low health to run away safely
    if (health > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool TassadarPsiStormGeneric (order spellOrd, int player, unit aiUnit, unitgroup scanGroup) {
    // Use same logic for both the base skill and the relic varient
    unitgroup nearbyEnemies;
    unitgroup nearbyEnemyHeroes;
    unit target;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    Storm_AI_TargetQueryOptions query;

    // Cast on a weak enemy hero
    query.lv_maxDistance = 10.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    target = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(target)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(target));
    }

    // Cast on a group
    query.lv_minScore = 0;
    query.lv_maxHealthPercent = 100.0;
    target = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (!UnitIsValid(target)) {
        return false;
    }

    targetPos = UnitGetPosition(target);

    // Cast if there is a large number of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast3Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    // Only use on large group of enemies
    if (!EnoughEnemiesInArea(scanGroup, targetPos, 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TassadarPsionicStorm (int player, unit aiUnit, unitgroup scanGroup) {
    // Casts psi storm, damaging enemies in a small area.
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TassadarPsionicStorm , 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    return TassadarPsiStormGeneric(spellOrd, player, aiUnit, scanGroup);
}

//---------------------------------------------------------------------------------------------
bool TassadarPsionicStormSecondStrike (int player, unit aiUnit, unitgroup scanGroup) {
    // A second psistorm (on a different cooldown, due to level 16 SecondStrike talent).
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TassadarPsionicStormPT , 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    return TassadarPsiStormGeneric(spellOrd, player, aiUnit, scanGroup);
}

//---------------------------------------------------------------------------------------------
bool TassadarForceWall (int player, unit aiUnit, unitgroup scanGroup) {
    // Creates a "sentry" wall that can block an enemy hero from running away
    order spellOrd;
    order attackOrd;
    unit targetHero;
    point targetPos;
    fixed directionAngle;
    point targetPoint;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TassadarForceWall, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    query.lv_minDistance = 2.0;
    query.lv_maxDistance = 6.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    // Get a point on the other side of the enemy hero
    targetPos = UnitGetPosition(targetHero);
    directionAngle = AngleBetweenPoints(UnitGetPosition(aiUnit), targetPos);
    targetPoint = PointWithOffsetPolar(targetPos, 1.5, directionAngle);

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, targetPoint);
}

//---------------------------------------------------------------------------------------------
bool TassadarArchon (int player, unit aiUnit, unitgroup scanGroup) {
    // Gives tassadar a shield and buffs his attack damage
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TassadarArchon, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use if you are retreating
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 8.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool TassadarOracle (int player, unit aiUnit, unitgroup scanGroup) {
    // Increases vision radius and enemy hero detection temporarily
    order spellOrd;
    unit target;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TassadarOracle, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use for decloaking nearby enemies
    target = libAIAI_gf_HeroAIGetCloakedEnemyToReveal(player);
    if (UnitIsAlive(target)) {
        libAIAI_gf_HeroAIResetRevealCloakedEnemyTimer(player);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // No use case beyond this point if we are inside our base
    if (libAIAI_gf_HeroAIIsPlayerInsideBase(player)) {
        return false;
    }

    // Use spell for the below cases only if we have energy to spare and we are not mounted
    if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < libAIAI_gv_aIHeroLowEnergyPercent
     || UnitHasBehavior(aiUnit, libAIAI_gv_aIHeroes[player].lv_mountBehavior)) {
        return false;
    }

    // Use when there are no enemies and ally minions in sight and we are not near a tower
    if (!AnyEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 20.0)
     && !AnyAllyMinionUnitsInArea(player, UnitGetPosition(aiUnit), 7.0)
     && !UnitIsValid(GetNearbyTower(aiUnit, scanGroup))) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Use to reveal enemies behind enemy gates
    target = FindClosestGate(scanGroup, aiUnit, 20.0);
    if (!UnitIsAlive(target)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkTassadar (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (TassadarDimensionalShift(player, aiUnit, scanGroup)) {
        return;
    }

    if (TassadarPlasmaShield(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (TassadarOracle(player, aiUnit, scanGroup)) {
        // Don't want to count the usable trait as a used up ability for lower difficulty AI with
        // casting limitations, so we are not returning out.
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TassadarArchon(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TassadarForceWall(player, aiUnit, scanGroup)) {
        return;
    }

    if (TassadarPsionicStormSecondStrike(player, aiUnit, scanGroup)) {
        return;
    }

    if (TassadarPsionicStorm(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Tinker Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_TinkerRockItTurrett       = "TinkerRockItTurret";
const string c_AB_TinkerDethLazorCharged    = "TinkerDethLazorCharged";
const string c_AB_TinkerDethLazorCancel     = "DethLazorCancel";
const string c_AB_TinkerXplodiumBomb        = "TinkerXplodiumBomb";
const string c_AB_TinkerGravOBomb3000       = "TinkerGravOBomb3000";
const string c_AB_TinkerDismantleTurret     = "TinkerDismantleTurret";
const string c_DethLazorActiveBehavior      = "DethLazorActive";

//---------------------------------------------------------------------------------------------
bool TinkerDethLazorCharged (int player, unit aiUnit, unitgroup scanGroup) {
    // Shoots a lazer that damages everything in its path. The longer it is charged the larger the AOE.
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    Storm_AI_TargetQueryOptions query;
    unit target;
    point targetPos;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TinkerDethLazorCharged, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Do not cast this channeling ability if the enemy heroes around you outnumber you and your
    // allies by 2 or more heroes.
    if (CountTeamOutnumberedBy(player, scanGroup, UnitGetPosition(aiUnit), 10.0) > 1) {
        return false;
    }

    // Cast if there is a large number of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast1Creep;
        minMinions = c_Storm_AI_AtLeast2Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    query.lv_maxDistance = 10.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    target = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (target == null) {
        return false;
    }

    targetPos = UnitGetPosition(target);
    if (!EnoughEnemiesInArea(scanGroup, targetPos, 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    if (HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, targetPos)) {
        HeroClaimForTactical(player, 1.25, false);
        return true;
    }
    return false;
}

//--------------------------------------------------------------------------------------------------
void AIChannelDethLazor (int player, unit aiUnit, unitgroup scanGroup) {
    order cancelOrd;
    bool cancel = false;
    order turnOrd;
    Storm_AI_TargetQueryOptions query;
    unit target;
    point targetPos;


    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        // Stop chanelling if in danger
        cancel = true;
    }
    else if (CountTeamOutnumberedBy(player, scanGroup, UnitGetPosition(aiUnit), 10.0) > 1) {
        // Stop channelling if the enemy heroes around you outnumber you and your allies by 2 or more heroes.
        cancel = true;
    }
    else {
        // Stop if the targets are leaving the area
        query.lv_maxDistance = 10.0;
        query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        target = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (target == null) {
            cancel = true;
        }
        else {
            targetPos = UnitGetPosition(target);
            cancel = !EnoughEnemiesInArea(scanGroup, targetPos, 3.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast3Minions);
        }
    }

    if (cancel) {
        cancelOrd = StormHeroAICreateOrder(player, c_AB_TinkerDethLazorCancel, 0);
        if (UnitOrderIsValid(aiUnit, cancelOrd)) {
            HeroClaimForTactical(player, 0.0, false);

            // Don't use HeroIssueOrder for channeling
            UnitIssueOrder(aiUnit, cancelOrd, c_orderQueueReplace);
            return;
        }
    }

    turnOrd = StormHeroAICreateOrder(player, c_Storm_AB_Move, 4);
    if (!UnitOrderIsValid(aiUnit, turnOrd)) {
        return;
    }

    HeroClaimForTactical(player, 1.25, false);

    OrderSetTargetPoint(turnOrd, targetPos);
    if (!UnitOrderIsValid(aiUnit, turnOrd)) {
        return;
    }

    // Don't use HeroIssueOrder for channeling
    UnitIssueOrder(aiUnit, turnOrd, c_orderQueueReplace);
}

//---------------------------------------------------------------------------------------------
bool TinkerRockItTurret (int player, unit aiUnit, unitgroup scanGroup) {
    // Creates a turret that attacks enemies
    order ord;
    unit nearbyTower;

    ord = StormHeroAICreateOrder(player, c_AB_TinkerRockItTurrett, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Don't be too offensive if we're near a tower (tower will just kill it)
    nearbyTower = GetNearbyTower(aiUnit, scanGroup);
    if (UnitIsValid(nearbyTower)) {
        return false;
    }

    // Always cast this if we have energy and there are enemies nearby
    if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < libAIAI_gv_aIHeroLowEnergyPercent) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 7.0, c_Storm_AI_AtLeast2Heroes, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast2Minions)) {
        return false;
    }

    // Deliberately setting the ord point here and passing in "null, null" since we don't want to fudge this position
    OrderSetTargetPoint(ord,UnitGetPosition(aiUnit));
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool TinkerXplodiumBomb (int player, unit aiUnit, unitgroup scanGroup) {
    // Places a bomb that damages and stuns nearby enemies
    order spellOrd;
    unit target;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TinkerXplodiumBomb, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = 6.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        // any enemy
        target = FindBestTacticalTarget(scanGroup, aiUnit, query);
    }
    else {
        // only a wounded hero
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
        target = FindBestHero(scanGroup, aiUnit, query);
    }

    // Shoot at a nearby hero
    if (target == null) {
        return false;
    }

    targetPos = UnitGetPosition(target);

    if (!EnoughEnemiesInArea(scanGroup, targetPos, 3.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TinkerGravOBomb3000 (int player, unit aiUnit, unitgroup scanGroup) {
    // Place bomb that after a delay sucks in all nearby units and detonates, leaving units stunned
    order spellOrd;
    unit targetHero;
    point targetPos;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TinkerGravOBomb3000, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_minDistance = 1.0;
    query.lv_maxDistance = 7.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    // Only cast if there are other nearby enemies for it to hit also
    targetPos = UnitGetPosition(targetHero);
    if (RequiredEnemyPlayerCountInArea(2, scanGroup, targetPos, 3.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TinkerDismantleTurret (int player, unit aiUnit, unitgroup scanGroup) {
    // Dismantles a Rock-It turret for mana and faster ability cd.
    order ord;
    point unitPosition;
    int index;
    int count;
    unitgroup turrets;
    unit turret;
    unit bestTurret;
    fixed turretDistanceSquared;
    fixed bestDistanceSquared;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    // only do this if we could use the energy
    if (energy > libAIAI_gv_aIHeroMediumEnergyPercent) {
        return false;
    }

    ord = StormHeroAICreateOrder(player, c_AB_TinkerDismantleTurret, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // we shouldn't destroy it if we see any enemies nearby
    unitPosition = UnitGetPosition(aiUnit);
    if (AnyEnemiesInArea(scanGroup, unitPosition, 10.0)) {
        return false;
    }

    // find our closest turret
    turrets = UnitGroupSearch("TinkerRockItTurret", player, unitPosition, 9.0, null, 0);
    bestDistanceSquared = 999.0;
    count = UnitGroupCount(turrets, c_unitCountAll);
    for (index = 1; index <= count; index += 1) {
        turret = UnitGroupUnit(turrets, index);
        if (!UnitIsAlive(turret)) {
            continue;
        }
        turretDistanceSquared = DistanceSquaredBetweenPoints(unitPosition, UnitGetPosition(turret));
        if (turretDistanceSquared > bestDistanceSquared) {
            continue;
        }
        bestTurret = turret;
        bestDistanceSquared = turretDistanceSquared;
    }

    // we need a turret to continue.
    if (bestTurret == null) {
        return false;
    }

    // we shouldn't destroy it if the turret has any enemies nearby
    if (AnyEnemiesInArea(scanGroup, UnitGetPosition(bestTurret), 10.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueReplace, bestTurret, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkTinker (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UnitHasBehavior(aiUnit, c_DethLazorActiveBehavior) == true) {
        AIChannelDethLazor(player, aiUnit, scanGroup);
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (TinkerRockItTurret(player, aiUnit, scanGroup)) {
        return;
    }

    if (TinkerXplodiumBomb(player, aiUnit, scanGroup)) {
        return;
    }

    if (TinkerDethLazorCharged(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TinkerGravOBomb3000(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (TinkerDismantleTurret(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Diablo Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_DiabloShadowCharge                = "DiabloShadowCharge";
const string c_AB_DiabloFireStomp                   = "DiabloFireStomp";
const string c_AB_DiabloOverpower                   = "DiabloOverpower";
const string c_AB_DiabloLightningBreath             = "DiabloLightningBreath";
const string c_AB_DiabloLightningBreathCancel       = "LightningBreathCancel";
const string c_AB_DiabloApocalypse                  = "DiabloApocalypse";

const string c_DiabloLightningBreathActive          = "DiabloLightningBreathActive";
const string c_DiabloLightningBreathTalentHellstorm = "DiabloMasteryHellstormLightningBreath";

// Setting this to half the range of the missiles, as they move outward in a way that makes them more difficult to purposefully aim
const fixed c_DiabloFireStompEffectiveRange                     = 5.25;

const fixed c_DiabloShadowChargeRange                           = 5.0;
const fixed c_DiabloOutnumberedRange                            = 7.0;
const fixed c_DiabloOutnumberedCount                            = 3.0;
const string c_DiabloShadowChargeOverwhelmingForceTalent        = "DiabloTalentOverwhelmingForceShadowCharge";
const fixed c_DiabloShadowChargeOverwhelmingForceRangeModifier  = 1.75;

const fixed c_DiabloOverpowerTargetingRange                     = 4.0;
// Range here is extended to establish effectiveness of the heroic
const fixed c_DiabloLightningBreathRange                        = 8.5;
const fixed c_DiabloLightningBreathHellstormModifier            = 1.5;

const fixed c_DiabloApocalypseTeamFightRange                    = 8.0;

//---------------------------------------------------------------------------------------------
bool DiabloFireStomp (int player, unit aiUnit, unitgroup scanGroup) {
    // Shoots fireballs radially in all direction
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unit nearbyHero;
    Storm_AI_TargetQueryOptions query;
    fixed minEnemyHero;
    fixed minEnemyCreep;
    fixed minEnemyMinion;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DiabloFireStomp, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast if there is a weak, close hero
    query.lv_maxDistance = c_DiabloFireStompEffectiveRange;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;


    // Find closest needs to be replaced
    nearbyHero = FindBestHero(scanGroup, aiUnit, query);
    if (nearbyHero != null) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Cast if there are many enemies in the area
    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minEnemyHero = 1;
        minEnemyCreep = 2;
        minEnemyMinion = 3;
    }
    else {
        minEnemyHero = 2;
        minEnemyCreep = 4;
        minEnemyMinion = 8;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), c_DiabloFireStompEffectiveRange, minEnemyHero, minEnemyCreep, minEnemyMinion)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool DiabloShadowCharge (int player, unit aiUnit, unitgroup scanGroup) {
    // Charge at an enemy pushing them back. Stuns them if it pushes them into a wall.
    unit targetEnemy;
    order spellOrd;
    order attackOrd;
    Storm_AI_TargetQueryOptions query;
    fixed abilityRange;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_DiabloShadowCharge, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        attackOrd = null;
    }

    // Don't jump into battle with low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    // setup target options
    abilityRange = c_DiabloShadowChargeRange;
    if (PlayerHasTalent(player, c_DiabloShadowChargeOverwhelmingForceTalent)) {
        abilityRange = (c_DiabloShadowChargeRange+c_DiabloShadowChargeOverwhelmingForceRangeModifier);
    }
    query.lv_minDistance = 1.0;
    query.lv_maxDistance = abilityRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_ignoreTargetsBehindGate = true;

    // Cast if enemy health is low enough
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroHighHealthPercent;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }

    // Find a target hero
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (targetEnemy == null){
        return false;
    }
    // Ensure he's not too outnumbered
    if (CountTeamOutnumberedBy(player, scanGroup, UnitGetPosition(targetEnemy), c_DiabloOutnumberedRange) >= c_DiabloOutnumberedCount){
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool DiabloOverpower (int player, unit aiUnit, unitgroup scanGroup) {
    // Flips the target behind Diablo and stuns them
    unit targetEnemy;
    order spellOrd;
    order attackOrd;
    Storm_AI_TargetQueryOptions query;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_DiabloOverpower, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // If low on health don't flip
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroLowHealthPercent) {
        return false;
    }

    // Cast if enemy health is low enough
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroHighHealthPercent;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }

    // Find a target hero
    query.lv_maxDistance = c_DiabloOverpowerTargetingRange;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    // No health preferences to keep this ability viable as CC for high and low targets
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (targetEnemy == null) {
        // Try to find a creep that fits the same criteria, but ultimately don't do this on a minion
        targetEnemy = FindBestAggroCreep(scanGroup, aiUnit, query);
        if (targetEnemy == null) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool DiabloLightningBreathActive (int player, unit aiUnit, unitgroup scanGroup) {
    // Update direction of breath cone or cancel if very low health
    unit targetEnemy;
    order cancelOrd;
    fixed abilityRange;
    Storm_AI_TargetQueryOptions query;

    if (!UnitHasBehavior2(aiUnit, c_DiabloLightningBreathActive)) {
        return false;
    }

    // Stop channeling if in danger
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        cancelOrd = StormHeroAICreateOrder(player, c_AB_DiabloLightningBreathCancel, 0);
        if (UnitOrderIsValid(aiUnit, cancelOrd)) {
            HeroReleaseFromTactical(player);
            UnitIssueOrder(aiUnit, cancelOrd, c_orderQueueReplace);
            return true;
        }
    }

    // Otherwise continue to claim for tactical AI
    HeroClaimForTactical(player, 1.25, false);

    abilityRange = c_DiabloLightningBreathRange;
    if (PlayerHasTalent(player, c_DiabloLightningBreathTalentHellstorm)) {
        abilityRange *= c_DiabloLightningBreathHellstormModifier;
    }

    // Find Diablo a good close target and track
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = abilityRange;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // Use for tower damage if there's no compatible hero
        targetEnemy = GetNearbyTower(aiUnit, scanGroup);
        if (!UnitIsValid(targetEnemy)) {
            return true;
        }
    }

    return UnitUpdateChanneledOrderTarget(aiUnit, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool DiabloLightningBreath (int player, unit aiUnit, unitgroup scanGroup) {
    // Shoot lightning towards target point
    order spellOrd;
    unit targetEnemy;
    point targetPoint;
    point playerPoint;
    fixed abilityRange;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DiabloLightningBreath, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Are we in a teamfight?
    playerPoint = UnitGetPosition(aiUnit);
    if (!TeamFightInArea(player, scanGroup, playerPoint, c_Storm_AI_DefaultTeamfightRange)){
        return false;
    }

    abilityRange = c_DiabloLightningBreathRange;
    if (PlayerHasTalent(player, c_DiabloLightningBreathTalentHellstorm)) {
        abilityRange *= c_DiabloLightningBreathHellstormModifier;
    }

    // Find a target, preferring close and unhealthy
    query.lv_maxDistance = abilityRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    targetPoint = UnitGetPosition(targetEnemy);
    if (HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, targetPoint)) {
        HeroClaimForTactical(player, 1.25, false);
        return true;
    }
    return false;
}

//---------------------------------------------------------------------------------------------
bool DiabloApocalypse (int player, unit aiUnit, unitgroup scanGroup) {
    // Create a fire under all enemy heroes revealing them and damaging them if they don't move out in time
    order ord;
    unit targetHero;
    int enemyHeroIndex;
    int numEnemyHeroes;
    point targetPosition;

    ord = StormHeroAICreateOrder(player, c_AB_DiabloApocalypse, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Cast it any time Diablo sees a favorable teamfight with a weakened enemy
    numEnemyHeroes = UnitGroupCount(libAIAI_gv_aIHeroes[player].lv_visibleEnemyHeroes, c_unitCountAll);
    for (enemyHeroIndex = 1 ; enemyHeroIndex <= numEnemyHeroes; enemyHeroIndex += 1){
        targetHero = UnitGroupUnit(libAIAI_gv_aIHeroes[player].lv_visibleEnemyHeroes, enemyHeroIndex);
        if (targetHero != null) {
            targetPosition = UnitGetPosition(targetHero);
            if ((UnitGetPropertyFixed(targetHero, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroMediumHealthPercent)
            && (TeamFightInArea(player, scanGroup, targetPosition, c_DiabloApocalypseTeamFightRange))
            && (CountTeamOutnumberedBy(player, scanGroup, targetPosition, c_DiabloApocalypseTeamFightRange) >= 0)) {
                return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
            }
        }
    }
    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkDiablo (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (DiabloOverpower(player, aiUnit, scanGroup)) {
        return;
    }

    // Sometimes is used as a combo with Overpower
    if (DiabloShadowCharge(player, aiUnit, scanGroup)) {
        return;
    }

    if (DiabloFireStomp(player, aiUnit, scanGroup)) {
        return;
    }

    if (DiabloLightningBreathActive(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && DiabloApocalypse(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && DiabloLightningBreath(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Tychus Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_TychusGrenade                 = "TychusGrenade";
const string c_AB_TychusRunAndGun               = "TychusRunAndGun";
const string c_AB_TychusOverkillTargeted        = "TychusOverkillTargeted";
const string c_AB_TychusOdin                    = "TychusOdinNoHealth";
const string c_AB_OdinAnnihilate                = "TychusOdinAnnihilate";
const string c_AB_OdinRagnarokMissiles          = "TychusOdinRagnarokMissilesTargeted";
const string c_AB_OdinNuclearBlast              = "TychusOdinNuclearBlast";
const string c_AB_TychusDrakkenLaserDrill       = "TychusDrakkenLaserDrill";
const string c_AB_TychusMinigunActive           = "TychusMinigunActive";
const string c_NeosteelPlatingItem              = "TychusNeosteelCoating";

const fixed c_TychusOverkillRange                = 6.0;
const fixed c_TychusOverkillRadius               = 5.0;
const fixed c_TychusGrenadeRange                 = 7.0;
const fixed c_TychusGrenadeRadius                = 2.0;
const fixed c_TychusRunAndGunRange               = 8.0;
const fixed c_TychusOdinUseRange                 = 8.0;
const fixed c_TychusAnnihilateRange              = 18.0;
const fixed c_TychusAnnihilateRadius             = 2.0;
const fixed c_TychusRagnarokMissileRange         = 14.0;
const fixed c_TychusRagnarokMissileRadius        = 4.0;
const fixed c_TychusDrakkenLaserDrillRange       = 10.0;
const fixed c_TychusDrakkenLaserDrillRadius      = 10.0;

//---------------------------------------------------------------------------------------------
bool TychusGrenade (int player, unit aiUnit, unitgroup scanGroup) {
    // Lob Grenade that deals damage and knocks enemies away from impact point
    unit targetUnit;
    point targetPos;
    fixed energy;
    Storm_AI_TargetQueryOptions query;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusGrenade, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = c_TychusGrenadeRange;

    energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroHighHealthPercent;
    }
    else if (energy > libAIAI_gv_aIHeroMediumEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }

    // Target best hero
    targetUnit = FindBestHero(scanGroup, aiUnit, query);

    // Check if hero is valid
    if (UnitIsValid(targetUnit)) {
        targetPos = UnitGetPosition(targetUnit);
    }
    else {
        // Target a minion if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        targetUnit = FindBestUnit(scanGroup, scanGroup, aiUnit, query);
        if (UnitIsValid(targetUnit)) {
            targetPos = UnitGetPosition(targetUnit);
            if (!EnoughEnemiesInArea(scanGroup, targetPos, c_TychusGrenadeRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast3Minions, c_Storm_AI_AtLeast3Creeps)) {
                return false;
            }
        }
        else {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TychusRunAndGun (int player, unit aiUnit, unitgroup scanGroup) {
    // Dashes to target position and winds up his gun
    order attackOrd;
    point retreatPos;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusRunAndGun, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Dash to safety if low health
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 5.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Don't jump into battle if near a tower or have low health
    if (CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    query.lv_maxDistance = c_TychusRunAndGunRange;

    // Find a target hero
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool TychusOverkillTargeted (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages all enemies in front of hero over next few seconds
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusOverkillTargeted, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Don't use in battle if near a tower or have low health
    if(CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    query.lv_maxDistance = c_TychusOverkillRange;

    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    // only activate if there are other nearby enemies for it to hit
    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetHero), c_TychusOverkillRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast3Minions, c_Storm_AI_AtLeast3Creeps)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool TychusOdin (int player, unit aiUnit, unitgroup scanGroup) {
    // Transform into odin
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusOdin, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {
        return false;
    }

    query.lv_maxDistance = c_TychusOdinUseRange;

    // Attack nearest hero after transforming
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    // deliberately setting the attackOrd target here and passing in "null, null" for the target since odin itself has no target
    OrderSetTargetUnit(attackOrd, targetHero);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool OdinAnnihilate (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals AoE damage in a line
    point center;
    unit targetUnit;
    Storm_AI_TargetQueryOptions query;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_OdinAnnihilate, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = c_TychusAnnihilateRange;

    targetUnit = FindBestUnit(scanGroup, scanGroup, aiUnit, query);
    if (!UnitIsValid(targetUnit)) {
        return false;
    }

    center = UnitGetPosition(targetUnit);
    if (!EnoughEnemiesInArea(scanGroup, center, c_TychusAnnihilateRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast4Creeps, c_Storm_AI_AtLeast5Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, center);
}

//---------------------------------------------------------------------------------------------
bool OdinRagnarokMissiles (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages all nearby enemies
    Storm_AI_TargetQueryOptions query;
    unit nearbyEnemy;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_OdinRagnarokMissiles, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = c_TychusRagnarokMissileRange;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;

    // Cast if there is a weak hero
    nearbyEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(nearbyEnemy)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(nearbyEnemy));
    }

    // Cast if there is a weak tower
    nearbyEnemy = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
    if (UnitIsValid(nearbyEnemy)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(nearbyEnemy));
    }

    // Cast if there are many enemies in the area
    query.lv_maxHealthPercent = 100.0;
    nearbyEnemy = FindBestUnit(scanGroup, scanGroup, aiUnit, query);
    if (!UnitIsValid(nearbyEnemy)) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(nearbyEnemy), c_TychusRagnarokMissileRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast4Creeps, c_Storm_AI_AtLeast5Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(nearbyEnemy));
}

//---------------------------------------------------------------------------------------------
bool TychusDrakkenLaserDrill (int player, unit aiUnit, unitgroup scanGroup) {
    // Places a turret that shoots nearby enemies
    Storm_AI_TargetQueryOptions query;
    unit targetHero;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusDrakkenLaserDrill, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {
        return false;
    }

    query.lv_maxDistance = c_TychusDrakkenLaserDrillRange;

    // Place on a group of nearby heroes
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetHero), c_TychusDrakkenLaserDrillRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast4Creeps, c_Storm_AI_AtLeast5Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetHero));
}

//---------------------------------------------------------------------------------------------
bool TychusMinigunActive (int player, unit aiUnit, unitgroup scanGroup) {
    // Activate to deal giant killer damage
    order spellOrd;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusMinigunActive, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {
        return false;
    }

    return UnitIssueOrder (aiUnit, spellOrd, c_orderQueueAddToFront);
}

//---------------------------------------------------------------------------------------------
bool TychusDefensiveItemCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    if (itemType == c_NeosteelPlatingItem) {
        if (!HaveBeenAttackedRecently(aiUnit) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
            return false;
        }
        return UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkTychus (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseItem(player, aiUnit, scanGroup, TychusDefensiveItemCallback)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (OdinRagnarokMissiles(player, aiUnit, scanGroup)) {
        return;
    }

    if (OdinAnnihilate(player, aiUnit, scanGroup)) {
        return;
    }

    if (TychusRunAndGun(player, aiUnit, scanGroup)) {
        return;
    }

    if (TychusGrenade(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TychusDrakkenLaserDrill(player, aiUnit, scanGroup)) {
        return;
    }

    if (TychusOverkillTargeted(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TychusOdin(player, aiUnit, scanGroup)) {
        return;
    }

    if (TychusMinigunActive(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Tyrande Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_TyrandeLightofElune   = "TyrandeLightofElune";
const string c_AB_TyrandeSentinelShot   = "TyrandeSentinelShot";
const string c_AB_TyrandeLunarFlare     = "TyrandeLunarFlare";
const string c_AB_TyrandeShadowStalk    = "TyrandeShadowstalk";
const string c_AB_TyrandeStarfall       = "TyrandeStarfall";
const string c_AB_TyrandeHuntersMark    = "TyrandeHuntersMark";
const string c_TyrandeLunarBlazeTalent = "TyrandeMasteryLunarBlaze";
const fixed c_TyrandeHuntersMarkRange   = 5.5;

//---------------------------------------------------------------------------------------------
bool TyrandeLightofElune (int player, unit aiUnit, unitgroup scanGroup) {
    // Heals target ally and self
    unit targetUnit;
    order ord;
    fixed targetHealth;

    ord = StormHeroAICreateOrder(player, c_AB_TyrandeLightofElune, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Find weak nearby ally to heal
    targetUnit = FindBestHealTarget(player, aiUnit, 8.5, c_Storm_AI_OnlyEssentialHealing, false);
    if (!UnitIsValid(targetUnit)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null);
}

//---------------------------------------------------------------------------------------------
bool TyrandeSentinelShot (int player, unit aiUnit, unitgroup scanGroup) {
    // Shoots an owl across the map that gives vision and damages an enemy hero if it hits them
    order spellOrd;
    order attackOrd;
    unit targetHero;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyrandeSentinelShot, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        healthReq = 100.0;
    }
    else {
        healthReq = 60.0;
    }

    // Use on a weak enemy hero
    query.lv_maxDistance = 13;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxHealthPercent = healthReq;
    targetHero = FindBestTacticalTarget (scanGroup, aiUnit, query);

    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool TyrandeLunarFlare (int player, unit aiUnit, unitgroup scanGroup) {
    // AoE shot that damages/stuns targets in a small area
    order spellOrd;
    unit targetHero;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;
    fixed range;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyrandeLunarFlare, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        healthReq = 100.0;
    }
    else {
        healthReq = 60.0;
    }

    if (PlayerHasTalent(player, c_TyrandeLunarBlazeTalent)) {
        range = 13.0;
    }
    else {
        range = 9.0;
    }
    // Shoot at any nearby hero
    query.lv_maxDistance = range;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxHealthPercent = healthReq;
    targetHero = FindBestTacticalTarget (scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        // Shoot minions if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        targetPos = UnitGroupCenterOfGroup(scanGroup);
        if (!EnoughEnemiesInArea(scanGroup, targetPos, 2.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
            return false;
        }
    }
    else {
        targetPos = UnitGetPosition(targetHero);
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TyrandeShadowStalk (int player, unit aiUnit, unitgroup scanGroup) {
    // Cloaks all nearby allies
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyrandeShadowStalk, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!HaveBeenAttackedRecently(aiUnit) || !TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 8.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool TyrandeStarfall (int player, unit aiUnit, unitgroup scanGroup) {
    // Damage/slow nearby enemies
    order spellOrd;
    order attackOrd;
    unitgroup nearbyEnemies;
    unitgroup nearbyEnemyHeroes;
    point center;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyrandeStarfall, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 10.0)) {
        return false;
    }

    // Center on heroes are any is nearby
    nearbyEnemies = UnitsInArea(scanGroup, UnitGetPosition(aiUnit), 8.0);
    nearbyEnemyHeroes = UnitGroupFilterHeroes(nearbyEnemies);

    if (UnitGroupCount(nearbyEnemyHeroes, c_unitCountAll) == 0) {
        return false;
    }

    center = UnitGroupCenterOfGroup(nearbyEnemyHeroes);

    if (!EnoughEnemiesInArea(scanGroup, center, 6.0, c_Storm_AI_AtLeast3Heroes, 5, 9)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, center);
}

//---------------------------------------------------------------------------------------------
bool TyrandeHuntersMark (int player, unit aiUnit, unitgroup scanGroup) {
    // Make a target enemy vulnerable
    order spellOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyrandeHuntersMark, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Target a weaker nearby hero
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = c_TyrandeHuntersMarkRange;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkTyrande (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (TyrandeLightofElune(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (TyrandeLunarFlare(player, aiUnit, scanGroup)) {
        return;
    }

    if (TyrandeSentinelShot(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TyrandeShadowStalk(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TyrandeStarfall(player, aiUnit, scanGroup)) {
        return;
    }

    if (TyrandeHuntersMark(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Tyrael Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_TyraelElDruinsMight                       = "TyraelElDruinsMight";
const string c_AB_TyraelElDruinsMightAngelicFlash           = "ElDruinsMightAngelicFlash";
const string c_AB_TyraelElDruinsMightAngelicFlashMastery    = "ElDruinsMightAngelicFlashMastery";
const string c_AB_TyraelRighteousness                       = "TyraelRighteousness";
const string c_AB_TyraelSmite                               = "TyraelSmite";
const string c_AB_TyraelJudgement                           = "TyraelJudgement";
const string c_AB_TyraelSanctification                      = "TyraelSanctificationStationary";
const string c_AB_TyraelSanctificationCancel                = "CancelSanctification";

const string c_EldruinSwordUnit                             = "TyraelEldruinSword";

//---------------------------------------------------------------------------------------------
bool TyraelElDruinsMight (int player, unit aiUnit, unitgroup scanGroup) {
    // Throw sword damaging and slowing all enemies in target area
    order spellOrd;
    point retreatPos;
    unit targetHero;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelElDruinsMight, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Throw sword toward spawn if low health to use the teleport to retreat faster
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 9.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        healthReq = 100.0;
    }
    else {
        healthReq = 60.0;
    }

    // Shoot any nearby hero
    query.lv_maxHealthPercent = healthReq;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = 9.0;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        // Shoot a group of minions if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        targetPos = UnitGroupCenterOfGroup(scanGroup);
        if (!EnoughEnemiesInArea(scanGroup, targetPos, 2.5, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
            return false;
        }
    }
    else {
        targetPos = UnitGetPosition(targetHero);
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool ElDruinsMightAngelicFlash (int player, unit aiUnit, unitgroup scanGroup) {
    // Teleports Tyrael to where the sword was thrown
    order spellOrd;
    order attackOrd;
    unitgroup nearbySwords;
    unit sword;
    fixed healthPercent = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    unitgroup enemiesNearSword;
    unit targetHero;
    fixed heroToHomeDistance;
    fixed swordToHomeDistance;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelElDruinsMightAngelicFlash, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelElDruinsMightAngelicFlashMastery, 0);
        if (!UnitOrderIsValid(aiUnit, spellOrd)) {
            return false;
        }
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find the position of his sword
    nearbySwords = UnitGroup(c_EldruinSwordUnit, player, RegionCircle(UnitGetPosition(aiUnit), 500.0), null, 0);
    if (UnitGroupCount(nearbySwords, c_unitCountAll) == 0) {
        return false;
    }

    sword = UnitGroupUnit(nearbySwords, 1);

    // Teleport if you are low health and your sword is closer to home
    if (healthPercent < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        heroToHomeDistance = DistanceBetweenPoints(UnitGetPosition(aiUnit), libGame_gv_players[player].lv_spawnPoint);
        swordToHomeDistance = DistanceBetweenPoints(UnitGetPosition(sword), libGame_gv_players[player].lv_spawnPoint);

        if (swordToHomeDistance < heroToHomeDistance) {
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
        }
    }

    // Teleport if the sword is near a weak enemy
    if(!CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, 60.0)) {
        enemiesNearSword = UnitsInArea(scanGroup, UnitGetPosition(sword), 3.0);
        query.lv_maxHealthPercent = 50;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
        query.lv_maxDistance = 3.0;
        targetHero = FindBestHero(enemiesNearSword, sword, query);

        if (UnitIsValid(targetHero)) {
            // deliberately setting the attackOrd target here and passing in "null, null" for the target
            //      since ReturnSword itself has no target
            OrderSetTargetUnit(attackOrd, targetHero);
            if (!UnitOrderIsValid(aiUnit, attackOrd)) {
                return false;
            }

            return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueReplace, null, null);
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool TyraelRighteousness (int player, unit aiUnit, unitgroup scanGroup) {
    // Casts a temporary shield on self, minor shield on nearby allies
    order spellOrd;
    fixed health = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelRighteousness, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use if you are being attacked while retreating or a decent amount of energy
    if (HaveBeenAttackedRecently(aiUnit)) {
        if ((energy > libAIAI_gv_aIHeroMediumEnergyPercent && health < 80) || health < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
        }
    }

    // Activate if there is a team fight
    if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 6.0)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool TyraelSmite (int player, unit aiUnit, unitgroup scanGroup) {
    // aoe damage
    order spellOrd;
    unit targetHero;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelSmite, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        healthReq = 100.0;
    }
    else {
        healthReq = 60.0;
    }

        // Shoot any nearby hero
    query.lv_maxHealthPercent = healthReq;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = 8.0;
    targetHero = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetHero)) {
        // Shoot a group of minions if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        targetPos = UnitGroupCenterOfGroup(scanGroup);
        if (!EnoughEnemiesInArea(scanGroup, targetPos, 3.5, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
            return false;
        }
    }
    else {
        targetPos = UnitGetPosition(targetHero);
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TyraelJudgement (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages and stuns enemy. Knocks back all surrounding enemies.
    order spellOrd;
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelJudgement, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    query.lv_maxHealthPercent = 50;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = 11.0;
    query.lv_minDistance = 1.0;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool TyraelSanctification (int player, unit aiUnit, unitgroup scanGroup) {
    // Makes nearby allies invulnerable while channeling
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelSanctification, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Only activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 6.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}


//---------------------------------------------------------------------------------------------
void AIThinkTyrael (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }


    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (ElDruinsMightAngelicFlash(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (TyraelRighteousness(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TyraelSanctification(player, aiUnit, scanGroup)) {
        return;
    }

    if (TyraelElDruinsMight(player, aiUnit, scanGroup)) {
        return;
    }

    if (TyraelSmite(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TyraelJudgement(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Sonya Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_BarbarianBash                     = "BarbarianSeismicSlam";
const string c_AB_BarbarianWhirlwind                = "BarbarianWhirlwind";
const string c_AB_BarbarianWhirlwindCancel          = "BarbarianWhirlwindCancel";
const string c_AB_BarbarianAncientSpear             = "BarbarianAncientSpear";
const string c_AB_BarbarianLeap                     = "BarbarianLeap";
const string c_AB_BarbarianWrathOfTheBeserker       = "BarbarianWrathoftheBerserker";
const string c_AB_BarbarianShotofFury               = "BarbarianShotofFury";

const string c_BarbarianWhirlwindChannelBehavior    = "BarbarianWhirlwindChannel";
const string c_BarbarianCompositeSpearTalent        = "BarbarianMasteryCompositeSpearAncientSpear";

//---------------------------------------------------------------------------------------------
bool BarbarianBash (int player, unit aiUnit, unitgroup scanGroup) {
    // Strong melee attack
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_BarbarianBash, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Use on a weak enemy hero
    query.lv_maxDistance = 3.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        // Only try for a minion if we have pleny of enerygy. This allows us to save up to use whirlwind.
        // 65 is the cost of whirlwind plus bash.
        if(UnitGetPropertyFixed(aiUnit, c_unitPropEnergy, c_unitPropCurrent) < 65) {
            return false;
        }
        query.lv_minScore = 0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool BarbarianWhirlwind (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE that damages nearby enemies over the next few seconds.
    order ord;

    // only cast if we are healthy enough to maintain for a little while
    if(UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    ord = StormHeroAICreateOrder(player, c_AB_BarbarianWhirlwind, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // If there are not enough enemy units around the hero, do not cast
    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 4.0, c_Storm_AI_AtLeast2Heroes, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast4Minions)) {
        return false;
    }


    if(HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueReplace, null, null)) {
        HeroClaimForTactical(player, 3.0, false); // let whirlwind move the player until it stops
        return true;
    }
    return false;
}

//--------------------------------------------------------------------------------------------
void AIChannelBarbarianWhirlwind (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    // Move to the closest enemy
    query.lv_maxDistance = 8.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        targetEnemy = FindClosestWeakMinion(scanGroup, aiUnit, 0.0, 8.0, 100.0, -1, -1, c_Storm_AI_LOS_Optional);
        query.lv_minScore = 0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    }
    if (UnitIsValid(targetEnemy) && !(HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth)) {
        ord = StormHeroAICreateOrder(player, c_Storm_AB_Move, 0);
        if (!UnitOrderIsValid(aiUnit, ord)) {
            return;
        }
        OrderSetTargetUnit(ord, targetEnemy);
        if (!UnitOrderIsValid(aiUnit, ord)) {
            return;
        }
        UnitIssueOrder(aiUnit, ord, c_orderQueueReplace);
    }
    else {
        // no target or we are in danger, so cancel
        HeroReleaseFromTactical(player);
        ord = StormHeroAICreateOrder(player, c_AB_BarbarianWhirlwindCancel, 0);
        if (!UnitOrderIsValid(aiUnit, ord)) {
            return;
        }
        HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
    }
}

//---------------------------------------------------------------------------------------------
bool BarbarianAncientSpear (int player, unit aiUnit, unitgroup scanGroup) {
    // Skillshot that drags Barbarian to the target it hits and that generates fury
    order spellOrd;
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;
    fixed range;


    spellOrd = StormHeroAICreateOrder(player, c_AB_BarbarianAncientSpear, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Don't jump into enemies if we are low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    if (PlayerHasTalent(player, c_BarbarianCompositeSpearTalent)) {
        range = 9.5;
    }
    else {
        range = 7.0;
    }

    // grab nearest enemy if they are low health
    query.lv_maxHealthPercent = 80;
    query.lv_maxDistance = range;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    query.lv_ignoreTargetsBehindGate = true;
    targetHero = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, UnitGetPosition(targetHero));
}

//---------------------------------------------------------------------------------------------
bool BarbarianLeap (int player, unit aiUnit, unitgroup scanGroup) {
   // Moves leaps to target dealing damage to it
    order spellOrd;
    order attackOrd;
    point retreatPos;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_BarbarianLeap, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Jump towards your spawn for safety if you are low health
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // Find position that is 6 units from current position towards the base
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 8.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Don't jump into enemies if we are low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find a target hero
    query.lv_maxHealthPercent = 70;
    query.lv_maxDistance = 9.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_ignoreTargetsBehindGate = true;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool BarbarianWrathOfTheBeserker (int player, unit aiUnit, unitgroup scanGroup) {
    // Increase attack speed and become invulnerable to CC effects
    order spellOrd;
    unit targetHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_BarbarianWrathOfTheBeserker, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!HaveBeenAttackedRecently(aiUnit) || !TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 6.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool BarbarianShotofFury (int player, unit aiUnit, unitgroup scanGroup) {
    // Instantly gain fury
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_BarbarianShotofFury, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkBarbarian (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UnitHasBehavior(aiUnit, c_BarbarianWhirlwindChannelBehavior) == true) {
        AIChannelBarbarianWhirlwind(player, aiUnit, scanGroup);
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && BarbarianLeap(player, aiUnit, scanGroup)) {
        return;
    }

    // whirlwind should be above other abilities because it has more requirements to cast and needs to be used more often (this only makes a tiny difference, but it's worth noting).
    if (BarbarianWhirlwind(player, aiUnit, scanGroup)) {
        return;
    }

    if (BarbarianShotofFury(player, aiUnit, scanGroup)) {
        return;
    }

    if (BarbarianBash(player, aiUnit, scanGroup)) {
        return;
    }

    if (BarbarianAncientSpear(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && BarbarianWrathOfTheBeserker(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Abathur Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_AbathurSymbiote               = "AbathurSymbiote";
const string c_AB_AbathurToxicNest              = "AbathurToxicNest";
const string c_AB_AbathurDeepTunnel             = "AbathurDeepTunnel";
const string c_AB_AbathurUltimateEvolution      = "AbathurUltimateEvolution";
const string c_AB_AbathurEvolveMonstrosity      = "AbathurEvolveMonstrosity";

const string c_AB_AbathurAssumingDirectControlCancel = "AbathurAssumingDirectControlCancel";

const string c_AbathurAssumingDirectControlBehavior       = "AssumingDirectControlBehavior";

//---------------------------------------------------------------------------------------------
bool AbathurSymbiote (int player, unit aiUnit, unitgroup scanGroup) {
    // Place a symbiote on an ally hero that can cast abilities
    order spellOrd;
    unit allyHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurSymbiote, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Don't start channeling if there is an enemy likely to attack Abathur
    if (EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 12.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast1Minion)) {
        return false;
    }

    allyHero = libAIAI_gf_HeroAIGetRandomAllyHeroInBattle(player, 500.0, false);
    if (!UnitIsValid(allyHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, allyHero, null);
}

//---------------------------------------------------------------------------------------------
bool AbathurToxicNest (int player, unit aiUnit, unitgroup scanGroup) {
    // Places a proximity bomb anywhere on the map
    order spellOrd;
    point contentionPoint;
    region nearContentionPoint;
    point position;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurToxicNest, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    contentionPoint = libAIAI_gf_HeroAIGetRandomContentionPoint(player, 70.0);
    if (contentionPoint == null) {
        return false;
    }

    nearContentionPoint = RegionCircle(contentionPoint, 4.0);
    position = RegionRandomPoint(nearContentionPoint);

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, position);
}

//---------------------------------------------------------------------------------------------
bool AbathurDeepTunnel (int player, unit aiUnit, unitgroup scanGroup) {
    // Teleport to the target position
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurDeepTunnel, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Currently unused by the Tactical AI
    return false;
}

//---------------------------------------------------------------------------------------------
bool AbathurUltimateEvolution (int player, unit aiUnit, unitgroup scanGroup) {
    // Create a copy of an ally hero
    order spellOrd;
    unit allyHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurUltimateEvolution, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    allyHero = libAIAI_gf_HeroAIGetRandomAllyHeroInBattle(player, 500.0, false);
    if (!UnitIsValid(allyHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, allyHero, null);
}

//---------------------------------------------------------------------------------------------
bool AbathurEvolveMonstrosity (int player, unit aiUnit, unitgroup scanGroup) {
    // Turns a minion or locust into a monster. Abathur can symbiote the monster  (can be used anywhere on the map)
    // For now I'll just try to use it to help an ally in battle  (similar logic to ultimate evolution)
    order spellOrd;
    unit allyHero;
    unit target;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurEvolveMonstrosity, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    allyHero = libAIAI_gf_HeroAIGetRandomAllyHeroInBattle(player, 500.0, true);
    if (!UnitIsValid(allyHero)) {
        return false;
    }

    target = FindClosestAllyMinion(UnitGetOwner(aiUnit), UnitGetPosition(allyHero), 6.0);
    if (!UnitIsValid(target)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, target, null);
}

//---------------------------------------------------------------------------------------------
void AIChannelAbathurAssumingDirectControl (int player, unit aiUnit, unitgroup scanGroup) {
    order cancelOrd;

    // Symbiote
    if (UnitIsValid(abathurSymbioteUnit[player - 1])) {
        cancelOrd = StormHeroAICreateOrder(player, c_AB_AbathurAssumingDirectControlCancel, 0);
        if (!UnitOrderIsValid(abathurSymbioteUnit[player - 1], cancelOrd)) {
            return;
        }

        if (HaveBeenAttackedRecently(aiUnit) || EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 10.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast1Minion))  {
            UnitIssueOrder(abathurSymbioteUnit[player - 1], cancelOrd, c_orderQueueReplace);
        }
    }

    // Ultimate evolution
    if (UnitIsValid(abathurUltimateEvolutionUnit[player - 1])) {
        // Hook it into the MinionAI if it has not been yet
        if (libAIAI_gf_MinionAIGetIndexForMinion(abathurUltimateEvolutionUnit[player - 1]) == 0) {
            libAIAI_gf_MinionAIStartMinionAISimple(abathurUltimateEvolutionUnit[player - 1]);
        }

        cancelOrd = StormHeroAICreateOrder(player, c_AB_AbathurAssumingDirectControlCancel, 0);
        if (!UnitOrderIsValid(abathurUltimateEvolutionUnit[player - 1], cancelOrd)) {
            return;
        }

        if (HaveBeenAttackedRecently(aiUnit))  {
            UnitIssueOrder(abathurUltimateEvolutionUnit[player - 1], cancelOrd, c_orderQueueReplace);
        }
    }
}

//---------------------------------------------------------------------------------------------
bool AbathurForceAssumingDirectControl (int player) {
    order cancelOrd;

    // Symbiote
    if (UnitIsValid(abathurSymbioteUnit[player - 1])) {
        cancelOrd = StormHeroAICreateOrder(player, c_AB_AbathurAssumingDirectControlCancel, 0);
        if (!UnitOrderIsValid(abathurSymbioteUnit[player - 1], cancelOrd)) {
            return false;
        }

        return UnitIssueOrder(abathurSymbioteUnit[player - 1], cancelOrd, c_orderQueueReplace);
    }

    // Ultimate evolution
    if (UnitIsValid(abathurUltimateEvolutionUnit[player - 1])) {
        // Hook it into the MinionAI if it has not been yet
        if (libAIAI_gf_MinionAIGetIndexForMinion(abathurUltimateEvolutionUnit[player - 1]) == 0) {
            libAIAI_gf_MinionAIStartMinionAISimple(abathurUltimateEvolutionUnit[player - 1]);
        }

        cancelOrd = StormHeroAICreateOrder(player, c_AB_AbathurAssumingDirectControlCancel, 0);
        if (!UnitOrderIsValid(abathurUltimateEvolutionUnit[player - 1], cancelOrd)) {
            return false;
        }

        return UnitIssueOrder(abathurUltimateEvolutionUnit[player - 1], cancelOrd, c_orderQueueReplace);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkAbathur (int player, unit aiUnit, unitgroup scanGroup) {
    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UnitHasBehavior(aiUnit, c_AbathurAssumingDirectControlBehavior)) {
        AIChannelAbathurAssumingDirectControl(player, aiUnit, scanGroup);
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (AbathurToxicNest(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && AbathurUltimateEvolution(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && AbathurEvolveMonstrosity(player, aiUnit, scanGroup)) {
        return;
    }

    if (AbathurSymbiote(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Abathur Symbiote Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_AbathurSymbioteStab           = "AbathurSymbioteStab";
const string c_AB_AbathurSymbioteSpikeBurst     = "AbathurSymbioteSpikeBurst";
const string c_AB_AbathurSymbioteCarapace       = "AbathurSymbioteCarapace";

//---------------------------------------------------------------------------------------------
bool AbathurSymbioteStab (int player, unit aiUnit, unitgroup scanGroup) {
    // Skillshot damage
    order spellOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurSymbioteStab, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Shoot any nearby enemy if there is a clear shot
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = 8.0;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        query.lv_lineOfSightRequired = c_Storm_AI_LOS_Optional;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool AbathurSymbioteSpikeBurst (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE damage
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurSymbioteSpikeBurst, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 4.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
}

//---------------------------------------------------------------------------------------------
bool AbathurSymbioteCarapace (int player, unit aiUnit, unitgroup scanGroup) {
    // Places a shield on the host
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurSymbioteCarapace, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 8.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast2Minions)) {
        return false;
    }

    // Cast when off cooldown and enemies are nearby
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkAbathurSymbiote (int player, unit aiUnit, unitgroup scanGroup) {
    if (player > libCore_gv_bALMaxPlayers) {
        return;
    }

    abathurSymbioteUnit[player - 1] = aiUnit;

    // Only control if it is an AI player
    if (libAIAI_gf_HeroAIIsAIEnabledForPlayer(player) == false) {
        return;
    }

    if (AbathurSymbioteCarapace(player, aiUnit, scanGroup)) {
        return;
    }

    if (AbathurSymbioteSpikeBurst(player, aiUnit, scanGroup)) {
        return;
    }

    if (AbathurSymbioteStab(player, aiUnit, scanGroup)) {
        return;
    }
}
