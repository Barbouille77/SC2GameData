//--------------------------------------------------------------------------------------------------
// Storm Tactical Hero AI
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
// Function prototypes
//--------------------------------------------------------------------------------------------------

// The prototype for function callbacks that can adjust a target unit's score from inside FindBestUnit()
fixed Storm_AI_AdjustScore (unitgroup scanGroup, int player, unit aiUnit, unit targetUnit, fixed targetScore, point targetPosition);

// Prototype for callbacks to check item usage.
bool Storm_AI_CheckUseItem (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff);

//--------------------------------------------------------------------------------------------------
// Structs
//--------------------------------------------------------------------------------------------------

// Storm_AI_TargetQueryOptions is used by FindBestUnit() to determine what units are valid and how to score them.
// Units are scored based on units having a default score value of 1.0,
// multiplied by their AIEvaluationFactor property, which is typically 1.0 for heroes.
// If minDistance or maxDistance are not set, they do not restrict the targets considered.
// If distanceFactor is not set, then distance does not alter the score of targets considered.
// If distanceFactor is positive, and maxDistance is set, then units at minDistance have a score
// increased by distanceFactor, and units at maxDistance have no score increase. Units in
// between are interpolated between the two extremes.
// If distanceFactor is negative, and maxDistance is set, then units at maxDistance have a score
// increased by abs(distanceFactor), interpolated to units at minDistance which have no score increase.
// If minHealthPercent or maxHealthPercent are not set, they do not restrict the targets considered.
// If healthFactor is not set, then health does not alter the score of targets considered.
// If healthFactor is positive then units at minHealthPercent have a score increased by healthFactor,
// interpolated to units at maxHealthPercent (or 100.0) which have no score increase.
// If healthFactor is negative, then units at maxHealthPercent (or 100.0) have a score
// increased by abs(healthFactor), and units at minHealthPercent having no score increase. Units in
// between are interpolated between the two extremes.
// PreferedRole refers to the pre-defined roles (Warrior, Support, Specialist, etc...).
// If roleFactor is Not 0, then roleFactor will be added to all units matching the role specified in preferedRole,
// meaning positive values in roleFactor will increase the score of matching units, while negative values will decrease it.
// MinScore is the score required for a target to be valid (unscaled by distance or health).
// Set to c_Storm_AI_FullHeroScore to require the target's AIEvaluationFactor is at least 1.0.
// AdjustScoreCallback can be set to a callback which can modify all target unit scores in a custom way.
// The callback function could set the score for a unit to c_Storm_AI_InvalidScore to ignore the unit.
// If Line of Sight is required, then targets behind other targets (from the point of view of the
// aiUnit attacking) will be discarded.
// If ignoreTargetsBehindGate is true, then targets behind enemy gates (from the point of view of the
// aiUnit attacking) will be discarded.
// If projectedTargetDistance is > 0, then when filtering out targets behind gates,
// the point tested for being behind a gate will be projected behind the target by the given distance.
// If projectedTargetDistance is < 0, then it will project the target position towards the attacker.
struct Storm_AI_TargetQueryOptions {
    fixed lv_minDistance;
    fixed lv_maxDistance;
    fixed lv_distanceFactor;
    fixed lv_minHealthPercent;
    fixed lv_maxHealthPercent;
    fixed lv_healthFactor;
    fixed lv_minScore;
    fixed lv_projectedTargetDistance;
    int lv_matchingRole;
    fixed lv_roleFactor;
    funcref<Storm_AI_AdjustScore> lv_adjustScoreCallback;
    bool lv_lineOfSightRequired;
    bool lv_ignoreTargetsBehindGate;
    bool lv_ignoreTargetsBehindAlliedGate;
}; // If you add to this, update ResetTargetQueryOptions!

//--------------------------------------------------------------------------------------------------
// Copies of constants to avoid including another file, must match original definitions
//--------------------------------------------------------------------------------------------------

const string c_Storm_AB_Attack = "attack";
const string c_Storm_AB_Move = "move";

//--------------------------------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------------------------------

const string c_AbathurUltimateEvolutionControlBehavior    = "AbathurUltimateEvolutionControlBehavior";

// When comparing best targets, the target has a default score of c_Storm_AI_FullHeroScore and the
// range and health can offset it. The ratio between these values can change how much range and health
// affects target preference.
const fixed c_Storm_AI_StronglyPreferCloserTargets = 1.0;
const fixed c_Storm_AI_PreferCloserTargets = 0.25;
const fixed c_Storm_AI_PreferDistantTargets = -0.25;
const fixed c_Storm_AI_StronglyPreferDistantTargets = -1.0;
const fixed c_Storm_AI_StronglyPreferUnhealthyTargets = 1.0;
const fixed c_Storm_AI_PreferUnhealthyTargets = 0.25;
const fixed c_Storm_AI_PreferHealthyTargets = -0.25;
const fixed c_Storm_AI_StronglyPreferHealthyTargets = -1.0;
const fixed c_Storm_AI_StronglyPreferMathchingRoleTargets = 1.0;
const fixed c_Storm_AI_PreferMathchingRoleTargets = 0.25;
const fixed c_Storm_AI_AvoidMathchingRoleTargets = -0.25;
const fixed c_Storm_AI_StronglyAvoidMathchingRoleTargets = -1.0;
const fixed c_Storm_AI_InvalidScore = -9999.0;
const fixed c_Storm_AI_FullHeroScore = 1.0;
const fixed c_Storm_AI_AtLeastMiniHero = 0.5;
const fixed c_Storm_AI_AtLeast1Hero = 1.0;
const fixed c_Storm_AI_AtLeast1HighValueHero = 1.25;
const fixed c_Storm_AI_AtLeast2Heroes = 2.0;
const fixed c_Storm_AI_AtLeast3Heroes = 3.0;
const fixed c_Storm_AI_AtLeast1Creep = 1.0;
const fixed c_Storm_AI_AtLeast2Creeps = 2.0;
const fixed c_Storm_AI_AtLeast3Creeps = 3.0;
const fixed c_Storm_AI_AtLeast4Creeps = 4.0;
const fixed c_Storm_AI_AtLeast1Minion = 1.0;
const fixed c_Storm_AI_AtLeast2Minions = 2.0;
const fixed c_Storm_AI_AtLeast3Minions = 3.0;
const fixed c_Storm_AI_AtLeast4Minions = 4.0;
const fixed c_Storm_AI_AtLeast5Minions = 5.0;
const fixed c_Storm_AI_AtLeast6Minions = 6.0;
const fixed c_Storm_AI_AtLeast7Minions = 7.0;
const fixed c_Storm_AI_AtLeast8Minions = 8.0;
const fixed c_Storm_AI_AtLeast9Minions = 9.0;
const fixed c_Storm_AI_DefaultTeamfightRange = 10.0;

const bool c_Storm_AI_AllowAnyHealing = true;
const bool c_Storm_AI_OnlyEssentialHealing = false;
const bool c_Storm_AI_LOS_Required = true;
const bool c_Storm_AI_LOS_Optional = false;

const fixed c_Storm_AI_HeavilyLosingTeamfight  = 2.0;
const fixed c_Storm_AI_LosingTeamfight         = 1.3;
const fixed c_Storm_AI_HeavilyWinningTeamfight = 0.1;
const fixed c_Storm_AI_WinningTeamfight        = .7;
const fixed c_Storm_AI_EvenTeamfight           = 1.0;
const fixed c_Storm_AI_AnyWinningCondition     = 0.0;
const fixed c_Storm_AI_AnyLosingCondition      = 2500.0;

// compare against this to detect an invalid ref because we can't use null or nullref
funcref<Storm_AI_AdjustScore> Storm_AI_AdjustScoreInvalidRef; // can't be const for some obscure reason.

//--------------------------------------------------------------------------------------------------
// Static data
//--------------------------------------------------------------------------------------------------

// Helper function to make filter creation easier.
unitfilter MakeSimpleAttributeUnitFilter(int attribute) {
    return UnitFilter(
        (1 << attribute),
        0,
        0,
        (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32))
    );
}
unitfilter c_Storm_AI_HeroFilter = MakeSimpleAttributeUnitFilter(c_targetFilterHeroic);
unitfilter c_Storm_AI_MinionFilter = UnitFilter(
    (1 << c_targetFilterBiological),
    0,
    0,
    (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterRobotic - 32)) | (1 << (c_targetFilterInvulnerable - 32)) | (1 << (c_targetFilterPassive - 32)) | (1 << (c_targetFilterBenign - 32))
);

// Only non-benign and non-passive creeps are considered because we don't want to attack them with tactical unless they've been initiated
unitfilter c_Storm_AI_AggroCreepFilter = UnitFilter(
    (1 << c_targetFilterLight),
    0,
    0,
    (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32)) | (1 << (c_targetFilterPassive - 32)) | (1 << (c_targetFilterBenign - 32))
);
unitfilter c_Storm_AI_LanerCreepFilter = UnitFilter(
    (1 << c_targetFilterRobotic),
    0,
    0,
    (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32)) | (1 << (c_targetFilterPassive - 32)) | (1 << (c_targetFilterBenign - 32))
);
unitfilter c_Storm_AI_TowerFilter = MakeSimpleAttributeUnitFilter(c_targetFilterArmored);
unitfilter c_Storm_AI_StructureFilter = MakeSimpleAttributeUnitFilter(c_targetFilterStructure);
unitfilter c_Storm_AI_PassiveCreepFilter = UnitFilter(
    (1 << c_targetFilterLight),
    (1 << (c_targetFilterPassive - 32)),
    0,
    (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32))
);
unitfilter c_Storm_AI_AttackableFilter = UnitFilter(
    0,
    0,
    0,
    (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32)) | (1 << (c_targetFilterPassive - 32)) | (1 << (c_targetFilterBenign - 32))
);

//--------------------------------------------------------------------------------------------------
// Variables
//--------------------------------------------------------------------------------------------------

unit[libCore_gv_bALMaxPlayers] abathurSymbioteUnit;
unit[libCore_gv_bALMaxPlayers] abathurUltimateEvolutionUnit;

//--------------------------------------------------------------------------------------------------
//  Tactical Helper Functions
//--------------------------------------------------------------------------------------------------
void ResetTargetQueryOptions (structref<Storm_AI_TargetQueryOptions> options) {
    options.lv_minDistance = 0.0;
    options.lv_maxDistance = 0.0;
    options.lv_distanceFactor = 0.0;
    options.lv_minHealthPercent = 0.0;
    options.lv_maxHealthPercent = 0.0;
    options.lv_healthFactor = 0.0;
    options.lv_minScore = 0.0;
    options.lv_projectedTargetDistance = 0.0;
    options.lv_matchingRole = -1; //Using -1 because 0 is used for warriors
    options.lv_roleFactor = 0.0;
    options.lv_adjustScoreCallback = Storm_AI_AdjustScoreInvalidRef;
    options.lv_lineOfSightRequired = false;
    options.lv_ignoreTargetsBehindGate = false;
    options.lv_ignoreTargetsBehindAlliedGate = false;
}

//---------------------------------------------------------------------------------------------
int GetOpposingFactionAITeamDataIndex (int faction) {
    //libGame_gv_teams, for some reason, is a 1-based array, so we need to return the correct
    //index which is defined by libGame_gv_teamOrderIndex_C and libGame_gv_teamChaosIndex_C
    //in case the indexing ever changes in the future.
    if (faction == libGame_ge_Faction_Order) {
        return libGame_gv_teamChaosIndex_C;
    }
    else {
        return libGame_gv_teamOrderIndex_C;
    }
}

//---------------------------------------------------------------------------------------------
int GetOpposingFaction (int faction) {
    if (faction == libGame_ge_Faction_Order) {
        return libGame_ge_Faction_Chaos;
    }
    else {
        return libGame_ge_Faction_Order;
    }
}

//---------------------------------------------------------------------------------------------
fixed Storm_AI_IgnoreTargetsInAOEDangerousToThem (unitgroup scanGroup, int player, unit aiUnit, unit targetUnit, fixed targetScore, point targetPosition) {
    if (libAIAI_gf_HeroAIIsPointInAOEDangerousToFaction(targetPosition, libAIAI_gv_aIHeroAvoidAOEAvoidExtraDistance, GetOpposingFaction(libGame_gv_players[player].lv_faction))) {
        return c_Storm_AI_InvalidScore;
    }
    return targetScore;
}

//---------------------------------------------------------------------------------------------
fixed Storm_AI_IgnoreTargetsInAOEDangerousToUs (unitgroup scanGroup, int player, unit aiUnit, unit targetUnit, fixed targetScore, point targetPosition) {
    if (libAIAI_gf_HeroAIIsPointInAOEDangerousToFaction(targetPosition, libAIAI_gv_aIHeroAvoidAOEAvoidExtraDistance, libGame_gv_players[player].lv_faction)) {
        return c_Storm_AI_InvalidScore;
    }
    return targetScore;
}

//---------------------------------------------------------------------------------------------
order StormHeroAICreateOrder (int player, string abilLink, int abilIndex) {
    abilcmd cmd = AbilityCommand(abilLink, abilIndex);
    order ord;
    if (cmd == c_nullCmd) {
        return null;
    }
    ord = Order(cmd);
    OrderSetPlayer(ord, player);
    return ord;
}

//---------------------------------------------------------------------------------------------
bool IsClaimedForTactical (int player) {
    return libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSCastTactical;
}

//---------------------------------------------------------------------------------------------
void HeroClaimForTactical (int player, fixed duration, bool endIfIdleOrVeryInjured) {
    if (libAIAI_gv_aIHeroes[player].lv_heroState != libAIAI_ge_HeroAIStates_HSCastTactical) {
        libAIAI_gf_HeroAIChangeState(player, libAIAI_ge_HeroAIStates_HSCastTactical);
    }
    libAIAI_gv_aIHeroes[player].lv_castTacticalTimeout = TimerGetElapsed(libGame_gv_gameTimer) + duration;
    libAIAI_gv_aIHeroes[player].lv_castTacticalEndIfIdleOrVeryInjured = endIfIdleOrVeryInjured;
}

//---------------------------------------------------------------------------------------------
void HeroReleaseFromTactical (int player) {
    libAIAI_gf_HeroAIReturnToCurrentObjective(player);
}

void HeroFocusOnHero (int player, unit targetHero) {
    if (libAIAI_gv_aIHeroFocusWeakHeroes[libAIAI_gv_aIHeroes[player].lv_difficulty]
        && libAIAI_gf_HeroAIIsHigherPriority(player, libAIAI_ge_HeroAIPriority_PushLanePushWithTeam)
        && libAIAI_gf_HeroAIHeroCanBeFocused(targetHero)) {
        libAIAI_gf_HeroAIChangeState(player, libAIAI_ge_HeroAIStates_HSFocusHero);
        libAIAI_gv_aIHeroes[player].lv_targetHero = targetHero;
        libAIAI_gv_aIHeroes[player].lv_targetHeroCheckPosition = null;
        libAIAI_gv_aIHeroes[player].lv_focusHeroTimeout = (TimerGetElapsed(libGame_gv_gameTimer) + libAIAI_gv_aIHeroFocusHeroMaxChaseTime);
    }
}

//---------------------------------------------------------------------------------------------
bool HeroIssueOrder (int player, unit aiUnit, order spellOrd, order attackOrd, int addToFront, unit targetUnit, point pos) {
    // Make AI miss skillshots
    point fudgedTargetPos;

    if (pos != null) {
        fudgedTargetPos = libAIAI_gf_HeroAIFudgeTargetPosition(player, pos);
    }

    // Set the target of the attack order
    if (attackOrd != null) {
        if (targetUnit != null) {
            OrderSetTargetUnit(attackOrd, targetUnit);
        }
        else if (fudgedTargetPos != null) {
            OrderSetTargetPoint(attackOrd, fudgedTargetPos);
        }

        if (UnitIssueOrder(aiUnit, attackOrd, c_orderQueueReplace)) {
            addToFront = c_orderQueueAddToFront;
        }
    }

    libAIAI_gf_HeroAIUpdateNextSpellCheckTime(player);

    // Cast the ability
    if (spellOrd != null) {
        // Set the target of the spell order
        if (fudgedTargetPos != null) {
            OrderSetTargetPoint(spellOrd, fudgedTargetPos);
        }
        else if (targetUnit != null) {
            OrderSetTargetUnit(spellOrd, targetUnit);
        }

        return UnitIssueOrder(aiUnit, spellOrd, addToFront);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
point MovePointTowardsPoint (point p1, point p2, fixed dist) {
    fixed dx;
    fixed dy;
    fixed t;

    dx = PointGetX(p2) - PointGetX(p1);
    dy = PointGetY(p2) - PointGetY(p1);
    t = SquareRoot(dx * dx + dy * dy);
    if(t == 0.0) {
        return p1;
    }
    t = dist / t;
    return Point(PointGetX(p1) + t * dx, PointGetY(p1) + t * dy);
}

//---------------------------------------------------------------------------------------------
point PointScaleFixed (point p, fixed scalar) {
    return Point(PointGetX(p) * scalar, PointGetY(p) * scalar);
}

//---------------------------------------------------------------------------------------------
point PointNegate (point p) {
    return Point(-PointGetX(p), -PointGetY(p));
}

//---------------------------------------------------------------------------------------------
// Returns the magnitude of the potential orthogonal vector in 3d.
fixed PointCrossProduct2D(point p1, point p2) {
    return (PointGetX(p1) * PointGetY(p2)) - (PointGetY(p1) * PointGetY(p2));
}

//---------------------------------------------------------------------------------------------
// Meant for vectors, obviously, but we only have a single point type in Galaxy.
fixed PointDotProduct (point p1, point p2) {
    return (PointGetX(p1) * PointGetX(p2)) + (PointGetY(p1) * PointGetY(p2));
}

//---------------------------------------------------------------------------------------------
point PointAddition (point p1, point p2) {
    return Point(PointGetX(p1) + PointGetX(p2), PointGetY(p1) + PointGetY(p2));
}

//---------------------------------------------------------------------------------------------
point PointSubtraction (point p1, point p2) {
    return Point(PointGetX(p1) - PointGetX(p2), PointGetY(p1) - PointGetY(p2));
}

//---------------------------------------------------------------------------------------------
// NOTE: vec should not be (0.0, 0.0) because a null point will be returned and accessing it will generate an error message.
point TacticalNormalize (point vec) {
    fixed length;

    length = SquareRoot(PointGetX(vec) * PointGetX(vec) + PointGetY(vec) * PointGetY(vec));
    if(length == 0.0) {
        return c_nullPoint;
    }
    return Point(PointGetX(vec) / length, PointGetY(vec) / length);
}

//---------------------------------------------------------------------------------------------
point ProjectPointOntoLine (point p1, point p2, point t) {
    // Projects a point onto a line between p1 & p2 (that extends beyond both ends).
    fixed diffx;
    fixed diffy;
    fixed length;
    point axis;
    point line;
    fixed projMag;
    point final;

    // Get the unit line segment axis
    diffx =  PointGetX(p2) - PointGetX(p1);
    diffy = PointGetY(p2) - PointGetY(p1);
    length = SquareRoot(diffx * diffx + diffy * diffy);

    if (length == 0.0) {
        return p1;
    }

    axis = Point(diffx / length, diffy / length);

    // Project point we are testing onto the axis
    line = Point(PointGetX(t) - PointGetX(p1), PointGetY(t) - PointGetY(p1));
    projMag = PointGetX(axis) * PointGetX(line) + PointGetY(axis) * PointGetY(line);

    final = Point(PointGetX(p1) + PointGetX(axis) * projMag, PointGetY(p1) + PointGetY(axis) * projMag);
    return final;
}

//---------------------------------------------------------------------------------------------
bool LineSegmentCollide (point p1, point p2, point t, fixed r) {
    // Test if point t is inside a line segment from p1 to p2 that extends r in both directions normal to the segment axis (squared off capsule)
    fixed diffx;
    fixed diffy;
    fixed length;
    point axis;
    point line;
    fixed projMag;
    point orth;
    fixed orthMagSquare;

    // Get the unit line segment axis
    diffx =  PointGetX(p2) - PointGetX(p1);
    diffy = PointGetY(p2) - PointGetY(p1);
    length = SquareRoot(diffx * diffx + diffy * diffy);

    if (length == 0.0) {
        return false;
    }

    axis = Point(diffx / length, diffy / length);

    // Project point we are testing onto the axis
    line = Point(PointGetX(t) - PointGetX(p1), PointGetY(t) - PointGetY(p1));
    projMag = PointGetX(axis) * PointGetX(line) + PointGetY(axis) * PointGetY(line);

    // The projection of the point onto the line segment axis is not on the line segment,
    // so it does not collide with the line segment
    if (projMag < 0.0 || projMag > length) {
        return false;
    }

    // Check if it is within the radius of the line
    orth = Point(PointGetX(line) - PointGetX(axis) * projMag, PointGetY(line) - PointGetY(axis) * projMag);
    orthMagSquare = PointGetX(orth) * PointGetX(orth) + PointGetY(orth) * PointGetY(orth);

    // The test point is further than r away from the line segment, so it does not collide with it
    if (orthMagSquare > r * r) {
        return false;
    }

    return true;
}

//---------------------------------------------------------------------------------------------
point LeadPoint (point startingPoint, point endingPoint, unit targetUnit, fixed scalar, bool useTargetFacing, bool rotateVector180Degrees) {
    // Returns a lead vector.
    // bool useTargetFacing TRUE if we want to lead based on target facing, FALSE if we want to
    // place the lead point along a line from startingPoint to endingPoint that
    // extends beyond endingPoint.
    // Bool rotateVector180Degrees TRUE if we want the lead point to be facing the opposite
    // direction from its original. For example if useTargetFacing is FALSE and
    // rotateVector180Degrees is TRUE then our lead point no longer extend beyond endingPoint,
    // instead we force the lead point to always be placed along a line between
    // startingPoint and endingPoint.
    point leadPoint;

    if (!useTargetFacing) {
        // create the vector from startingPoint to endingPoint
        leadPoint = TacticalNormalize(PointSubtraction(endingPoint, startingPoint));

        // If rotateVector180Degrees is TRUE,
        // the placement of the ability should be between the caster and target in the
        // hopes that we can force them to stop chasing.
        if (rotateVector180Degrees) {
            leadPoint = PointNegate(leadPoint);
        }

        // scale our vector and combine its magnitude with that of the endingPoint vector
        leadPoint = PointScaleFixed(leadPoint, scalar);
        leadPoint = PointAddition(endingPoint, leadPoint);
    }
    else {
        // create the vector from endingPoint with a magnitude in the direction of
        // the targetUnit's facing
        leadPoint = PointWithOffsetPolar(endingPoint, scalar, UnitGetFacing(targetUnit));
    }

    return leadPoint;
}

//---------------------------------------------------------------------------------------------
bool HaveBeenAttackedRecently (unit aiUnit) {
    if (UnitTestState(aiUnit, c_unitStateHallucination)) {
        return AILastAttack(aiUnit) >= (AIGetTime() - 3.0);
    }
    else {
        return libAIAI_gf_HeroAIHeroHasBeenAttackedRecently(UnitGetOwner(aiUnit), 3.0);
    }
}

//---------------------------------------------------------------------------------------------
unitgroup UnitsInArea (unitgroup group, point center, fixed radius) {
    return UnitGroupFilterRegion(group, RegionCircle(center, radius), 0);
}

//---------------------------------------------------------------------------------------------
unitgroup AllyUnitsInArea (int player, point center, fixed radius) {
    return UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), null, c_noMaxCount);
}

//---------------------------------------------------------------------------------------------
unitgroup AllyHeroUnitsInArea (int player, point center, fixed radius) {
    return UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), c_Storm_AI_HeroFilter, c_noMaxCount);
}

//---------------------------------------------------------------------------------------------
unitgroup AllyMinionUnitsInArea (int player, point center, fixed radius) {
    return UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), c_Storm_AI_MinionFilter, c_noMaxCount);
}

//---------------------------------------------------------------------------------------------
bool AnyAllyHeroUnitsInArea (int player, point center, fixed radius) {
    return UnitGroupCount(UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), c_Storm_AI_HeroFilter, 1), c_unitCountAll) > 0;
}

//---------------------------------------------------------------------------------------------
bool AnyAllyMinionUnitsInArea (int player, point center, fixed radius) {
    return UnitGroupCount(UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), c_Storm_AI_MinionFilter, 1), c_unitCountAll) > 0;
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterHeroes (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_HeroFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterMinions (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_MinionFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterHeroOrMinion (unitgroup group) {
    unitgroup result = UnitGroupFilterHeroes(group);
    UnitGroupAddUnitGroup(result, UnitGroupFilterMinions(group));
    return result;
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterAggroCreeps (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_AggroCreepFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterLanerCreeps (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_LanerCreepFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterAggroCreepsOrLanerCreeps (unitgroup group) {
    unitgroup result = UnitGroupFilterAggroCreeps(group);
    UnitGroupAddUnitGroup(result, UnitGroupFilterLanerCreeps(group));
    return result;
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterTowers (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_TowerFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterStructures (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_StructureFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupFilterAttackable (unitgroup group) {
    return UnitGroupFilter(null, c_playerAny, group, c_Storm_AI_AttackableFilter, 0);
}

//---------------------------------------------------------------------------------------------
unitgroup UnitGroupUnitsInRing (unitgroup scanGroup, point p, fixed innerRadius, fixed outerRadius) {
    int i;
    unit currUnit;
    int count;
    fixed squaredRadius = innerRadius * innerRadius;
    unitgroup toReturn = UnitGroupEmpty();
    unitgroup enemyGroup;
    unitgroup circleGroup;

    enemyGroup = UnitGroupFilterHeroes(scanGroup);
    UnitGroupAddUnitGroup(enemyGroup, UnitGroupFilterAggroCreeps(scanGroup));
    UnitGroupAddUnitGroup(enemyGroup, UnitGroupFilterMinions(scanGroup));

    circleGroup = UnitsInArea(enemyGroup, p, outerRadius);

    count = UnitGroupCount(circleGroup, c_unitCountAll);
    for (i = 1; i <= count; i += 1) {
        currUnit = UnitGroupUnit(circleGroup, i);
        if (DistanceSquaredBetweenPoints(p, UnitGetPosition(currUnit)) >= squaredRadius) {
            UnitGroupAdd(toReturn, currUnit);
        }
    }
    return toReturn;
}

//---------------------------------------------------------------------------------------------
const int c_towerNearbyDist = 12;
unit GetNearbyTower (unit aiUnit, unitgroup group) {
    unitgroup tower = UnitGroupFilterRegion(UnitGroupFilterTowers(group), RegionCircle(UnitGetPosition(aiUnit), c_towerNearbyDist), 1);

    if (UnitGroupCount(tower, c_unitCountAll) > 0) {
        return UnitGroupUnit(tower, 1);
    }

    return null;
}

//---------------------------------------------------------------------------------------------
bool CheckIfTooLowHealthOrNearbyTower (unit aiUnit, unitgroup scanGroup, fixed minHealth) {
    unit nearbyTower;
    fixed curHealth = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);

    if (curHealth < minHealth) {
        return true;
    }

    nearbyTower = GetNearbyTower(aiUnit, scanGroup);
    if (UnitIsValid(nearbyTower)) {
        return true;
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool IsTargetAcrossGate (unit aiUnit, unit target, unitgroup relevantUnits, fixed projectedTargetDistance) {
    int blockingIndex;
    unit blockingUnitToCheck;
    point blockingUnitToCheckPosition;
    fixed blockingUnitToCheckFacing;
    fixed gateCrossSelf;
    point gateFacingVector;
    point gateAxis;
    point gateToSelf;
    point gateToTarget;
    fixed gateCrossTarget;
    point unitPosition;
    point targetPosition;
    bool blocked = false;

    unitPosition = UnitGetPosition(aiUnit);
    targetPosition = UnitGetPosition(target);
    for (blockingIndex = 1; blockingIndex <= UnitGroupCount(relevantUnits, c_unitCountAll); blockingIndex += 1) {
        blockingUnitToCheck = UnitGroupUnit(relevantUnits, blockingIndex);

        if (target == blockingUnitToCheck
            || !UnitIsAlive(blockingUnitToCheck)) {
            continue;
        }

        if (!UnitTypeTestFlag(UnitGetType(blockingUnitToCheck), c_unitFlagTownStructureGate)) {
            continue;
        }

        blockingUnitToCheckPosition = UnitGetPosition(blockingUnitToCheck);
        blockingUnitToCheckFacing = UnitGetFacing(blockingUnitToCheck);
        // We get the facing first
        gateFacingVector = Point(Cos(blockingUnitToCheckFacing), Sin(blockingUnitToCheckFacing));
        // We swap x and y and negate one so that we rotate 90 degrees because we want a vector along the length of the gate
        gateAxis = Point(-PointGetY(gateFacingVector), PointGetX(gateFacingVector));

        // get the cross product of ourself relative to the gate and the gate's axis.
        gateToSelf = Point(PointGetX(unitPosition) - PointGetX(blockingUnitToCheckPosition), PointGetY(unitPosition) - PointGetY(blockingUnitToCheckPosition));
        gateCrossSelf = PointGetX(gateAxis) * PointGetY(gateToSelf) - PointGetY(gateAxis) * PointGetX(gateToSelf);

        // optionally move targetPosition further away from unitPosition so that we test a point behind the target from our perspective.
        if (projectedTargetDistance != 0.0) {
            targetPosition = MovePointTowardsPoint(targetPosition, unitPosition, -projectedTargetDistance);
        }

        // Check which direction we need to move the unit
        if (((PointGetX(gateFacingVector) * PointGetX(gateToSelf)) + (PointGetY(gateFacingVector) * PointGetY(gateToSelf))) > 0.0) {
            // Facing out, negate and scale it
            gateFacingVector = Point(-PointGetX(gateFacingVector) * 2.0, -PointGetY(gateFacingVector) * 2.0);
        }
        else {
            gateFacingVector = Point(PointGetX(gateFacingVector) * 2.0, PointGetY(gateFacingVector) * 2.0);
        }
        // Add the scaled normal to the point to make the buffer zone.
        targetPosition = Point(PointGetX(targetPosition) + PointGetX(gateFacingVector), PointGetY(targetPosition) + PointGetY(gateFacingVector));

        // get the cross product of the target relative to the gate and the gate's axis.
        gateToTarget = Point(PointGetX(targetPosition) - PointGetX(blockingUnitToCheckPosition), PointGetY(targetPosition) - PointGetY(blockingUnitToCheckPosition));
        gateCrossTarget = PointGetX(gateAxis) * PointGetY(gateToTarget) - PointGetY(gateAxis) * PointGetX(gateToTarget);

        // If the cross products have a different sign (multiply to be negative), then they are on opposite sides of the gate
        if (gateCrossSelf * gateCrossTarget < 0.0) {
            blocked = true;
            break;
        }
    }

    return blocked;
}

//---------------------------------------------------------------------------------------------
bool IsTargetBlocked (point startPosition, point targetPosition, unitgroup scanGroup, unit ignoreUnit) {
    bool blocked;
    unit blockingUnitToCheck;
    int blockingIndex;

    // check if any of the units in the scan group intersect the line segment connecting the two points with a width of 1.5
    blockingIndex = UnitGroupCount(scanGroup, c_unitCountAll);
    blocked = false;
    // check all the units in the area
    while (blockingIndex > 0) {
        blockingUnitToCheck = UnitGroupUnit(scanGroup, blockingIndex);
        blockingIndex = blockingIndex - 1;

        if (ignoreUnit == blockingUnitToCheck) {
            continue;
        }

        if (LineSegmentCollide(startPosition, targetPosition, UnitGetPosition(blockingUnitToCheck), 1.5)) {
            blocked = true;
            break;
        }
    }

    return blocked;
}

//---------------------------------------------------------------------------------------------
unit FindBestUnit (unitgroup testGroup, unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    point unitPosition;
    int unitCount;
    int player;
    unit nearestUnit;
    fixed nearestHeroDistance;

    point inFrontofUnit;
    region inFrontRegion;
    unitgroup unitsInTheWayGroup;
    unitgroup minionsInTheWayGroup;
    unit target;
    fixed targetHealthPercent;
    point targetPosition;
    fixed targetDistance;
    fixed targetScore;
    fixed inverseHealthRange;
    bool lineOfSightRequired;

    unit bestUnit;
    fixed bestScore;

    bestScore = c_Storm_AI_InvalidScore; // Scaled score may be negative so we set our starting best score to a massively negative number.
    unitPosition = UnitGetPosition(aiUnit);
    player = UnitGetOwner(aiUnit);
    unitCount = UnitGroupCount(testGroup, c_unitCountAll);
    // setup the inverse health range such that incorrect configuration results in a 0 score modification
    // and we assume a maximum of 100 if no maximum is set.
    inverseHealthRange = 0.0;
    if (options.lv_maxHealthPercent > options.lv_minHealthPercent) {
        inverseHealthRange = 1.0 / (options.lv_maxHealthPercent - options.lv_minHealthPercent);
    }
    else if (options.lv_minHealthPercent < 100.0) {
        inverseHealthRange = 1.0 / (100.0 - options.lv_minHealthPercent);
    }

    lineOfSightRequired = options.lv_lineOfSightRequired && libAIAI_gv_aIHeroLineUpClearShotForSkillShots[libAIAI_gv_aIHeroes[player].lv_difficulty];

    // check all the units in the area
    while (unitCount > 0) {
        target = UnitGroupUnit(testGroup,unitCount);
        unitCount = unitCount - 1;

        // make sure unit is alive
        if (!UnitIsAlive(target)) {
            continue;
        }

        // make sure it is within the health percent constraints
        targetHealthPercent = UnitGetPropertyFixed(target, c_unitPropLifePercent, c_unitPropCurrent);
        if (targetHealthPercent < options.lv_minHealthPercent || (options.lv_maxHealthPercent > 0.0 && targetHealthPercent > options.lv_maxHealthPercent)) {
            continue;
        }

        targetPosition = UnitGetPosition(target);
        targetDistance = DistanceBetweenPoints(unitPosition, targetPosition);
        targetDistance = targetDistance - UnitGetPropertyFixed(target, c_unitPropRadius, c_unitPropCurrent);
        if (targetDistance < 0.0) {
            targetDistance = 0.0; // clamp because negative distances cause units to be excluded
        }

        // make sure it is within the distance constraint
        if (targetDistance < options.lv_minDistance || (options.lv_maxDistance > 0.0 && targetDistance > options.lv_maxDistance)) {
            continue;
        }

        // setup the basic unit score
        targetScore = c_Storm_AI_FullHeroScore * UnitGetPropertyFixed(target, c_unitPropAIEvaluationFactor, c_unitPropCurrent);

        // check the unscaled targetScore against the minscore so that scaling can't make a unit seem valid even though we shouldn't ever target it.
        if (targetScore < options.lv_minScore) {
            continue;
        }

        // add to the score based on distance
        if (options.lv_maxDistance > 0.0 && options.lv_maxDistance > options.lv_minDistance) {
            if (options.lv_distanceFactor > 0.0) {
                targetScore = targetScore + options.lv_distanceFactor * (options.lv_maxDistance - targetDistance) / (options.lv_maxDistance - options.lv_minDistance);
            }
            else if (options.lv_distanceFactor < 0.0) {
                targetScore = targetScore - options.lv_distanceFactor * (targetDistance - options.lv_minDistance) / (options.lv_maxDistance - options.lv_minDistance);
            }
        }

        // add to the score based on health
        if (options.lv_healthFactor > 0.0) {
            targetScore = targetScore + options.lv_healthFactor * (options.lv_maxHealthPercent - targetHealthPercent) * inverseHealthRange;
        }
        else if (options.lv_healthFactor < 0.0) {
            targetScore = targetScore - options.lv_healthFactor * (targetHealthPercent - options.lv_minHealthPercent) * inverseHealthRange;
        }

        // add to the score based on role
        if (options.lv_roleFactor != 0.0 && options.lv_matchingRole == libGame_gv_players[UnitGetOwner(target)].lv_heroData.lv_class) {
            targetScore = targetScore + options.lv_roleFactor;
        }

        // optionally run a callback to adjust the score for various reasons, e.g. chilled targets get 1.5 score. The callback can also filter by setting the score to c_Storm_AI_InvalidScore.
        if (options.lv_adjustScoreCallback != Storm_AI_AdjustScoreInvalidRef) {
            targetScore = options.lv_adjustScoreCallback(scanGroup, player, aiUnit, target, targetScore, targetPosition);
        }

        // If the score is worse than what we have, then skip the target.
        if (targetScore < bestScore) {
            continue;
        }

        // make sure it there is a clear shot between the units if requested
        // replace with something better later
        if (lineOfSightRequired && IsTargetBlocked(unitPosition, targetPosition, scanGroup, target)) {
            continue;
        }

        // Make sure there is no allied gate between us and the target for abilities that cannot be used through them
        if (options.lv_ignoreTargetsBehindAlliedGate
            && IsTargetAcrossGate(aiUnit, target, UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(unitPosition, options.lv_maxDistance), c_Storm_AI_StructureFilter, c_noMaxCount), options.lv_projectedTargetDistance)) {
              continue;
        }
        // make sure there is no enemy gate between us and the target (this assumes we will not get onto the bad side of a gate).
        // replace with something better later
        if (options.lv_ignoreTargetsBehindGate
            && IsTargetAcrossGate(aiUnit, target, scanGroup, options.lv_projectedTargetDistance)) {
            continue;
        }

        bestUnit = target;
        bestScore = targetScore;
    }

    return bestUnit;
}

//---------------------------------------------------------------------------------------------
// DEPRECATED
unit FindClosestWeakUnit (unitgroup testGroup, unitgroup scanGroup, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    Storm_AI_TargetQueryOptions options;

    // maxHealth and minMissingHealth aren't set anywhere, so they are not part of the new API.
    options.lv_minDistance = minDist;
    options.lv_maxDistance = maxDist;
    options.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    //options.lv_minHealthPercent = 0.0;
    options.lv_maxHealthPercent = maxHealthPercent;
    options.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    options.lv_lineOfSightRequired = clearShot;
    //options.lv_ignoreTargetsBehindGate = false;

    return FindBestUnit(testGroup, scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
unitgroup FilterBadHeroTargets (unitgroup scanGroup, int player) {
    int unitCount;
    unit unitToCheck;
    fixed healthPercent;

    // Avoid targetting weak human heroes
    if (!libAIAI_gv_aIHeroCastAbilitiesOnWeakHumanHeroes[libAIAI_gv_aIHeroes[player].lv_difficulty]) {
        unitCount = UnitGroupCount(scanGroup, c_unitCountAll);
        while (unitCount > 0) {
            unitToCheck = UnitGroupUnit(scanGroup, unitCount);
            unitCount = unitCount - 1;

            if (UnitTypeTestAttribute(UnitGetType(unitToCheck), c_unitAttributeHeroic) == false) {
                continue;
            }

            if (libAIAI_gf_HeroAIIsPlayerActive(UnitGetOwner(unitToCheck), libAIAI_gv_heroAIHumanPlayerType) == false) {
                continue;
            }

            healthPercent =  UnitGetPropertyFixed(unitToCheck, c_unitPropLifePercent, c_unitPropCurrent);
            if (healthPercent > 25.0) {
                continue;
            }

            UnitGroupRemove(scanGroup, unitToCheck);
        }
    }

    return scanGroup;
}

//---------------------------------------------------------------------------------------------
// Heroes are ranked based on health, distance, and the unit's AIEvaluationFactor
// e.g. (healers are worth more, misha is worth less)
unit FindBestHero (unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    return FindBestUnit(FilterBadHeroTargets(UnitGroupFilterHeroes(scanGroup), UnitGetOwner(aiUnit)), scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
// Minions are ranked based on health, distance, and the unit's AIEvaluationFactor
unit FindBestMinion (unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    return FindBestUnit(UnitGroupFilterMinions(scanGroup), scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
// Creeps are ranked based on health, distance, and the unit's AIEvaluationFactor
unit FindBestAggroCreep (unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    return FindBestUnit(UnitGroupFilterAggroCreeps(scanGroup), scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
// Creeps are ranked based on health, distance, and the unit's AIEvaluationFactor
// We don't want creeps with c_targetFilterUser1 because they're special map creeps.
unit FindBestPassiveCampCreep (unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    return FindBestUnit(UnitGroupFilter(null, c_playerAny, scanGroup, c_Storm_AI_PassiveCreepFilter, 0), scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
// Units are ranked based on health, distance, and the unit's AIEvaluationFactor
unit FindBestTacticalTarget (unitgroup scanGroup, unit aiUnit, structref<Storm_AI_TargetQueryOptions> options) {
    unitgroup targets;
    unit target;

    // search heroes first
    targets = FilterBadHeroTargets(UnitGroupFilterHeroes(scanGroup), UnitGetOwner(aiUnit));
    target = FindBestUnit(targets, scanGroup, aiUnit, options);
    if (target != null) {
        return target;
    }

    // otherwise try aggro creeps
    targets = UnitGroupFilterAggroCreeps(scanGroup);
    target = FindBestUnit(targets, scanGroup, aiUnit, options);
    if (target != null) {
        return target;
    }

    // otherwise try minions
    targets = UnitGroupFilterMinions(scanGroup);
    return FindBestUnit(targets, scanGroup, aiUnit, options);
}

//---------------------------------------------------------------------------------------------
unit FindClosestWeakHero (unitgroup scanGroup, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    unitgroup targets = FilterBadHeroTargets(UnitGroupFilterHeroes(scanGroup), UnitGetOwner(aiUnit));
    return FindClosestWeakUnit(targets, scanGroup, aiUnit, minDist, maxDist, maxHealthPercent, maxHealth, minMissingHealth, clearShot);
}

//---------------------------------------------------------------------------------------------
unit FindClosestWeakMinion (unitgroup scanGroup, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    return FindClosestWeakUnit(UnitGroupFilterMinions(scanGroup), scanGroup, aiUnit, minDist, maxDist, maxHealthPercent, maxHealth, minMissingHealth, clearShot);
}

//---------------------------------------------------------------------------------------------
unit FindClosestWeakHeroOrMinion (unitgroup scanGroup, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    unitgroup targets = FilterBadHeroTargets(UnitGroupFilterHeroOrMinion(scanGroup), UnitGetOwner(aiUnit));
    return FindClosestWeakUnit(targets, scanGroup, aiUnit, minDist, maxDist, maxHealthPercent, maxHealth, minMissingHealth, clearShot);
}

//---------------------------------------------------------------------------------------------
unit FindClosestWeakTower (unitgroup scanGroup, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    return FindClosestWeakUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, minDist, maxDist, maxHealthPercent, maxHealth, minMissingHealth, clearShot);
}

//---------------------------------------------------------------------------------------------
unit FindCoreInGroup (unitgroup scanGroup, int player, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, bool clearShot) {
    fixed targetHealthPercent;
    point unitPosition;
    point targetPosition;
    fixed targetDistance;
    int teamIndex = GetOpposingFactionAITeamDataIndex(libGame_gv_players[player].lv_faction);
    unit target = libGame_gv_teams[teamIndex].lv_core;
    if (!UnitIsValid(target) || !UnitGroupHasUnit(scanGroup, target)) {
        return null;
    }

    // make sure it is within the health percent constraints
    targetHealthPercent = UnitGetPropertyFixed(target, c_unitPropLifePercent, c_unitPropCurrent);
    if (maxHealthPercent > 0.0 && targetHealthPercent > maxHealthPercent) {
        return null;
    }

    unitPosition = UnitGetPosition(aiUnit);
    targetPosition = UnitGetPosition(target);
    targetDistance = DistanceBetweenPoints(unitPosition, targetPosition);
    targetDistance = targetDistance - UnitGetPropertyFixed(target, c_unitPropRadius, c_unitPropCurrent);
    if (targetDistance < 0.0) {
        targetDistance = 0.0; // clamp because negative distances cause units to be excluded
    }

    // make sure it is within the distance constraint
    if (targetDistance < minDist || (maxDist > 0.0 && targetDistance > maxDist)) {
        return null;
    }

    //check line of sight if requested
    if (clearShot && IsTargetBlocked(unitPosition, targetPosition, scanGroup, target)) {
        return null;
    }

    return target;
}

//---------------------------------------------------------------------------------------------
unit FindClosestWeakTowerOrCore (unitgroup scanGroup, int player, unit aiUnit, fixed minDist, fixed maxDist, fixed maxHealthPercent, fixed maxHealth, fixed minMissingHealth, bool clearShot) {
    unit target = FindClosestWeakUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, minDist, maxDist, maxHealthPercent, maxHealth, minMissingHealth, clearShot);
    if (!UnitIsValid(target)) {
        target = FindCoreInGroup(scanGroup, player, aiUnit, minDist, maxDist, maxHealthPercent, clearShot);
    }

    return target;
}

//---------------------------------------------------------------------------------------------
unit FindClosestGate (unitgroup scanGroup, unit aiUnit, fixed maxDistance) {
    point unitPosition;
    int targetCount;
    unit target;
    fixed targetDistance;
    unit bestTarget;
    fixed bestDistance = maxDistance;
    unitgroup targets = UnitGroupFilterStructures(scanGroup);

    unitPosition = UnitGetPosition(aiUnit);
    targetCount = UnitGroupCount(targets, c_unitCountAll);

    // check all the units in the area
    while (targetCount > 0) {
        target = UnitGroupUnit(targets, targetCount);
        targetCount = targetCount - 1;

        // make sure unit is a valid gate
        if (!UnitIsValid(target)  || !UnitTypeTestFlag(UnitGetType(target), c_unitFlagTownStructureGate)) {
            continue;
        }

        targetDistance = DistanceBetweenPoints(unitPosition, UnitGetPosition(target));

        // make sure it is within the distance constraint
        if (targetDistance > bestDistance) {
            continue;
        }

        bestTarget = target;
        bestDistance = targetDistance;
    }

    return bestTarget;
}

//---------------------------------------------------------------------------------------------
unit FindStrongestNearbyAllyHero (int player, unit aiUnit, fixed maxDist, fixed minHealthPercent, bool excludeSelf) {
    // chosen by hitpoints, but at least a certain health percent
    region r;
    unitgroup nearbyAllies;
    int allyCount;
    unit unitToCheck;
    fixed unitHealth;
    fixed unitHealthPercent;
    unit resultUnit;
    fixed resultHealth = -1.0;

    // find nearby allied heroes
    r = RegionCircle(UnitGetPosition(aiUnit), maxDist);
    nearbyAllies = UnitGroupAlliance(player, c_unitAllianceAlly, r, null, c_noMaxCount);
    nearbyAllies = UnitGroupFilterHeroes(nearbyAllies);

    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally heroes in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies,allyCount);
        allyCount = allyCount - 1;

        if (excludeSelf && aiUnit == unitToCheck) {
            continue;
        }

        unitHealthPercent = UnitGetPropertyFixed(unitToCheck, c_unitPropLifePercent, c_unitPropCurrent);

        if (unitHealthPercent < minHealthPercent) {
            continue;
        }

        unitHealth = UnitGetPropertyFixed(unitToCheck, c_unitPropLife, c_unitPropCurrent);

        if (unitHealth > resultHealth) {
            resultUnit = unitToCheck;
            resultHealth = unitHealth;
        }
    }

    return resultUnit;
}

//---------------------------------------------------------------------------------------------
unit FindWeakestNearbyAllyHero (int player, unit aiUnit, fixed maxDist, fixed maxHealthPercent, fixed minMissingHealth, bool excludeSelf) {
    region r;
    unitgroup nearbyAllies;
    int allyCount;
    unit unitToCheck;
    fixed unitHealthPercent;
    unit resultUnit;
    fixed resultHealthPercent = maxHealthPercent;

    // find nearby allied heroes
    r = RegionCircle(UnitGetPosition(aiUnit), maxDist);
    nearbyAllies = UnitGroupAlliance(player, c_unitAllianceAlly, r, null, c_noMaxCount);
    nearbyAllies = UnitGroupFilterHeroes(nearbyAllies);

    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally heroes in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies,allyCount);
        allyCount = allyCount - 1;

        if (excludeSelf && aiUnit == unitToCheck) {
            continue;
        }

        unitHealthPercent = UnitGetPropertyFixed(unitToCheck, c_unitPropLifePercent, c_unitPropCurrent);

        if (unitHealthPercent < resultHealthPercent) {
            resultUnit = unitToCheck;
            resultHealthPercent = unitHealthPercent;
        }
    }

    return resultUnit;
}

//---------------------------------------------------------------------------------------------
unit FindBestHealTarget (int player, unit aiUnit, fixed maxDist, bool allowAnyHealing, bool excludeSelf) {
    region r;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unitgroup nearbyAllies;
    fixed humanHealBonus;
    int allyCount;
    unit unitToCheck;
    bool unitIsAI;
    fixed unitHealthPercent;
    unit bestUnit;
    bool bestUnitIsAI;
    fixed bestUnitHealthPercent;

    // find nearby allied heroes
    r = RegionCircle(UnitGetPosition(aiUnit), maxDist);
    nearbyAllies = UnitGroupAlliance(player, c_unitAllianceAlly, r, null, c_noMaxCount);
    nearbyAllies = UnitGroupFilterHeroes(nearbyAllies);

    if (excludeSelf) {
        UnitGroupRemove(nearbyAllies, aiUnit);
    }

    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally heroes in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies,allyCount);
        allyCount = allyCount - 1;
        if (!UnitIsValid(unitToCheck)) {
            continue;
        }

        unitHealthPercent = UnitGetPropertyFixed(unitToCheck, c_unitPropLifePercent, c_unitPropCurrent);

        unitIsAI = libAIAI_gf_HeroAIIsPlayerActive(UnitGetOwner(unitToCheck), libAIAI_gv_heroAIComputerPlayerType);
        if (!unitIsAI && (energy > libAIAI_gv_aIHeroLowEnergyPercent)) {
            humanHealBonus = 10.0;
        } else {
            humanHealBonus = 0.0;
        }

        if ((allowAnyHealing && unitHealthPercent <= 98.0)
            || unitHealthPercent < (65.0 + humanHealBonus)
            || (HaveBeenAttackedRecently(unitToCheck) && unitHealthPercent < (75.0 + (humanHealBonus/2.0)))) {
            // Check if this is better than our current best target
            if (UnitIsValid(bestUnit)) {
                // Prioritize human heroes over AI
                if (!unitIsAI && bestUnitIsAI) {
                    if (unitHealthPercent > bestUnitHealthPercent + libAIAI_gv_aIHeroPrioritizeHealingHumanAlliesThreshold[libAIAI_gv_aIHeroes[player].lv_difficulty]) {
                        continue;
                    }
                }
                else {
                    if (unitHealthPercent > bestUnitHealthPercent) {
                        continue;
                    }
                }
            }

            bestUnit = unitToCheck;
            bestUnitIsAI = unitIsAI;
            bestUnitHealthPercent = unitHealthPercent;
        }
    }

    return bestUnit;
}

//---------------------------------------------------------------------------------------------
fixed GetTotalLifeHealInBlast (int player, unit aiUnit, fixed maxDist, fixed healPerHero) {
    region r;
    unitgroup nearbyAllies;
    fixed unitHealthMax;
    fixed unitHealthExpected;
    fixed totalLifeHeal = 0.0;

    int allyCount;
    unit unitToCheck;

    // find nearby allied heroes
    r = RegionCircle(UnitGetPosition(aiUnit), maxDist);
    nearbyAllies = UnitGroupAlliance(player, c_unitAllianceAlly, r, null, c_noMaxCount);
    nearbyAllies = UnitGroupFilterHeroes(nearbyAllies);

    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally heroes in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies,allyCount);
        allyCount = allyCount - 1;

        if(UnitIsValid(unitToCheck)) {
            // This uses the expected final health value to decide how much healing can be done.
            unitHealthMax = UnitGetPropertyFixed(unitToCheck, c_unitPropLifeMax, c_unitPropCurrent);
            unitHealthExpected = UnitGetPropertyFixed(unitToCheck, c_unitPropLife, c_unitPropCurrent) + UnitGetPropertyFixed(unitToCheck, c_unitPropLifeExpected, c_unitPropCurrent);
            // Clamp to positive healing values because unitHealthExpected may be larger than unitHealthMax
            totalLifeHeal += MaxF(0, MinF(healPerHero, unitHealthMax - unitHealthExpected));
        }
    }

    return totalLifeHeal;
}

//---------------------------------------------------------------------------------------------
unit FindWeakestNearbyAllyTowers (int player, unit aiUnit, fixed maxDist, fixed maxHealthPercent, fixed minMissingHealth) {
    region r;
    unitgroup nearbyAllies;
    int allyCount;
    unit unitToCheck;
    fixed unitHealthPercent;
    unit resultUnit;
    fixed resultHealthPercent = maxHealthPercent;

    // find nearby allied towers
    r = RegionCircle(UnitGetPosition(aiUnit), maxDist);
    nearbyAllies = UnitGroupAlliance(player, c_unitAllianceAlly, r, null, c_noMaxCount);
    nearbyAllies = UnitGroupFilterTowers(nearbyAllies);

    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally towers in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies,allyCount);
        allyCount = allyCount - 1;

        unitHealthPercent = UnitGetPropertyFixed(unitToCheck, c_unitPropLifePercent, c_unitPropCurrent);

        if (unitHealthPercent < resultHealthPercent) {
            resultUnit = unitToCheck;
            resultHealthPercent = unitHealthPercent;
        }
    }

    return resultUnit;
}

//---------------------------------------------------------------------------------------------
unit FindClosestAllyMinion (int player, point center, fixed maxDist) {
    unitgroup nearbyAllies;
    unitgroup nearbyAllyMinions;
    int allyMinionCount;

    unit unitToCheck;
    point unitToCheckPosition;
    fixed unitToCheckDistance;

    unit resultUnit = null;
    fixed resultDistance = 999.0;

    nearbyAllies = AllyUnitsInArea(player, center, maxDist);
    nearbyAllyMinions = UnitGroupFilterMinions(nearbyAllies);
    allyMinionCount = UnitGroupCount(nearbyAllyMinions, c_unitCountAll);

    // check all the ally minions in the area
    while (allyMinionCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllyMinions, allyMinionCount);
        allyMinionCount = allyMinionCount - 1;

        unitToCheckPosition = UnitGetPosition(unitToCheck);
        unitToCheckDistance = DistanceBetweenPoints(center, unitToCheckPosition);

        if (unitToCheckDistance < resultDistance) {
            resultUnit = unitToCheck;
            resultDistance = unitToCheckDistance;
        }
    }

    return resultUnit;
}

//---------------------------------------------------------------------------------------------
int CountHeroesInGroup (unitgroup group) {
    return UnitGroupCount(UnitGroupFilterHeroes(group), c_unitCountAll);
}

//---------------------------------------------------------------------------------------------
int CountMinionsInGroup (unitgroup group) {
    return UnitGroupCount(UnitGroupFilterMinions(group), c_unitCountAll);
}

//---------------------------------------------------------------------------------------------
int CountCreepsInGroup (unitgroup group) {
    return UnitGroupCount(UnitGroupFilterAggroCreepsOrLanerCreeps(group), c_unitCountAll);
}

//---------------------------------------------------------------------------------------------
int CountHeroesInArea (unitgroup scanGroup, point center, fixed radius) {
    return UnitGroupCount(UnitsInArea(UnitGroupFilterHeroes(scanGroup), center, radius), c_unitCountAll);
}

//---------------------------------------------------------------------------------------------
bool AnyHeroesInArea (unitgroup scanGroup, point center, fixed radius) {
    return UnitGroupCount(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), RegionCircle(center, radius), 1), c_unitCountAll) > 0;
}

//---------------------------------------------------------------------------------------------
bool AnyEnemiesInArea (unitgroup scanGroup, point center, fixed radius) {
    region r = RegionCircle(center, radius);
    return (UnitGroupCount(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), r, 1), c_unitCountAll) > 0)
        || (UnitGroupCount(UnitGroupFilterRegion(UnitGroupFilterMinions(scanGroup), r, 1), c_unitCountAll) > 0)
        || (UnitGroupCount(UnitGroupFilterRegion(UnitGroupFilterAggroCreeps(scanGroup), r, 1), c_unitCountAll) > 0);
}

//---------------------------------------------------------------------------------------------
bool AnyAttackableUnitsInArea (unitgroup scanGroup, point center, fixed radius) {
    region r = RegionCircle(center, radius);
    return (UnitGroupCount(UnitGroupFilterRegion(UnitGroupFilterAttackable(scanGroup), r, 1), c_unitCountAll) > 0);
}

//---------------------------------------------------------------------------------------------
fixed EvalTargets (unitgroup targets) {
    int index;
    unit currentUnit;
    fixed score = 0.0;

    index = UnitGroupCount(targets, c_unitCountAll);
    while (index > 0) {
        currentUnit = UnitGroupUnit(targets, index);
        index -= 1;
        score += UnitGetPropertyFixed(currentUnit,  c_unitPropAIEvaluationFactor, c_unitPropCurrent);
    }
    return score;
}

//---------------------------------------------------------------------------------------------
// Returns true if the area has the required number of heroes, or the required number of minions,
// or a combination of the two, where the ratio of required minions to heroes is used to determine
// whether the number of minions plus heroes meets the threshold for the number of heroes.
// Note that units have an AIEvaluationFactor which may influence their worth.
bool EnoughEnemiesInArea (unitgroup scanGroup, point center, fixed radius, fixed minHeroes, fixed minAggroCreeps, fixed minMinions) {
    unitgroup enemies;
    fixed score = 0.0;

    enemies = UnitsInArea(scanGroup, center, radius);

    if (minHeroes != 0.0) {
        score += EvalTargets(UnitGroupFilterHeroes(enemies)) / minHeroes;
    }

    if (minAggroCreeps != 0.0) {
        score += UnitGroupCount(UnitGroupFilterAggroCreepsOrLanerCreeps(enemies), c_unitCountAll) / minAggroCreeps;
    }

    if (minMinions != 0.0) {
        score += UnitGroupCount(UnitGroupFilterMinions(enemies), c_unitCountAll) / minMinions;
    }
    // we account for precision loss so that 1/3 + 1/3 + 1/3 will return true
    return score >= 0.99;
}

//---------------------------------------------------------------------------------------------
// DEPRECATED - USE EnoughEnemiesInArea INSTEAD
int CountEnemiesInArea (unitgroup scanGroup, point center, fixed radius, int heroValue, int minionValue) {
    unitgroup enemies;
    int heroes;
    int minions;

    enemies = UnitsInArea(scanGroup, center, radius);
    heroes = CountHeroesInGroup(enemies);
    minions = CountMinionsInGroup(enemies);

    return heroValue * heroes + minionValue * minions;
}

//---------------------------------------------------------------------------------------------
int CountPlayersInUnitGroup (unitgroup group) {
    int index;
    int playerCount;
    int playerIndex;
    bool[libCore_gv_bALMaxPlayers + 1] playerSeen;

    playerCount = 0;
    index = UnitGroupCount(group, c_unitCountAll);

    for (; index > 0; index -= 1) {
        playerIndex = UnitGetOwner(UnitGroupUnit(group, index));

        // Filter out units not controlled by an active AI or human player
        if (playerIndex > libCore_gv_bALMaxPlayers) {
            continue;
        }

        // Update the count of unique players
        if (playerSeen[playerIndex] == false) {
            playerSeen[playerIndex] = true;
            playerCount += 1;
        }
    }

    return playerCount;
}

//---------------------------------------------------------------------------------------------
bool RequiredPlayerCountInUnitGroup (unitgroup group, int requiredPlayerCount) {
    int index;
    int playerCount;
    int playerIndex;
    bool[libCore_gv_bALMaxPlayers + 1] playerSeen;

    playerCount = 0;
    index = UnitGroupCount(group, c_unitCountAll);

    // If checking for absence of units, return true when nothing is found
    if (index == 0 && requiredPlayerCount == 0) {
        return true;
    }

    // Otherwise
    for (; index > 0; index -= 1) {
        playerIndex = UnitGetOwner(UnitGroupUnit(group, index));

        // Filter out units not controlled by an active AI or human player
        if (playerIndex > libCore_gv_bALMaxPlayers) {
            continue;
        }

        // Update the count of unique players
        if (playerSeen[playerIndex] == false) {
            playerCount += 1;
            if (playerCount >= requiredPlayerCount) {
                return true;
            }
            playerSeen[playerIndex] = true;
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
// When a positive integer is returned, it corresponds to how many heroes the player's enemy
// team outnumbers the player's team by.
// When a negative integer is returned, it corresponds to how many heroes the player's team
// outnumbers the enemy's team by.
int CountTeamOutnumberedBy (int player, unitgroup scanGroup, point center, fixed radius) {
    int enemyHeroCount;
    int allyHeroCount;

    enemyHeroCount = CountPlayersInUnitGroup(UnitGroupFilterHeroes(UnitsInArea(scanGroup, center, radius)));
    allyHeroCount = CountPlayersInUnitGroup(UnitGroupFilterHeroes(AllyUnitsInArea(player, center, radius)));

    return enemyHeroCount - allyHeroCount;
}

//---------------------------------------------------------------------------------------------
bool TeamFightInArea (int player, unitgroup scanGroup, point center, fixed radius) {
    region r = RegionCircle(center, radius);
    return RequiredPlayerCountInUnitGroup(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), r, c_noMaxCount), 2)
        && RequiredPlayerCountInUnitGroup(UnitGroupAlliance(player, c_unitAllianceAlly, r, c_Storm_AI_HeroFilter, c_noMaxCount), 2);
}

//-------------------------------------------------------------------------------------------------
bool ShouldLeavePassiveMount (int player, unit aiUnit, unitgroup scanGroup) {
    Storm_AI_TargetQueryOptions query;
    unit target;

    // If theres a teamfight beneath me, aggro creeps, or an enemy less than 5%
    if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 6.0)) {
        return true;
    }

    if (EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 6.0, 0, 1, 2)) {
        return true;
    }

    // Not low health, is there a low health enemy nearby?
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = 10;
    query.lv_maxHealthPercent = 5.0; // Super low on purpose
    query.lv_ignoreTargetsBehindGate = true;
    target = FindBestHero(scanGroup, aiUnit, query);

    if (target != null) {
        return true;
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool TeamFightInAllyAndEnemyAreas (int player, unitgroup scanGroup, point allyCenter, fixed allyRadius, point enemyCenter, fixed enemyRadius) {
    return RequiredPlayerCountInUnitGroup(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), RegionCircle(enemyCenter, enemyRadius), c_noMaxCount), 2)
        && RequiredPlayerCountInUnitGroup(UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(allyCenter, allyRadius), c_Storm_AI_HeroFilter, c_noMaxCount), 2);
}

//---------------------------------------------------------------------------------------------
bool TeamFightInAreaWithEnemyRadius(int player, unitgroup scanGroup, point center, fixed allyRadius, fixed enemyRadius) {
    return RequiredPlayerCountInUnitGroup(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), RegionCircle(center, enemyRadius), c_noMaxCount), 2)
        && RequiredPlayerCountInUnitGroup(UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, allyRadius), c_Storm_AI_HeroFilter, c_noMaxCount), 2);
}

//---------------------------------------------------------------------------------------------
bool RequiredEnemyPlayerCountInArea (int requiredPlayerCount, unitgroup scanGroup, point center, fixed radius) {
    return RequiredPlayerCountInUnitGroup(UnitGroupFilterRegion(UnitGroupFilterHeroes(scanGroup), RegionCircle(center, radius), c_noMaxCount), requiredPlayerCount);
}

//---------------------------------------------------------------------------------------------
bool RequiredAllyPlayerCountInArea (int requiredPlayerCount, int player, point center, fixed radius) {
    return RequiredPlayerCountInUnitGroup(UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(center, radius), c_Storm_AI_HeroFilter, c_noMaxCount), requiredPlayerCount);
}

//---------------------------------------------------------------------------------------------
unit FindUnitOfType (unitgroup scanGroup, int type) {
    int iterIndex;
    int targetUnitOwner;
    unit targetUnit;

    for (iterIndex = 1; iterIndex <= UnitGroupCount(scanGroup, c_unitCountAll); iterIndex += 1) {
        targetUnit = UnitGroupUnit(scanGroup, iterIndex);
        targetUnitOwner = UnitGetOwner(targetUnit);
        if (targetUnitOwner <= libCore_gv_bALMaxPlayers) {
            if (libGame_gv_players[targetUnitOwner].lv_heroData.lv_class == type) {
                return targetUnit;
            }
        }
    }
    return null;
}

//---------------------------------------------------------------------------------------------
bool TowardFarSideOfTheMap (int player, unit aiUnit) {
    point currentPos = UnitGetPosition(aiUnit);

    if (libCore_gf_TestLocationClosertoFactionSide(currentPos, libGame_gv_players[player].lv_faction, 0.8)) {
        return false;
    }
    return true;
}

//---------------------------------------------------------------------------------------------
bool UnitHasDebuffThatCanBeCleansed (unit unitToCheck) {
    int behaviourCount;
    int behaviorIndex;
    string behavior;
    int validatorCount;
    int validatorIndex;
    string validator;
    string scope;

    // Check for behaviors with Cleanse as a RemoveValidator
    behaviourCount = UnitBehaviorCountAll(unitToCheck);
    for ( behaviorIndex = 1 ; behaviorIndex <= behaviourCount ; behaviorIndex += 1 ) {
        behavior = UnitBehaviorGet(unitToCheck, behaviorIndex);
        scope = CatalogEntryScope(c_gameCatalogBehavior, behavior);
        if (CatalogFieldExists(scope, "RemoveValidatorArray")) {
            validatorCount = CatalogFieldValueCount(c_gameCatalogBehavior, behavior, "RemoveValidatorArray", c_playerAny);
            for ( validatorIndex = 1 ; validatorIndex <= validatorCount ; validatorIndex += 1) {
                validator = CatalogFieldValueGet(c_gameCatalogBehavior, behavior, "RemoveValidatorArray[" + IntToString((validatorIndex - 1)) + "]", c_playerAny);
                if (validator == "TargetCleanseDebuffRemoval") {
                    return true;
                }
            }
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
unit GetAllyToCleanse (int player, unit aiUnit) {
    unitgroup nearbyAllies;
    int allyCount;
    unit unitToCheck;

    nearbyAllies = AllyUnitsInArea(player, UnitGetPosition(aiUnit), 9.0);
    nearbyAllies = UnitGroupFilterHeroes(nearbyAllies);
    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    // check all the ally heroes in the area
    while (allyCount > 0) {
        unitToCheck = UnitGroupUnit(nearbyAllies, allyCount);
        allyCount = allyCount - 1;

        if ((unitToCheck != aiUnit) && UnitHasDebuffThatCanBeCleansed(unitToCheck)) {
            return unitToCheck;
        }
    }

    return null;
}

//---------------------------------------------------------------------------------------------
int GetAbilitiesOnCooldown (int player) {
    int abilitiesOnCooldown = 0;
    int abilityIndex = 0;

    while (abilityIndex < 3) {
        if (libCore_gf_IsAbilityOnCooldown(libGame_gv_players[player].lv_heroUnit, AbilityCommandGetAbility(libAIAI_gv_aIHeroes[player].lv_castAbility[abilityIndex]))) {
            abilitiesOnCooldown = abilitiesOnCooldown + 1;
        }

        abilityIndex = abilityIndex + 1;
    }

    return abilitiesOnCooldown;
}

//---------------------------------------------------------------------------------------------
const string c_AB_UseItem = "StormInventory";

//---------------------------------------------------------------------------------------------
bool UseItem (int player, unit aiUnit, unitgroup scanGroup, funcref<Storm_AI_CheckUseItem> callback) {
    order ord;
    order ordTarget;
    order ordTogOn;
    order ordTogOff;
    unit invItem;
    string itemType;
    int itemIdx = 1;

    if (UnitTestState(aiUnit, c_unitStateHallucination)) {
        return false;
    }

    ord = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemInstant);
    ordTarget = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemTarget);
    ordTogOn = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemTogOn);
    ordTogOff = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemTogOff);
    while (itemIdx <= libCore_gv_bALPlayerActiveInventorySlots) {
        invItem = UnitInventoryItem(aiUnit, itemIdx);
        itemIdx = itemIdx + 1;

        if (!UnitIsValid(invItem)) {
            continue;
        }

        OrderSetTargetItem(ord, invItem);
        OrderSetTargetItem(ordTarget, invItem);
        OrderSetTargetItem(ordTogOn, invItem);
        OrderSetTargetItem(ordTogOff, invItem);
        if (!UnitOrderIsValid(aiUnit, ord)
         && !UnitOrderIsValid(aiUnit, ordTarget)
         && !UnitOrderIsValid(aiUnit, ordTogOn)
         && !UnitOrderIsValid(aiUnit, ordTogOff)) {
            continue;
        }

        itemType = UnitGetType(invItem);
        if (callback(player, aiUnit, scanGroup, itemType, ord, ordTarget, ordTogOn, ordTogOff)) {
            return true;
        }
    }
    return false;
}
//---------------------------------------------------------------------------------------------
// Item Abilities Tactical
//---------------------------------------------------------------------------------------------

const string c_FlashOfTheStorms = "FlashoftheStorms";

bool ItemFlashOfTheStorms(int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    point pos;
        // Blink to target position
        if (!HaveBeenAttackedRecently(aiUnit) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            return false;
        }
        pos = libAIAI_gf_HeroAIGetRetreatPosition(UnitGetOwner(aiUnit), 9.0, null);
        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueReplace, null, pos);
}

//---------------------------------------------------------------------------------------------
bool DefensiveItemCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    int itemIdx = 1;
    int towerIdx = 0;
    int tryIdx = 0;
    int callbackIdx = 0;
    fixed curHealth;
    fixed targetHealth;
    point pos;
    unit target;
    int unitGroupIndex;
    fixed chargesUsed;
    unit currentUnit;
    Storm_AI_TargetQueryOptions query;

    if (itemType == "TalentFirstAid" || itemType == "BarbarianFerociousHealingItem" || itemType == "CrusaderLawsOfHopeItem") {
        // Self heal
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 60.0) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "TalentArcanePower") {
        // Self restore
        if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < 50.0) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "ZagaraRapidIncubationItem") {
        // Channel to regenrate health and energy
        // Do not channel if being attacked
        if (!HaveBeenAttackedRecently(aiUnit) && (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 70.0 || UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < 50.0)) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "ChoTalentMoltenBlock") {
        // This code is very similar to below, but I removed the required allies because Cho is often alone
        // I also increased the health at which he will use this ability to make it a bit more offensive.
        // I also allow there to only be one hero nearby because molten block pulses with damage, so it's worth it regardless (but more optimal with more).
        if (HaveBeenAttackedRecently(aiUnit)
         && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 35.0
         && AnyHeroesInArea(scanGroup, UnitGetPosition(aiUnit), 7.5)) {
            UnitIssueOrder(aiUnit, ordTogOn, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "TalentBucketIceBlock" || itemType == "ImprovedIceBlockUnit" || itemType == "RexxarFeignDeath") {
        // Become invulnerable if you become very low health during a team fight
        if (HaveBeenAttackedRecently(aiUnit)
         && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 20.0
         && TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 9.0)) {
            UnitIssueOrder(aiUnit, ordTogOn, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "TalentStoneskin" || itemType == "KaelthasArcaneBarrierItem" || itemType == "SonyaTalentNervesOfSteel" || itemType == "TalentHardenedShield") {
        // Place a temporary shield on self
        if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 70.0) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "SonyaTalentIgnorePain") {
        // Place a temporary shield on self
        if (HaveBeenAttackedRecently(aiUnit)
         && (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 85.0
          || RequiredEnemyPlayerCountInArea(2, scanGroup, UnitGetPosition(aiUnit), 7.0))) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "TalentBucketSprint" || itemType == "KerriganQueensRush") {
        // Temporarily increase movement speed
        if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }
    }
    else if (itemType == "TalentBerserk") {
        // Temporarily increase movement and attack speed
        // Use to flee faster
        if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }

        // Use in a team fight
        if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 9.0)) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }

        return false;
    }
    else if (itemType == "TalentImposingPresence") {

        // Use in a team fight
        if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 5.0)) {
            UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
            return true;
        }

        return false;
    }
    else if (itemType == "TalentBloodForBlood" || itemType == "AzmodanSinforSinItem") {
        // Steals percentage of enemy's life from their maximum health capacity
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > 60.0) {
            return false;
        }

        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 6.0;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_minScore = c_Storm_AI_FullHeroScore; // prefer full hero for maximum steal
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "KerriganEssenceForEssenceItem") {
        // Steals percentage of enemies life as shields
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth || !HaveBeenAttackedRecently(aiUnit)) {
            return false;
        }

        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 6.0;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_minScore = c_Storm_AI_FullHeroScore; // prefer full hero for maximum steal
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "TalentBucketCalldownMule") {
        // Calls down a MULE to repair an ally tower
        target = FindWeakestNearbyAllyTowers(player, aiUnit, 15.0, 70.0, -1.0);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "FlashoftheStorms") {
        // Blink to target position

        return ItemFlashOfTheStorms(player, aiUnit, scanGroup, itemType, ord, ordTarget, ordTogOn, ordTogOff);

    }
    else if (itemType == "TalentBucketHealingWard" || itemType == "ShamanHealingWard") {
        // Place a healing ward
        target = FindWeakestNearbyAllyHero(player, aiUnit, 7.0, 70.0, -1.0, false);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueReplace, null, UnitGetPosition(target));
    }
    else if (itemType == "AzmodanGluttonousWardItem") {
        // Place a ward that heals self and your summoned units
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroMediumHealthPercent || !HaveBeenAttackedRecently(aiUnit)) {
            return false;
        }

        if (!AnyHeroesInArea(scanGroup, UnitGetPosition(aiUnit), 7.0)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueReplace, null, UnitGetPosition(aiUnit));
    }
    else if (itemType == "TalentBucketStormShield") {
        // cast area sheild
        target = FindWeakestNearbyAllyHero(player, aiUnit, 7.5, 70.0, -1.0, false);
        if (!UnitIsValid(target) || !HaveBeenAttackedRecently(target)) {
            return false;
        }

        return UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
    }
    else if (itemType == "ProtectiveShield") {
        // Places a temporary shield on an ally
        // Find a weak ally under attack other than self
        target = FindWeakestNearbyAllyHero(player, aiUnit, 7.0, libAIAI_gv_aIHeroHighHealthPercent, -1.0, true);
        if (!UnitIsValid(target)) {
            return false;
        }

        // Don't bother if the ally is 'safe' (not being attacked and not critically low health)
        // Use the generic health threshold to teleport home because our target may not be AI, and using our own health threshold may not make sense for the other hero.
        if (!HaveBeenAttackedRecently(target) && UnitGetPropertyFixed(target, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroTeleportPercent[(libAIAI_gv_aIHeroes[player].lv_difficulty)]) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "TalentBucketCleanse") {
        target = GetAllyToCleanse(player, aiUnit);
        if (!UnitIsValid(target)) {
            return false;
        }
        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "MonkEpiphanyItem") {
        // don't use if we have plenty of energy and we have any dash charges left
        if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) > libAIAI_gv_aIHeroLowEnergyPercent) {
            chargesUsed = UnitGetChargeUsed(aiUnit, CatalogFieldValueGet(c_gameCatalogAbil, "MonkDash", "Cost[0].Charge.Link", c_playerAny));
            if (chargesUsed == 0.0) {
                return false;
            }
            if (CatalogFieldValueGetAsInt(c_gameCatalogAbil, "MonkDash", "Cost[0].Charge.CountMax", c_playerAny) > chargesUsed) {
                return false;
            }
        }
        return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
    }
    else if (itemType == "RexxarHardenedSkinItem") {
        // Use this if any hero unit for the player has been attacked and is low on health (rexxar or misha).
        for (unitGroupIndex = UnitGroupCount(libGame_gv_players[player].lv_heroUnitGroup, c_unitCountAll); unitGroupIndex > 0; unitGroupIndex = unitGroupIndex - 1) {
            currentUnit = UnitGroupUnit(libGame_gv_players[player].lv_heroUnitGroup, unitGroupIndex);
            if (HaveBeenAttackedRecently(currentUnit) && UnitGetPropertyFixed(currentUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
                return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
            }
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool UseDefensiveItem (int player, unit aiUnit, unitgroup scanGroup) {
    return UseItem(player, aiUnit, scanGroup, DefensiveItemCallback);
}

//---------------------------------------------------------------------------------------------
bool OffensiveItemCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    const fixed scoutDroneLaneDistance = 13.0;
    Storm_AI_TargetQueryOptions query;
    unit target;
    point pos;
    region r;
    int unitGroupIndex = 1;
    bool isInShrub = false;

    if (itemType == "TalentOverdrive" || itemType == "IcyVeins") {
        // Temporarily buff abilities if we are in a team fight
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
            return false;
        }

        if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < libAIAI_gv_aIHeroLowEnergyPercent) {
            return false;
        }

        if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 7.0)) {
            return false;
        }

        UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
        return true;
    }
    else if (itemType == "SearingAttacks" || itemType == "TyrandeSearingArrows") {
        // Temporarily buff auto-attacks if we are in a team fight
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
            return false;
        }

        if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 9.0)) {
            return false;
        }

        UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
        return true;
    }
    else if (itemType == "TalentRewind" || itemType == "ColdSnapUnit") {
        // Reduces the cooldown of the QWE abilities
        if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < 25.0) {
            return false;
        }

        // Don't use if not enough enemies around
        if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 8.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
            return false;
        }

        if (GetAbilitiesOnCooldown(player) < 2) {
            return false;
        }

        UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
        return true;
    }
    else if (itemType == "TalentBucketBribe" || itemType == "RaynorRaidersRecruitment" || itemType == "FaerieDragonPixieCharm") {
        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 6.0;
        query.lv_healthFactor = c_Storm_AI_PreferHealthyTargets;
        target = FindBestPassiveCampCreep(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "TalentBucketShrinkRay") {
        // Reduce an enemy heroes damage if we are in a team fight
        if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 7.0)) {
            return false;
        }

        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 6.5;
        query.lv_minScore = c_Storm_AI_FullHeroScore;
        query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "TalentBucketPromote" || itemType == "TalentInfestItem") {
        // Buff a ally minion
        target = FindClosestAllyMinion(UnitGetOwner(aiUnit), UnitGetPosition(aiUnit), 7.0);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "TalentBucketClairvoyance" || itemType == "RexxarFlare") {
        // NOTE: if this is changed to affect a much wider area, RexxarFlare should be separated out, because it only has a shortish range.
        // drops an area that reveals enemies
        // Use when we have been damaged a lot but there are no enemies in sight, and we are not near a tower
        pos = UnitGetPosition(aiUnit);
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth
            && CountEnemiesInArea(scanGroup, pos, 20.0, 1, 1) == 0
            && !UnitIsValid(GetNearbyTower(aiUnit, scanGroup))) {
            return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, null, pos);
        }

        // also check for decloaking nearby players
        target = libAIAI_gf_HeroAIGetCloakedEnemyToReveal(player);
        if (UnitIsAlive(target)) {
            if (HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, null, UnitGetPosition(target))) {
                libAIAI_gf_HeroAIResetRevealCloakedEnemyTimer(player);
                return true;
            }
        }

        // also check for enemy gates to reveal enemies behind
        target = FindClosestGate(scanGroup, aiUnit, 18.0); // within the range of RexxarFlare
        if (UnitIsAlive(target)) {
            return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, null, UnitGetPosition(target));
        }
    }
    else if (itemType == "ScoutingDroneItem" || itemType == "GallEyeOfKilroggItemUnit") {
        pos = UnitGetPosition(aiUnit);

        if (HaveBeenAttackedRecently(aiUnit)) {
            return false;
        }

        isInShrub = InShrub(pos);

        // If not in a shrub, calculate lane distance.
        if (!isInShrub) {
            libGame_gf_CalculateClosestLaneData(pos);
        }

        // Use is in shrub again to avoid going to the array.
        if (isInShrub
         || libGame_gv_closestLaneData.lv_laneData[libGame_gv_closestLaneData.lv_closestLane].lv_closestDist >= scoutDroneLaneDistance) {
            r = RegionCircle(pos, 15.0);
            // If we find an allied scouting drone, we exit early because we already have coverage.
            if (UnitGroupCount(UnitGroupFilterAlliance(UnitGroup("ScoutingDrone", c_playerAny, r, null, 0), player, c_unitAllianceAlly, 1), c_unitCountAll) > 0) {
                return false;
            }

            // If we find an allied scouting drone, we exit early because we already have coverage.
            if (UnitGroupCount(UnitGroupFilterAlliance(UnitGroup("GallEyeOfKilroggPlacedUnit", c_playerAny, r, null, 0), player, c_unitAllianceAlly, 1), c_unitCountAll) > 0) {
                return false;
            }
            return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, null, pos);
        }
    }
    else if (itemType == "AbathurLocustSwarm") {
        // Summons three locusts at target position
        pos = UnitGetPosition(aiUnit);

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, null, pos);
    }
    else if (itemType == "Envenom") {
        // Put a DoT on enemy hero
        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 5.0;
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_minScore = c_Storm_AI_FullHeroScore;
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }
    else if (itemType == "DiabloTalentLordOfTerror") {
        // Steal life from enemy hero
        ResetTargetQueryOptions(query);
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            query.lv_maxHealthPercent = 100.0;
        }
        else {
            query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
        }
        query.lv_maxDistance = 6.0;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_minScore = c_Storm_AI_FullHeroScore;
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
    }
    else if (itemType == "AzmodanSinsGraspItem") {
        ResetTargetQueryOptions(query);
        query.lv_maxDistance = 8.0;
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        target = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(target)) {
            return false;
        }
        return HeroIssueOrder(player, aiUnit, ordTarget, null, c_orderQueueAddToFront, target, null);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool UseOffensiveItem (int player, unit aiUnit, unitgroup scanGroup) {
    return UseItem(player, aiUnit, scanGroup, OffensiveItemCallback);
}

//---------------------------------------------------------------------------------------------
bool RevealCloakedEnemies (int player, unit aiUnit, unitgroup scanGroup) {
    if (UnitTestState(aiUnit, c_unitStateHallucination)) {
        return false;
    }
    else {
        return libAIAI_gf_HeroAIRandomlyCastAbilityOnCloakedEnemy(player);
    }
}

//---------------------------------------------------------------------------------------------
bool HeroSkipTactical (int player, unit aiUnit) {
    abilcmd currentAbility;

    // Check if this is a valid AI controlled hero. Only allowing this for players 1-10 so that
    // all tactical functions don't have to worry about checking for players 11 and 12.
    if (player <= 0 || player > libCore_gv_bALMaxPlayers || libAIAI_gf_HeroAIIsAIEnabledForPlayer(player) == false) {
        return true;
    }

    // Special Hero
    if (UnitTestState(aiUnit, c_unitStateHallucination)) {
        // Abathur coppied hero
        if (UnitHasBehavior(aiUnit, c_AbathurUltimateEvolutionControlBehavior)) {
            abathurUltimateEvolutionUnit[player - 1] = aiUnit;
            return false;
        }

        return true;
    }
    // Regular hero
    else {
        // No tactical if the AI in the triggers doesn't want us to
        if (player <= libCore_gv_bALMaxPlayers) {
            if (libAIAI_gf_HeroAIShouldSkipTactical(player) == true) {
                return true;
            }

            // Only ignore spell casting delay for Defensive spells when there is a human ally on the team
            if (libAIAI_gf_HeroAITeamHasHumanPlayers(libGame_gv_players[player].lv_faction) == false && libAIAI_gv_aIHeroes[player].lv_nextOffensiveSpellCheckTime > TimerGetElapsed(libGame_gv_gameTimer)) {
                return true;
            }
        }

        if ((UnitOrder(aiUnit, 0) != null)) {
            currentAbility = OrderGetAbilityCommand(UnitOrder(aiUnit, 0));

            // No tactical while hearthing
            if (currentAbility == AbilityCommand("PortBackToBase", 0)) {
                return true;
            }

            // No tactical while capturing a map mechanic
            if (currentAbility == AbilityCommand("CaptureMacGuffin", 0) || currentAbility == AbilityCommand("CaptureMacGuffinTwo", 0)) {
                return true;
            }

            // No tactical while capturing a map vehicle (e.g. Sylvanas couldn't enter because of a 3-second cooldown ability).
            if (currentAbility == AbilityCommand("UseVehicle", 0)) {
                return true;
            }
        }

        // No tactical driving vehicle
        if (UnitHasBehavior(aiUnit, "UsingVehicle") == true) {
            return true;
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool HeroSkipOffensiveTactical (int player, unit aiUnit) {
    // No tactical if we have already used a spell recently
    if (player > libCore_gv_bALMaxPlayers) {
        return false;
    }

    if (libAIAI_gv_aIHeroes[player].lv_nextOffensiveSpellCheckTime > TimerGetElapsed(libGame_gv_gameTimer)) {
        return true;
    }

    if ((UnitOrder(aiUnit, 0) != null)) {
        // No tactical while mounting
        if (OrderGetAbilityCommand(UnitOrder(aiUnit, 0)) == libAIAI_gv_aIHeroes[player].lv_mountAbility) {
            return true;
        }
    }

    // No tactical while mounted
    if (UnitHasBehavior(aiUnit, libAIAI_gv_aIHeroes[player].lv_mountBehavior) == true) {
        return true;
    }

    return false;
}

//---------------------------------------------------------------------------------------------
// This function will return the ratio of enemies to allies in the area, scaling up from 0.
// [0, 1) means allies are favored, 1 is even, (1, N] is Enemies are favored in a N to 1 advantage.
bool ShouldEnterTeamfight (int player, point position, unitgroup scanGroup, fixed minThreshold, fixed maxThreshold) {
    fixed enemyEvaluationFactor;
    fixed allyEvaluationFactor;
    fixed teamfightFactor;
    fixed fightRadius = 8.0;
    unitgroup nearbyEnemies;
    unitgroup nearbyAllies;
    int enemyHeroCount;
    int allyHeroCount;


    nearbyEnemies = UnitsInArea(scanGroup, position, fightRadius);
    enemyHeroCount = CountPlayersInUnitGroup(UnitGroupFilterHeroes(nearbyEnemies));
    // We count this as a small engagement, not teamfights
    if (enemyHeroCount < 3) {
        return false;
    }

    nearbyAllies = AllyUnitsInArea(player, position, fightRadius);
    allyHeroCount = CountPlayersInUnitGroup(UnitGroupFilterHeroes(nearbyAllies));
    if (allyHeroCount < 3) {
        return false;
    }

    // Tentatively include towers because we want to value teamfights under towers differently.
    enemyEvaluationFactor = libAIAI_gf_HeroAIEnemyEvalInCircle(player, position, fightRadius, true, false, false);
    allyEvaluationFactor = libAIAI_gf_HeroAIAllyEvalInCircle(player, position, fightRadius, true, false, false);

    if (allyEvaluationFactor == 0.0
        || enemyEvaluationFactor == 0.0) {
        return false;
    }

    teamfightFactor = enemyEvaluationFactor / allyEvaluationFactor;

    // Clamp it to our return values.
    return teamfightFactor >= minThreshold && teamfightFactor <= maxThreshold;
}

//---------------------------------------------------------------------------------------------
// Begin Hero Tactical
//---------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------
// Muradin Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_MuradinStormBolt     = "MuradinStormBolt";
const string c_AB_MuradinThunderClap   = "MuradinThunderclap";
const string c_AB_MuradinDwarfToss     = "MuradinDwarfToss";
const string c_AB_MuradinAvatar        = "MuradinAvatar";
const string c_AB_MuradinHaymaker      = "MuradinHaymaker";
const string c_AB_Stoneform            = "Stoneform";

//---------------------------------------------------------------------------------------------
bool MuradinStormBolt (int player, unit aiUnit, unitgroup scanGroup) {
    // Skill-shot that stuns & damages the target
    order spellOrd;
    order attackOrd;
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_MuradinStormBolt, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    if (energy < libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }

    // Use on a weak enemy hero
    query.lv_maxDistance = 6.5;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets; // so that we can finish a hero
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets; // so that we can land the skill-shot more easily
    query.lv_lineOfSightRequired = true;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // If we have nearly full energy, we're allowed to target minions
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        query.lv_lineOfSightRequired = false; // we don't really care if another enemy gets hit instead
        query.lv_maxHealthPercent = 100.0; // we don't really care if we hit a healthy unit
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool MuradinDwarfToss (int player, unit aiUnit, unitgroup scanGroup) {
    // Medium-Range Jump that damages enemies near the landing location

    // Two ways we might cast it:
    //      If we're in danger jump away to survive
    //      If there is a clump of enemies who are safe to attack, jump on top of them
    order spellOrd;
    point retreatPos;
    point center;

    spellOrd = StormHeroAICreateOrder(player, c_AB_MuradinDwarfToss, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Jump towards your spawn for safety if you are low health
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // Find position that is 6 units from current position towards the base
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 6.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Don't use offensively if we're near a tower or low health
    if (CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth)) {
        return false;
    }

    // Don't jump into a battle if you are not safe
    if (!libAIAI_gf_HeroAIIsSafe(player)) {
        return false;
    }

    // Find a cluster of enemies in range that is also large enough
    center = UnitGroupCenterOfGroup(scanGroup);
    if (center == null) {
        return false;
    }
    if (DistanceBetweenPoints(UnitGetPosition(aiUnit), center) > 5.0) {
        return false;
    }
    if (!EnoughEnemiesInArea(scanGroup, center, 2.0, c_Storm_AI_AtLeast1HighValueHero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        return false;
    }
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, center);
}

//---------------------------------------------------------------------------------------------
bool MuradinThunderClap (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE that damages & slows enemies. Moves with Muradin.
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    unit nearbyHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_MuradinThunderClap, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast if there is a weak hero
    query.lv_maxDistance = 2.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    nearbyHero = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(nearbyHero)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Cast if there are many enemies in the area
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions= c_Storm_AI_AtLeast3Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast1HighValueHero;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool MuradinAvatar (int player, unit aiUnit, unitgroup scanGroup) {
    // Gives Muradin addtional health for a period of time
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_MuradinAvatar, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // If our health is low and we've been damaged recently use Avatar to try to save us
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > 50.0) {
        return false;
    }

    if (!HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }

    // Only if there is a dangerous hero nearby
    if (!AnyHeroesInArea(scanGroup, UnitGetPosition(aiUnit), 12.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool MuradinHaymaker (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages and knocks back target enemy
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit targetHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_MuradinHaymaker, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use if there is a weak enemy nearby
    query.lv_maxDistance = 3.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // don't use on mini-heroes because this is an ultimate
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool Stoneform (int player, unit aiUnit, unitgroup scanGroup) {
    // Cast heal over time on self
    order spellOrd;
    unit targetHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_Stoneform, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > 50.0) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkMuradin (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (Stoneform(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && MuradinAvatar(player, aiUnit, scanGroup)) {
        return;
    }

    if (MuradinDwarfToss(player, aiUnit, scanGroup)) {
        return;
    }

    if (MuradinStormBolt(player, aiUnit, scanGroup)) {
        return;
    }

    if (MuradinThunderClap(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && MuradinHaymaker(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Stitches Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_StitchesHook              = "StitchesHook";
const string c_AB_StitchesSlam              = "StitchesSlam";
const string c_AB_StitchesDevour            = "StitchesDevour";
const string c_AB_StitchesPutridBile        = "StitchesPutridBile";
const string c_AB_StitchesGorge             = "StitchesGorge";

//---------------------------------------------------------------------------------------------
bool StitchesDevour (int player, unit aiUnit, unitgroup scanGroup) {
    // Single target spell that damages enemy and heals Stitches
    order spellOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_StitchesDevour, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use on a nearby enemy if low health to heal
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > 80.0) {
        return false;
    }

    query.lv_maxDistance = 5.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool StitchesHook (int player, unit aiUnit, unitgroup scanGroup) {
    // skill-shot that hooks the target to Stitches
    order spellOrd;
    order attackOrd;
    Storm_AI_TargetQueryOptions query;
    unit targetHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_StitchesHook, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // grab nearest enemy if they are low health
    query.lv_minDistance = 3.0;
    query.lv_maxDistance = 8.0;
    query.lv_maxHealthPercent = 60.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets; // better to hook the hero with less health
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to use hook on main heroes
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, UnitGetPosition(targetHero));
}

//---------------------------------------------------------------------------------------------
bool StitchesSlam (int player, unit aiUnit, unitgroup scanGroup) {
    // Cone damage spell in front of Stitches
    order spellOrd;
    unit targetHero;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    point inFrontofHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_StitchesSlam, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Set thresholds based on energy level
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast1Creep;
        minMinions = c_Storm_AI_AtLeast2Minions;
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroHighHealthPercent;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1HighValueHero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }

    // Cast on a weak enemy hero
    query.lv_maxDistance = 4.0;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(targetHero)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetHero));
    }

    // Cast on a group of enemies
    inFrontofHero = PointWithOffsetPolar(UnitGetPosition(aiUnit), 2.5, UnitGetFacing(aiUnit));
    if (!EnoughEnemiesInArea(scanGroup, inFrontofHero, 2.5, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, inFrontofHero);
}

//---------------------------------------------------------------------------------------------
bool StitchesPutridBile (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE that damages & slows enemies. Moves with Stitches.
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;

    spellOrd = StormHeroAICreateOrder(player, c_AB_StitchesPutridBile, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast to slow enemies chasing you while retreating
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Cast if there are many enemies around
    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1HighValueHero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool StitchesGorge (int player, unit aiUnit, unitgroup scanGroup) {
    // Eats an enemy and spits them out a few seconds later
    order spellOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_StitchesGorge, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Only use during a team fight
    if (!HaveBeenAttackedRecently(aiUnit) || !TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 7.0)) {
        return false;
    }

    // Eat the closest enemy hero
    query.lv_maxDistance = 4.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to eat a main hero
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkStitches (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (StitchesDevour(player, aiUnit, scanGroup)) {
        return;
    }

    if (StitchesHook(player, aiUnit, scanGroup)) {
        return;
    }

    if (StitchesSlam(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && StitchesPutridBile(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && StitchesGorge(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Nova Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_NovaSnipeStorm         = "NovaSnipeStorm";
const string c_AB_NovaPinningShot        = "NovaPinningShot";
const string c_AB_NovaHoloDecoy          = "NovaHoloDecoy";
const string c_AB_NovaTripleTap          = "NovaTripleTap";
const string c_AB_NovaPrecisionStrike    = "NovaPrecisionStrike";

//---------------------------------------------------------------------------------------------
bool NovaSnipeStorm (int player, unit aiUnit, unitgroup scanGroup) {
    // Skill-shot, high damage single target
    order spellOrd;
    unit targetEnemy;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaSnipeStorm, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = 100.0;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }

    // Shoot any nearby enemy if there is a clear shot
    query.lv_maxDistance = 10.0;
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets; // the high dmg will be more effective on unhealthy targets
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // Shoot a minion if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        //set the target query options for finding the best minion to shoot.
        query.lv_maxHealthPercent = 100.0;
        targetEnemy = FindBestMinion(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool NovaPinningShot (int player, unit aiUnit, unitgroup scanGroup) {
    // Damage and slow enemy target
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaPinningShot, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = 100.0;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }

    // Use if there is a weak enemy nearby and attack them
    query.lv_maxDistance = 8.0;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets; // the slow will be more effective on closer targets
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // Shoot a minion if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        // set the options for finding the best minion
        query.lv_distanceFactor = 0.0;
        query.lv_maxHealthPercent = 100.0;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        targetEnemy = FindBestMinion(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool NovaHoloDecoy (int player, unit aiUnit, unitgroup scanGroup) {
    // Creates a copy of Nova at nearby position to fool enemies
    order ord;

    ord = StormHeroAICreateOrder(player, c_AB_NovaHoloDecoy, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Use when low health to run away safely
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, UnitGetPosition(aiUnit));
}

//---------------------------------------------------------------------------------------------
bool NovaTripleTap (int player, unit aiUnit, unitgroup scanGroup) {
    // Shoots three shots at target enemy after a short delay
    order spellOrd;
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaTripleTap, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Use if there is a weak enemy nearby and attack them
    query.lv_maxDistance = 12.0;
    query.lv_maxHealthPercent = 60.0;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to use heroic ability on main heroes
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool NovaPrecisionStrike (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals aoe damage/slows enemies and has unlimited range
    order spellOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaPrecisionStrike, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_minDistance = 1.0;
    query.lv_maxDistance = 500.0;
    query.lv_maxHealthPercent = 70.0;
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to use heroic ability on main heroes
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    // Only cast if it will hit many enemies
    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetHero), 5.0, c_Storm_AI_AtLeast2Heroes, 0.0, 8.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkNova (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (NovaHoloDecoy(player, aiUnit, scanGroup)) {
        return;
    }

    if (NovaPinningShot(player, aiUnit, scanGroup)) {
        return;
    }

    if (NovaSnipeStorm(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && NovaTripleTap(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && NovaPrecisionStrike(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Nova HoloClone Tactical
//---------------------------------------------------------------------------------------------
const string c_HoloDecoyNoMastery1Disabler      = "HoloDecoyNoMastery1Disabler";

//---------------------------------------------------------------------------------------------
bool NovaHoloCloneSnipe (int player, unit aiUnit, unitgroup scanGroup) {
    // Skill-shot, high damage single target
    order spellOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaSnipeStorm, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (targetEnemy == null) {
        targetEnemy = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
    }
    if (targetEnemy == null) {
        return false;
    }

    OrderSetTargetPoint(spellOrd, UnitGetPosition(targetEnemy));
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    return true;
}

//---------------------------------------------------------------------------------------------
bool NovaHoloClonePinningShot (int player, unit aiUnit, unitgroup scanGroup) {
    // Damage and slow enemy target
    order spellOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_NovaPinningShot, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (targetEnemy == null) {
        targetEnemy = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
    }
    if (targetEnemy == null) {
        return false;
    }

    OrderSetTargetUnit(spellOrd, targetEnemy);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    return true;
}

//---------------------------------------------------------------------------------------------
void AIThinkNovaHoloClone (int player, unit aiUnit, unitgroup scanGroup) {
    // Only cast abilities if Nova has the HoloDecoy talent
    if (UnitHasBehavior(aiUnit, c_HoloDecoyNoMastery1Disabler) == true) {
        return;
    }

    if (NovaHoloCloneSnipe(player, aiUnit, scanGroup)) {
        return;
    }

    if (NovaHoloClonePinningShot(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Kerrigan Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_KerriganRavage                = "KerriganRavage";
const string c_AB_KerriganKerriganCrushingGrip  = "KerriganCrushingGrip";
const string c_AB_KerriganPrimalGrasp           = "KerriganPrimalGrasp";
const string c_AB_KerriganSummonUltralisk       = "KerriganSummonUltralisk";
const string c_AB_KerriganMaelstrom             = "KerriganMaelstrom";

//---------------------------------------------------------------------------------------------
bool KerriganRavage (int player, unit aiUnit, unitgroup scanGroup) {
    // Moves leaps to target dealing damage to it
    order spellOrd;
    order attackOrd;
    point retreatPos;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_KerriganRavage, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Don't jump into battle if have low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find a target hero
    query.lv_maxDistance = 4.5;
    query.lv_maxHealthPercent = 50.0;
    query.lv_ignoreTargetsBehindGate = true;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to tactically jump to a full hero
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool KerriganCrushingGrip (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages and stuns all enemies in target area
    order spellOrd;
    unit targetHero;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_KerriganKerriganCrushingGrip, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = 100.0;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }

    // Shoot any nearby hero
    query.lv_maxDistance = 6.0;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want a full hero as the center of the stun
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        // Shoot minions if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        targetPos = UnitGroupCenterOfGroup(scanGroup);
        if (!EnoughEnemiesInArea(scanGroup, targetPos, 2.0, c_Storm_AI_AtLeast2Heroes, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
            return false;
        }
    }
    else {
        targetPos = UnitGetPosition(targetHero);
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool KerriganPrimalGrasp (int player, unit aiUnit, unitgroup scanGroup) {
    // Pulls in all enemies in front of Kerrigan
    order spellOrd;
    order attackOrd;
    unit target;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    unitgroup nearbyEnemies;
    point center;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_KerriganPrimalGrasp, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Prefer casting on heroes
    query.lv_maxDistance = 5.0;
    query.lv_minDistance = 1.0; // don't use on heroes that are already in front of our face.
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    target = FindBestHero(scanGroup, aiUnit, query);
    if (target != null) {
        attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
        if (!UnitOrderIsValid(aiUnit, attackOrd)) {
            return false;
        }

        return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, null, UnitGetPosition(target));
    }

    // try again with any health hero, creep or minion
    query.lv_maxHealthPercent = 100.0;
    target = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (target == null) {
        return false;
    }

    // Cast if there is a large number of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast2Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1HighValueHero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast3Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    targetPos = UnitGetPosition(target);
    if (!EnoughEnemiesInArea(scanGroup, targetPos, 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool KerriganSummonUltralisk (int player, unit aiUnit, unitgroup scanGroup) {
    // Summons a ultralisk to attack the target
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_KerriganSummonUltralisk, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find a target hero
    query.lv_maxDistance = 9.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to cast heroic ability on main heroes.
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool KerriganMaelstrom (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE that damages enemies (also shields kerrigan 10+% of the damage done due to her trait). Moves with Kerrigan.

    // Two uses:
    //     If there are at least X nearby enemies
    //     Kerrigan is hurt and needs to try to live
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;

    spellOrd = StormHeroAICreateOrder(player, c_AB_KerriganMaelstrom, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // We're low health and under attack, cast this to hope to generate shields to try to live
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Find a target hero
    query.lv_maxDistance = 3.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to cast heroic ability on main heroes.
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    minCreeps = 0.0;

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1HighValueHero;
        minMinions = 0.0;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minMinions = 8.0;
    }

    // Only cast if there are many enemies in range
    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}


//---------------------------------------------------------------------------------------------
void AIThinkKerrigan (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && KerriganMaelstrom(player, aiUnit, scanGroup)) {
        return;
    }

    if (KerriganRavage(player, aiUnit, scanGroup)) {
        return;
    }

    if (KerriganPrimalGrasp(player, aiUnit, scanGroup)) {
        return;
    }

    if (KerriganCrushingGrip(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && KerriganSummonUltralisk(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Zeratul Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_ZeratulCleave             = "ZeratulCleave";
const string c_AB_ZeratulSingularitySpike   = "ZeratulSingularitySpike";
const string c_AB_ZeratulBlinkStorm         = "ZeratulBlinkStorm";
const string c_AB_ZeratulVoidPrison         = "ZeratulVoidPrison";
const string c_AB_ZeratulShadowAssault      = "ZeratulShadowAssault";

//---------------------------------------------------------------------------------------------
bool ZeratulCleave (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE cleave, damages nearby enemies
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    unit nearbyHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ZeratulCleave, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast if there is a weak hero
    query.lv_maxDistance = 3.0;
    query.lv_maxHealthPercent = 50.0;
    nearbyHero = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(nearbyHero)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Cast if there is a large number of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast3Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool ZeratulSingularitySpike (int player, unit aiUnit, unitgroup scanGroup) {
    // Skill-shot bomb that sticks to a target, after a delay it damages & slows the target
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ZeratulSingularitySpike, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = 100.0;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }

    query.lv_maxDistance = 8.0;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // Shoot a minion if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        // set the query options for targeting a minion
        query.lv_maxHealthPercent = 100.0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool ZeratulBlinkStorm (int player, unit aiUnit, unitgroup scanGroup) {
    // Teleports zeratul a short distance and cloaks him for a brief period

    // Two uses:
    //   Run away to live
    //   Catch a fleeing enemy hero
    unit targetEnemy;
    point retreatPos;
    order spellOrd;
    order attackOrd;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ZeratulBlinkStorm, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Retreat if you have low health
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // Blink back to retreat to safety
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 8.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Don't jump into battle if have low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find a target hero
    query.lv_minDistance = 2.0;
    query.lv_maxDistance = 8.0;
    query.lv_maxHealthPercent = 50.0;
    query.lv_ignoreTargetsBehindGate = true;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool ZeratulVoidPrison (int player, unit aiUnit, unitgroup scanGroup) {
    // creates a bubble that stuns all units inside, but also makes them invulnerable
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ZeratulVoidPrison, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // find a weak enemy who is getting away
    query.lv_minDistance = 2.0;
    query.lv_maxDistance = 5.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to cast heroic on a full hero.
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    if (HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null)) {
        HeroClaimForTactical(player, 0.25, false);
        return true;
    }
    return false;
}

//---------------------------------------------------------------------------------------------
bool ZeratulShadowAssault (int player, unit aiUnit, unitgroup scanGroup) {
    // Temporary cloak
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ZeratulShadowAssault, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use when low health to run away safely
    if (!HaveBeenAttackedRecently(aiUnit) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkZeratul (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (ZeratulBlinkStorm(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && ZeratulShadowAssault(player, aiUnit, scanGroup)) {
        return;
    }

    if (ZeratulCleave(player, aiUnit, scanGroup)) {
        return;
    }

    if (ZeratulSingularitySpike(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && ZeratulVoidPrison(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Sgt Hammer Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_SgtHammerSiegeMode            = "SgtHammerSiegeMode";
const string c_AB_SgtHammerTankMode             = "SgtHammerTankMode";
const string c_AB_SgtHammerConcussiveBlast      = "SgtHammerConcussiveBlast";
const string c_AB_SgtHammerMineField            = "SgtHammerMineField";
const string c_AB_SgtHammerNapalmStrike         = "SgtHammerNapalmStrike";
const string c_AB_SgtHammerBluntForceGun        = "SgtHammerBluntForceGun";
const string c_AB_SgtHammerThrusters            = "Thrusters";

//---------------------------------------------------------------------------------------------
bool SgtHammerThrusters (int player, unit aiUnit, unitgroup scanGroup) {
    // Increases movement speed
    // For now used only for fleeing
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SgtHammerThrusters, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Retreat if you have low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) >= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool SgtHammerSiegeMode (int player, unit aiUnit, unitgroup scanGroup) {
    // If Sgt Hammer is in tank mode, check if we should convert him to siege mode
    Storm_AI_TargetQueryOptions query;
    order spellOrd;
    order moveOrd;
    fixed range;
    fixed curHealth;
    unit tower;
    fixed dist;
    fixed directionAngle;
    point heroPos;
    point inFrontOfHero;
    point towerPos;
    int addToFront = c_orderQueueAddToFront;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SgtHammerSiegeMode, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // If we've been attacked recently then don't siege
    if (HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }

    // If low on health don't siege
    curHealth = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    if (curHealth < 50.0) {
        return false;
    }

    if (!libAIAI_gf_HeroAIIsSafe(player)) {
        return false;
    }

    heroPos = UnitGetPosition(aiUnit);
    range = libAIAI_gf_AIGetActiveWeaponRange(aiUnit) + 5.0;

    if (!EnoughEnemiesInArea(scanGroup, heroPos, range, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        // also check for creeps that are activated because we want to be able to siege during a camp attack.
        query.lv_maxDistance = range;
        if (!UnitIsValid(FindBestAggroCreep(scanGroup, aiUnit, query))) {
            // If not enough enemy around but near tower then still convert
            // The extra 5 range is used to find towers just outside of your siege range.
            query.lv_maxDistance = range + 5;
            query.lv_distanceFactor= c_Storm_AI_PreferCloserTargets;
            tower = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
            if (!UnitIsValid(tower)) {
                return false;
            }

            // Move away from tower towards max weapon range and then siege
            moveOrd = StormHeroAICreateOrder(player, c_Storm_AB_Move, 0);
            if (!UnitOrderIsValid(aiUnit, moveOrd)) {
                return false;
            }

            towerPos = UnitGetPosition(tower);
            dist = DistanceBetweenPoints(heroPos, towerPos) - range - 1.0;
            directionAngle = AngleBetweenPoints(heroPos, towerPos);
            inFrontOfHero = PointWithOffsetPolar(heroPos, dist, directionAngle);
            OrderSetTargetPoint(moveOrd, inFrontOfHero);
            if (!UnitOrderIsValid(aiUnit, moveOrd)) {
                return false;
            }
            UnitIssueOrder(aiUnit, moveOrd, c_orderQueueReplace);
            addToFront = c_orderQueueAddToEnd;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, addToFront, null, null);
 }

//---------------------------------------------------------------------------------------------
bool SgtHammerTankMode (int player, unit aiUnit, unitgroup scanGroup) {
    // If Sgt Hammer is in siege mode, check if we should convert him to tank mode
    order spellOrd;
    bool leaveSiege = false;
    fixed range;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SgtHammerTankMode, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // if we're trying to do something other than fighting, leave siege mode
    if (libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSFollowerGuardLeaderLeash) {
        leaveSiege = true;
    }
    // If we're low health, leave seige mode
    else if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < 45.0) {
        leaveSiege = true;
    }
    // If it's not safe anymore, leave seige mode
    else if (!libAIAI_gf_HeroAIIsSafe(player)) {
        leaveSiege = true;
    }
    else {
        range = libAIAI_gf_AIGetActiveWeaponRange(aiUnit);
        if (range < 8) {
            range = 8;
        }

        // Leave siege if there is nothing left to attack
        if (!AnyEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), range)) {
            if (UnitGroupCount(UnitsInArea(UnitGroupFilterTowers(scanGroup), UnitGetPosition(aiUnit), range), c_unitCountAll) == 0) {
                leaveSiege = true;
            }
        }
    }

    if (!leaveSiege) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
}

//---------------------------------------------------------------------------------------------
bool SgtHammerConcussiveBlast (int player, unit aiUnit, unitgroup scanGroup) {
    // pushes back all enemies in a cone and deals damage
    order ord;
    unit targetEnemy;
    fixed directionAngle;
    point heroPos;
    point inFrontOfHero;
    Storm_AI_TargetQueryOptions query;

    ord = StormHeroAICreateOrder(player, c_AB_SgtHammerConcussiveBlast, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Only push away units if they are attacking you
    if (!HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }

    // find a target enemy
    query.lv_maxDistance = 6.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    // check how many enemies are in that direction
    heroPos = UnitGetPosition(aiUnit);
    directionAngle = AngleBetweenPoints(heroPos, UnitGetPosition(targetEnemy));
    inFrontOfHero = PointWithOffsetPolar(heroPos, 3, directionAngle);

    if (!EnoughEnemiesInArea(scanGroup, inFrontOfHero, 3.5, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast4Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, inFrontOfHero);
 }

//---------------------------------------------------------------------------------------------
bool SgtHammerMineField (int player, unit aiUnit, unitgroup scanGroup) {
    // Drops mines at a nearby location
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unitgroup nearbyEnemies;
    unitgroup nearbyEnemyHeroes;
    unit targetEnemy;
    point center;
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SgtHammerMineField, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast on a weak enemy hero
    query.lv_maxDistance = 5.5;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(targetEnemy)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
    }

    // Center on heroes if any are nearby
    nearbyEnemies = UnitsInArea(scanGroup, UnitGetPosition(aiUnit), 5.5);
    nearbyEnemyHeroes = UnitGroupFilterHeroes(nearbyEnemies);

    if (UnitGroupCount(nearbyEnemyHeroes, c_unitCountAll) > 0) {
        center = UnitGroupCenterOfGroup(nearbyEnemyHeroes);
    }
    // Target minions instead
    else {
        query.lv_maxHealthPercent = 100.0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }

        center = UnitGetPosition(targetEnemy);
    }

    // Cast if there is a large number of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast2Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1HighValueHero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    if (!EnoughEnemiesInArea(scanGroup, center, 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, center);
 }

 //---------------------------------------------------------------------------------------------
bool SgtHammerNapalmStrike (int player, unit aiUnit, unitgroup scanGroup) {
    // Attack that damages all enemies in an area
    order ord;
    unitgroup largeScanGroup;
    unit targetEnemy;
    fixed range;
    Storm_AI_TargetQueryOptions query;

    ord = StormHeroAICreateOrder(player, c_AB_SgtHammerNapalmStrike, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    range = UnitAbilityEffectInstantGetRange(aiUnit, c_AB_SgtHammerNapalmStrike);

    // This skill's range is so large we have to scan a new larger scanGroup
    largeScanGroup = UnitGroupSearch(null, player, UnitGetPosition(aiUnit), range, UnitFilter((1 << c_targetFilterVisible) | (1 << c_targetFilterEnemy), 0, 0, 0), c_noMaxCount);

    // Find a target hero
    query.lv_maxDistance = range;
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to cast heroic on a full hero.
    targetEnemy = FindBestHero(largeScanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetEnemy), 3.0, c_Storm_AI_AtLeast1HighValueHero, 0.0, c_Storm_AI_AtLeast4Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
 }

//---------------------------------------------------------------------------------------------
bool SgtHammerBluntForceGun (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals damage to large area in front of hero
    Storm_AI_TargetQueryOptions query;
    unit targetEnemy;
    order spellOrd;
    point targetPosition;

    spellOrd = StormHeroAICreateOrder(player, c_AB_SgtHammerBluntForceGun, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // use in a teamfight
    if (CountHeroesInGroup(scanGroup) < 2 || CountHeroesInGroup(AllyUnitsInArea(player, UnitGetPosition(aiUnit), 16.0)) < 2) {
        return false;
    }

    // Find a target hero
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore; // only want to cast heroic on a full hero.
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    targetPosition = UnitGetPosition(targetEnemy);
    if (!EnoughEnemiesInArea(scanGroup, targetPosition, 4.0, c_Storm_AI_AtLeast2Heroes, 0.0, c_Storm_AI_AtLeast6Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPosition);
}

//---------------------------------------------------------------------------------------------
bool SgtHammerAttackUnitToDecloak(int player, unit aiUnit, unitgroup scanGroup) {
    // Attack a unit to decloak ourselves because when cloaked we do not acquire targets, and normal attack commands won't happen at long range
    order attackOrd;
    unit targetEnemy;
    unitgroup enemies;
    Storm_AI_TargetQueryOptions query;
    unitfilter filter = UnitFilter(0, 0, 0, (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32)) | (1 << (c_targetFilterPassive - 32)) | (1 << (c_targetFilterBenign - 32)));

    if (UnitTestState(aiUnit, c_unitStateCloaked)) {
        attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
        if (!UnitOrderIsValid(aiUnit, attackOrd)) {
            return false;
        }

        // We want to consider only those enemies that are not dead/hidden/invulnerable/passive/benign. This is because we want to include heroes, minions, summoned, towers, creeps
        // but not passive creeps and not destructible barrels (which are also passive).
        enemies = UnitGroupFilter(null, c_playerAny, scanGroup, filter, 0);
        query.lv_maxDistance = libAIAI_gf_AIGetActiveWeaponRange(aiUnit);
        targetEnemy = FindBestUnit(enemies, scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }

        OrderSetTargetUnit(attackOrd, targetEnemy);
        UnitIssueOrder(aiUnit, attackOrd, c_orderQueueReplace);
        return true;
    }
    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkSgtHammer (int player, unit aiUnit, unitgroup scanGroup) {
    if (libAIAI_gf_HeroAIIsAIEnabledForPlayer(player) == false) {
        return;
    }

    if (SgtHammerTankMode(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (SgtHammerThrusters(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (SgtHammerConcussiveBlast(player, aiUnit, scanGroup)) {
        return;
    }

    if (SgtHammerSiegeMode(player, aiUnit, scanGroup)) {
        return;
    }

    if (SgtHammerMineField(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && SgtHammerNapalmStrike(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && SgtHammerBluntForceGun(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (SgtHammerAttackUnitToDecloak(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Uther Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_UtherHolyLight                 = "UtherHolyLight";
const string c_AB_UtherHolyShock                 = "UtherHolyShock";
const string c_AB_UtherHolyRadiance              = "UtherHolyRadiance";
const string c_AB_UtherHammerOfJustice           = "UtherHammerOfJustice";
const string c_AB_UtherDivineIntervention        = "UtherDivineIntervention";
const string c_AB_UtherDivineStorm               = "UtherDivineStorm";
const string c_AB_UtherFlashofLight              = "UtherFlashofLight";

//---------------------------------------------------------------------------------------------
bool UtherHolyLight (int player, unit aiUnit, unitgroup scanGroup) {
    // Heals a single target
    order ord;
    unit targetUnit;
    fixed targetHealth;

    ord = StormHeroAICreateOrder(player, c_AB_UtherHolyLight, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Find weak nearby ally to heal
    targetUnit = FindBestHealTarget(player, aiUnit, 8.0, c_Storm_AI_OnlyEssentialHealing, false);
    if (!UnitIsValid(targetUnit)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null);
}

//---------------------------------------------------------------------------------------------
bool UtherHolyShock (int player, unit aiUnit, unitgroup scanGroup) {
    // Heals a single target, or deal damage to an enemy
    order ord;
    unit targetUnit;
    fixed targetHealth;
    Storm_AI_TargetQueryOptions query;

    ord = StormHeroAICreateOrder(player, c_AB_UtherHolyShock, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Find weak nearby ally to heal
    targetUnit = FindBestHealTarget(player, aiUnit, 8.0, c_Storm_AI_OnlyEssentialHealing, false);
    if (UnitIsValid(targetUnit)) {
        if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null)) {
            return true;
        }
    }

    // Cast on a weak enemy hero
    query.lv_maxDistance = 8.0;
    query.lv_maxHealthPercent = 20.0;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    targetUnit = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(targetUnit)) {
        return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool UtherDivineIntervention (int player, unit aiUnit, unitgroup scanGroup) {
    // Target becomes invulnerable and gains a movement buff, use to save friendly heros
    order ord;
    unit targetUnit;

    ord = StormHeroAICreateOrder(player, c_AB_UtherDivineIntervention, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Find weakest nearby ally hero
    targetUnit = FindWeakestNearbyAllyHero(player, aiUnit, 11.0, 30.0, -1.0, false);
    if (!UnitIsValid(targetUnit)) {
        return false;
    }

    // Don't use if he is already in safety
    if (!HaveBeenAttackedRecently(targetUnit)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null);
}

//---------------------------------------------------------------------------------------------
bool UtherHolyRadiance (int player, unit aiUnit, unitgroup scanGroup) {
    // line heal friend / damage enemies spell
    order ord;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    unit target;
    point targetPos;
    Storm_AI_TargetQueryOptions query;

    ord = StormHeroAICreateOrder(player, c_AB_UtherHolyRadiance, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    if (libAIAI_gv_aIHeroes[player].lv_difficulty <= libAIAI_ge_HeroAIDifficulty_HeroAITutorial1Ally) {
        healthReq = libAIAI_gv_aIHeroHighHealthPercent;
    }
    else {
        healthReq = libAIAI_gv_aIHeroMediumHealthPercent;
    }

    // Use to heal ally
    target = FindWeakestNearbyAllyHero(player, aiUnit, 7.0, healthReq, -1, true);
    if (UnitIsValid(target)) {
        return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, target, null);
    }

    if (HeroSkipOffensiveTactical(player, aiUnit) || libAIAI_gv_aIHeroes[player].lv_difficulty <= libAIAI_ge_HeroAIDifficulty_HeroAITutorial1Ally) {
        return false;
    }

    // Use to damage enemy
    query.lv_maxDistance = 7.0;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        // target any hero or creep or minion
        target = FindBestTacticalTarget(scanGroup, aiUnit, query);
    }
    else {
        // only target an unhealthy hero
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
        target = FindBestHero(scanGroup, aiUnit, query);
    }

    if (!UnitIsValid(target)) {
        return false;
    }

    targetPos = UnitGetPosition(target);

    // Only cast if it will hit multiple enemies
    if (!EnoughEnemiesInArea(scanGroup, targetPos, 2.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast2Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool UtherHammerOfJustice (int player, unit aiUnit, unitgroup scanGroup) {
    // Very short range stun + damage spell
    order spellOrd;
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_UtherHammerOfJustice, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    query.lv_maxDistance = 4.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool UtherDivineStorm (int player, unit aiUnit, unitgroup scanGroup) {
    // Player based AOE that deals damage and stuns nearby enemies

    // Two uses:
    //      When getting attacked while retreating
    //      When engaging a team fight
    order spellOrd;
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_UtherDivineStorm, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use if you are retreating
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!HaveBeenAttackedRecently(aiUnit) || TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 7.0)) {
        return false;
    }

    // Attack nearest hero after casting
    query.lv_maxDistance = 7.0;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    // Deliberately setting the attackOrd target here and passing in "null, null" for the target since divine storm itself has no target
    OrderSetTargetUnit(attackOrd, targetHero);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool UtherFlashofLight (int player, unit aiUnit, unitgroup scanGroup) {
    // Heals a single target
    order ord;
    unit targetUnit;
    fixed targetHealth;

    ord = StormHeroAICreateOrder(player, c_AB_UtherFlashofLight, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Find weak nearby ally to heal
    targetUnit = FindBestHealTarget(player, aiUnit, 7.0, c_Storm_AI_AllowAnyHealing, false);
    if (!UnitIsValid(targetUnit)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkUther (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && UtherDivineIntervention(player, aiUnit, scanGroup)) {
        return;
    }

    if (UtherHolyLight(player, aiUnit, scanGroup)) {
        return;
    }

    if (UtherHolyShock(player, aiUnit, scanGroup)) {
        return;
    }

    if (UtherHolyRadiance(player, aiUnit, scanGroup)) {
        // has logic to prevent unapproved offensive use
        return;
    }

    if (UtherFlashofLight(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (UtherHammerOfJustice(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && UtherDivineStorm(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Tassadar Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_TassadarPlasmaShield          = "TassadarPlasmaShield";
const string c_AB_TassadarPsionicStorm          = "TassadarPsionicStorm";
const string c_AB_TassadarPsionicStormPT        = "TassadarPsionicStormSecondStrike";
const string c_AB_TassadarDimensionalShift      = "TassadarDimensionalShift";
const string c_AB_TassadarArchon                = "TassadarArchon";
const string c_AB_TassadarForceWall             = "TassadarForceWall";
const string c_AB_TassadarOracle                = "TassadarOracle";

//---------------------------------------------------------------------------------------------
bool TassadarPlasmaShield (int player, unit aiUnit, unitgroup scanGroup) {
    // Shields a single target for 10-15 seconds
    order ord;
    fixed curHealth;
    unit targetUnit;
    fixed targetHealth;

    ord = StormHeroAICreateOrder(player, c_AB_TassadarPlasmaShield, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // If low health shield ourself first
    curHealth = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    if (HaveBeenAttackedRecently(aiUnit) && curHealth < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, aiUnit, null)) {
            return true;
        }
    }

    // Find weakest nearby ally hero
    targetUnit = FindWeakestNearbyAllyHero(player, aiUnit, 10.0, curHealth - 10.0, -1.0, false);

    if (UnitIsValid(targetUnit)) {
        targetHealth = UnitGetPropertyFixed(targetUnit, c_unitPropLifePercent, c_unitPropCurrent);
        if (HaveBeenAttackedRecently(targetUnit) && targetHealth < 70.0) {
            if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null)) {
                return true;
            }
        }
    }

    // Else shield ourself
    if (HaveBeenAttackedRecently(aiUnit) && curHealth < 70.0) {
        if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, aiUnit, null)) {
            return true;
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool TassadarDimensionalShift (int player, unit aiUnit, unitgroup scanGroup) {
    // Become invisible/invincible and gain movement speed
    order ord;
    fixed energy;
    fixed health;

    energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    health = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    ord = StormHeroAICreateOrder(player, c_AB_TassadarDimensionalShift, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }
    // don't use if we're not being attacked.
    if (!HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }
    // When high energy, use to end offensives
    if ((energy > libAIAI_gv_aIHeroMediumEnergyPercent) && (health < libAIAI_gv_aIHeroes[player].lv_endOffensiveHealth)) {
        return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
    }

    // Use when low health to run away safely
    if (health > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool TassadarPsiStormGeneric (order spellOrd, int player, unit aiUnit, unitgroup scanGroup) {
    // Use same logic for both the base skill and the relic varient
    unitgroup nearbyEnemies;
    unitgroup nearbyEnemyHeroes;
    unit target;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    Storm_AI_TargetQueryOptions query;

    // Cast on a weak enemy hero
    query.lv_maxDistance = 10.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    target = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(target)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(target));
    }

    // Cast on a group
    query.lv_minScore = 0;
    query.lv_maxHealthPercent = 100.0;
    target = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (!UnitIsValid(target)) {
        return false;
    }

    targetPos = UnitGetPosition(target);

    // Cast if there is a large number of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast3Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    // Only use on large group of enemies
    if (!EnoughEnemiesInArea(scanGroup, targetPos, 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TassadarPsionicStorm (int player, unit aiUnit, unitgroup scanGroup) {
    // Casts psi storm, damaging enemies in a small area.
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TassadarPsionicStorm , 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    return TassadarPsiStormGeneric(spellOrd, player, aiUnit, scanGroup);
}

//---------------------------------------------------------------------------------------------
bool TassadarPsionicStormSecondStrike (int player, unit aiUnit, unitgroup scanGroup) {
    // A second psistorm (on a different cooldown, due to level 16 SecondStrike talent).
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TassadarPsionicStormPT , 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    return TassadarPsiStormGeneric(spellOrd, player, aiUnit, scanGroup);
}

//---------------------------------------------------------------------------------------------
bool TassadarForceWall (int player, unit aiUnit, unitgroup scanGroup) {
    // Creates a "sentry" wall that can block an enemy hero from running away
    order spellOrd;
    order attackOrd;
    unit targetHero;
    point targetPos;
    fixed directionAngle;
    point targetPoint;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TassadarForceWall, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    query.lv_minDistance = 2.0;
    query.lv_maxDistance = 6.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    // Get a point on the other side of the enemy hero
    targetPos = UnitGetPosition(targetHero);
    directionAngle = AngleBetweenPoints(UnitGetPosition(aiUnit), targetPos);
    targetPoint = PointWithOffsetPolar(targetPos, 1.5, directionAngle);

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, targetPoint);
}

//---------------------------------------------------------------------------------------------
bool TassadarArchon (int player, unit aiUnit, unitgroup scanGroup) {
    // Gives tassadar a shield and buffs his attack damage
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TassadarArchon, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use if you are retreating
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 8.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool TassadarOracle (int player, unit aiUnit, unitgroup scanGroup) {
    // Increases vision radius and enemy hero detection temporarily
    order spellOrd;
    unit target;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TassadarOracle, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use for decloaking nearby enemies
    target = libAIAI_gf_HeroAIGetCloakedEnemyToReveal(player);
    if (UnitIsAlive(target)) {
        libAIAI_gf_HeroAIResetRevealCloakedEnemyTimer(player);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // No use case beyond this point if we are inside our base
    if (libAIAI_gf_HeroAIIsPlayerInsideBase(player)) {
        return false;
    }

    // Use spell for the below cases only if we have energy to spare and we are not mounted
    if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < libAIAI_gv_aIHeroLowEnergyPercent
     || UnitHasBehavior(aiUnit, libAIAI_gv_aIHeroes[player].lv_mountBehavior)) {
        return false;
    }

    // Use when there are no enemies and ally minions in sight and we are not near a tower
    if (!AnyEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 20.0)
     && !AnyAllyMinionUnitsInArea(player, UnitGetPosition(aiUnit), 7.0)
     && !UnitIsValid(GetNearbyTower(aiUnit, scanGroup))) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Use to reveal enemies behind enemy gates
    target = FindClosestGate(scanGroup, aiUnit, 20.0);
    if (!UnitIsAlive(target)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkTassadar (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (TassadarDimensionalShift(player, aiUnit, scanGroup)) {
        return;
    }

    if (TassadarPlasmaShield(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (TassadarOracle(player, aiUnit, scanGroup)) {
        // Don't want to count the usable trait as a used up ability for lower difficulty AI with
        // casting limitations, so we are not returning out.
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TassadarArchon(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TassadarForceWall(player, aiUnit, scanGroup)) {
        return;
    }

    if (TassadarPsionicStormSecondStrike(player, aiUnit, scanGroup)) {
        return;
    }

    if (TassadarPsionicStorm(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Arthas Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_ArthasDeathAndDecay           = "ArthasFrozenTempest";
const string c_AB_ArthasDeathAndDecayCancel     = "ArthasFrozenTempestCancel";
const string c_AB_ArthasArmyOfTheDead           = "ArthasArmyOfTheDead";
const string c_AB_ArthasArmyOfTheDeadSacrifice  = "ArthasArmyOfTheDeadSacrifice";
const string c_AB_ArthasSummonSindragosa        = "ArthasSummonSindragosa";
const string c_AB_ArthasHowlingBlast            = "ArthasHowlingBlast";
const string c_AB_ArthasDeathCoil               = "ArthasDeathCoil";
const string c_AB_ArthasFrostmourneHungers      = "ArthasFrostmourneHungers";

//---------------------------------------------------------------------------------------------
bool ArthasArmyOfTheDead (int player, unit aiUnit, unitgroup scanGroup) {
    // Summons a ghoul to help arthas fight
    order ord;
    fixed health = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    fixed enemyCnt;
    point center;
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;

    ord = StormHeroAICreateOrder(player, c_AB_ArthasArmyOfTheDead, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Cast if low on health, as it can be used to heal self
    if (health > libAIAI_gv_aIHeroMediumHealthPercent) {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast1Creep;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast1HighValueHero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }

    center = UnitGroupCenterOfGroup(scanGroup);
    if (!EnoughEnemiesInArea(scanGroup, center, 4.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool ArthasArmyOfTheDeadSacrifice (int player, unit aiUnit, unitgroup scanGroup) {
    // Sacrifice the ghoul for a little bit of health
    order ord;

    ord = StormHeroAICreateOrder(player, c_AB_ArthasArmyOfTheDeadSacrifice, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // If we're above 50% health don't sack it yet
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > 50.0) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool ArthasDeathCoil (int player, unit aiUnit, unitgroup scanGroup) {
    // Targetted shot that either heals self or damages target
    order spellOrd;
    order attackOrd;
    fixed health = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ArthasDeathCoil, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // If low health, heal self
    if (health < libAIAI_gv_aIHeroMediumHealthPercent) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, aiUnit, null);
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find weakest hero based on energy left. Can spam ability if energy percent is high
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        query.lv_maxHealthPercent = 80.0;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }

    query.lv_minDistance = 1.0;
    query.lv_maxDistance = 7.0;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueReplace, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool ArthasHowlingBlast (int player, unit aiUnit, unitgroup scanGroup) {
    // Short range snare + minor damage, use it to catch fleeing heros
    order spellOrd;
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ArthasHowlingBlast, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    query.lv_minDistance = 1.0;
    query.lv_maxDistance = 7.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueReplace, targetHero, UnitGetPosition(targetHero));
}

//---------------------------------------------------------------------------------------------
bool ArthasDeathAndDecay (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE that damages and slows nearby enemies. Moves with Arthas.
    order ord;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;

    ord = StormHeroAICreateOrder(player, c_AB_ArthasDeathAndDecay, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast3Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1HighValueHero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    // If there are not enough enemy units around the hero, do not cast
    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 4.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool ArthasDeathAndDecayCancel(int player, unit aiUnit, unitgroup scanGroup) {
    order ord;

    ord = StormHeroAICreateOrder(player, c_AB_ArthasDeathAndDecayCancel, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Do not cancel if there are units around to damage
    if (AnyEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 4.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool ArthasSummonSindragosa (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals damage to large area in front of hero, slowing enemy heroes and
    // disabling any minions and structures caught within the area
    order spellOrd;
    unit target;
    point targetPos;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ArthasSummonSindragosa, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    target = FindBestHero(scanGroup, aiUnit, query);

    if (target == null) {
        return false;
    }
    targetPos = UnitGetPosition(target);

    if (!EnoughEnemiesInArea(scanGroup, targetPos, 6.0, c_Storm_AI_AtLeast2Heroes, 0.0, c_Storm_AI_AtLeast6Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool ArthasFrostmourneHungers (int player, unit aiUnit, unitgroup scanGroup) {
    // Increase damage of next attack and restore mana
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ArthasFrostmourneHungers, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // After activating ability attack a weak target
    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    query.lv_maxDistance = 5.0;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (targetEnemy == null) {
        return false;
    }

    // Add Attack order to queue
    OrderSetTargetUnit(attackOrd, targetEnemy);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }
    UnitIssueOrder(aiUnit, attackOrd, c_orderQueueReplace);

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkArthas (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

     if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && ArthasArmyOfTheDeadSacrifice(player, aiUnit, scanGroup)) {
        return;
    }

    if (ArthasDeathAndDecayCancel(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (ArthasDeathCoil(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && ArthasArmyOfTheDead(player, aiUnit, scanGroup)) {
        return;
    }

    if (ArthasDeathAndDecay(player, aiUnit, scanGroup)) {
        return;
    }

    if (ArthasHowlingBlast(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && ArthasSummonSindragosa(player, aiUnit, scanGroup)) {
        return;
    }

    if (ArthasFrostmourneHungers(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Tinker Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_TinkerRockItTurrett       = "TinkerRockItTurret";
const string c_AB_TinkerDethLazorCharged    = "TinkerDethLazorCharged";
const string c_AB_TinkerDethLazorCancel     = "DethLazorCancel";
const string c_AB_TinkerXplodiumBomb        = "TinkerXplodiumBomb";
const string c_AB_TinkerGravOBomb3000       = "TinkerGravOBomb3000";
const string c_AB_TinkerDismantleTurret     = "TinkerDismantleTurret";
const string c_DethLazorActiveBehavior      = "DethLazorActive";

//---------------------------------------------------------------------------------------------
bool TinkerDethLazorCharged (int player, unit aiUnit, unitgroup scanGroup) {
    // Shoots a lazer that damages everything in its path. The longer it is charged the larger the AOE.
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    Storm_AI_TargetQueryOptions query;
    unit target;
    point targetPos;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TinkerDethLazorCharged, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Do not cast this channeling ability if the enemy heroes around you outnumber you and your
    // allies by 2 or more heroes.
    if (CountTeamOutnumberedBy(player, scanGroup, UnitGetPosition(aiUnit), 10.0) > 1) {
        return false;
    }

    // Cast if there is a large number of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast1Creep;
        minMinions = c_Storm_AI_AtLeast2Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    query.lv_maxDistance = 10.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    target = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (target == null) {
        return false;
    }

    targetPos = UnitGetPosition(target);
    if (!EnoughEnemiesInArea(scanGroup, targetPos, 3.0, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    if (HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, targetPos)) {
        HeroClaimForTactical(player, 1.25, false);
        return true;
    }
    return false;
}

//--------------------------------------------------------------------------------------------------
void AIChannelDethLazor (int player, unit aiUnit, unitgroup scanGroup) {
    order cancelOrd;
    bool cancel = false;
    order turnOrd;
    Storm_AI_TargetQueryOptions query;
    unit target;
    point targetPos;


    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        // Stop chanelling if in danger
        cancel = true;
    }
    else if (CountTeamOutnumberedBy(player, scanGroup, UnitGetPosition(aiUnit), 10.0) > 1) {
        // Stop channelling if the enemy heroes around you outnumber you and your allies by 2 or more heroes.
        cancel = true;
    }
    else {
        // Stop if the targets are leaving the area
        query.lv_maxDistance = 10.0;
        query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        target = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (target == null) {
            cancel = true;
        }
        else {
            targetPos = UnitGetPosition(target);
            cancel = !EnoughEnemiesInArea(scanGroup, targetPos, 3.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast3Minions);
        }
    }

    if (cancel) {
        cancelOrd = StormHeroAICreateOrder(player, c_AB_TinkerDethLazorCancel, 0);
        if (UnitOrderIsValid(aiUnit, cancelOrd)) {
            HeroClaimForTactical(player, 0.0, false);

            // Don't use HeroIssueOrder for channeling
            UnitIssueOrder(aiUnit, cancelOrd, c_orderQueueReplace);
            return;
        }
    }

    turnOrd = StormHeroAICreateOrder(player, c_Storm_AB_Move, 4);
    if (!UnitOrderIsValid(aiUnit, turnOrd)) {
        return;
    }

    HeroClaimForTactical(player, 1.25, false);

    OrderSetTargetPoint(turnOrd, targetPos);
    if (!UnitOrderIsValid(aiUnit, turnOrd)) {
        return;
    }

    // Don't use HeroIssueOrder for channeling
    UnitIssueOrder(aiUnit, turnOrd, c_orderQueueReplace);
}

//---------------------------------------------------------------------------------------------
bool TinkerRockItTurret (int player, unit aiUnit, unitgroup scanGroup) {
    // Creates a turret that attacks enemies
    order ord;
    unit nearbyTower;

    ord = StormHeroAICreateOrder(player, c_AB_TinkerRockItTurrett, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Don't be too offensive if we're near a tower (tower will just kill it)
    nearbyTower = GetNearbyTower(aiUnit, scanGroup);
    if (UnitIsValid(nearbyTower)) {
        return false;
    }

    // Always cast this if we have energy and there are enemies nearby
    if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < libAIAI_gv_aIHeroLowEnergyPercent) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 7.0, c_Storm_AI_AtLeast2Heroes, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast2Minions)) {
        return false;
    }

    // Deliberately setting the ord point here and passing in "null, null" since we don't want to fudge this position
    OrderSetTargetPoint(ord,UnitGetPosition(aiUnit));
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool TinkerXplodiumBomb (int player, unit aiUnit, unitgroup scanGroup) {
    // Places a bomb that damages and stuns nearby enemies
    order spellOrd;
    unit target;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TinkerXplodiumBomb, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = 6.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        // any enemy
        target = FindBestTacticalTarget(scanGroup, aiUnit, query);
    }
    else {
        // only a wounded hero
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
        target = FindBestHero(scanGroup, aiUnit, query);
    }

    // Shoot at a nearby hero
    if (target == null) {
        return false;
    }

    targetPos = UnitGetPosition(target);

    if (!EnoughEnemiesInArea(scanGroup, targetPos, 3.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TinkerGravOBomb3000 (int player, unit aiUnit, unitgroup scanGroup) {
    // Place bomb that after a delay sucks in all nearby units and detonates, leaving units stunned
    order spellOrd;
    unit targetHero;
    point targetPos;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TinkerGravOBomb3000, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_minDistance = 1.0;
    query.lv_maxDistance = 7.0;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    // Only cast if there are other nearby enemies for it to hit also
    targetPos = UnitGetPosition(targetHero);
    if (RequiredEnemyPlayerCountInArea(2, scanGroup, targetPos, 3.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TinkerDismantleTurret (int player, unit aiUnit, unitgroup scanGroup) {
    // Dismantles a Rock-It turret for mana and faster ability cd.
    order ord;
    point unitPosition;
    int index;
    int count;
    unitgroup turrets;
    unit turret;
    unit bestTurret;
    fixed turretDistanceSquared;
    fixed bestDistanceSquared;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    // only do this if we could use the energy
    if (energy > libAIAI_gv_aIHeroMediumEnergyPercent) {
        return false;
    }

    ord = StormHeroAICreateOrder(player, c_AB_TinkerDismantleTurret, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // we shouldn't destroy it if we see any enemies nearby
    unitPosition = UnitGetPosition(aiUnit);
    if (AnyEnemiesInArea(scanGroup, unitPosition, 10.0)) {
        return false;
    }

    // find our closest turret
    turrets = UnitGroupSearch("TinkerRockItTurret", player, unitPosition, 9.0, null, 0);
    bestDistanceSquared = 999.0;
    count = UnitGroupCount(turrets, c_unitCountAll);
    for (index = 1; index <= count; index += 1) {
        turret = UnitGroupUnit(turrets, index);
        if (!UnitIsAlive(turret)) {
            continue;
        }
        turretDistanceSquared = DistanceSquaredBetweenPoints(unitPosition, UnitGetPosition(turret));
        if (turretDistanceSquared > bestDistanceSquared) {
            continue;
        }
        bestTurret = turret;
        bestDistanceSquared = turretDistanceSquared;
    }

    // we need a turret to continue.
    if (bestTurret == null) {
        return false;
    }

    // we shouldn't destroy it if the turret has any enemies nearby
    if (AnyEnemiesInArea(scanGroup, UnitGetPosition(bestTurret), 10.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueReplace, bestTurret, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkTinker (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UnitHasBehavior(aiUnit, c_DethLazorActiveBehavior) == true) {
        AIChannelDethLazor(player, aiUnit, scanGroup);
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (TinkerRockItTurret(player, aiUnit, scanGroup)) {
        return;
    }

    if (TinkerXplodiumBomb(player, aiUnit, scanGroup)) {
        return;
    }

    if (TinkerDethLazorCharged(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TinkerGravOBomb3000(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (TinkerDismantleTurret(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Witch Doctor Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_WitchDoctorCorpseSpiders      = "WitchDoctorCorpseSpiders";
const string c_AB_WitchDoctorZombieWall       = "WitchDoctorZombieWall";
const string c_AB_WitchDoctorPlagueofToads    = "WitchDoctorPlagueofToads";
const string c_AB_WitchDoctorGargantuan         = "WitchDoctorGargantuan";
const string c_AB_WitchDoctorGargantuanStomp    = "WitchDoctorGargantuanStompCommand";
const string c_AB_WitchDoctorRavenousSpirit     = "WitchDoctorRavenousSpirit";
const string c_AB_WitchDoctorRavenousSpiritCancel = "WitchDoctorRavenousSpiritCancel";
const fixed c_WitchDoctorVisionRadius = 12.0;

//---------------------------------------------------------------------------------------------
bool WitchDoctorCorpseSpiders (int player, unit aiUnit, unitgroup scanGroup) {
    // Spawns spiders at the target location that attack nearby enemies
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_WitchDoctorCorpseSpiders, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = 100.0;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }

    // Find target hero
    query.lv_maxDistance = 8.0;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // Shoot a minion if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        query.lv_maxHealthPercent = 100.0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool WitchDoctorZombieWall (int player, unit aiUnit, unitgroup scanGroup) {
    // Surround the target with a circular wall of zombies
    order spellOrd;
    order attackOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_WitchDoctorZombieWall, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Trap an weak enemy hero
    query.lv_minDistance = 3.0;
    query.lv_maxDistance = 8.0;
    query.lv_maxHealthPercent = 50.0;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // Otherwise attack a large group of enemies
        query.lv_maxHealthPercent = 100.0;
        query.lv_minScore = 0.0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }

        if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
            minHeroes = c_Storm_AI_AtLeast1Hero;
            minCreeps = c_Storm_AI_AtLeast1Creep;
            minMinions = c_Storm_AI_AtLeast2Minions;
        }
        else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
            minHeroes = c_Storm_AI_AtLeast2Heroes;
            minCreeps = c_Storm_AI_AtLeast2Creeps;
            minMinions = c_Storm_AI_AtLeast4Minions;
        }
        else {
            minHeroes = c_Storm_AI_AtLeast2Heroes;
            minCreeps = c_Storm_AI_AtLeast3Creeps;
            minMinions = c_Storm_AI_AtLeast6Minions;
        }

        if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetEnemy), 4.5, minHeroes, minCreeps, minMinions)) {
            return false;
        }
    }

    // If low health just cast the prison, but don't turn to attack
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool WitchDoctorPlagueofToads (int player, unit aiUnit, unitgroup scanGroup) {
    // Waves of damaging toads from the witch doctor toward the target point
    order ord;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    unit targetEnemy;
    fixed directionAngle;
    point heroPos;
    point inFrontOfHero;
    Storm_AI_TargetQueryOptions query;

    ord = StormHeroAICreateOrder(player, c_AB_WitchDoctorPlagueofToads, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

     // Find a target enemy
    query.lv_maxDistance = 7.0;
    query.lv_maxHealthPercent = 100.0;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    // Don't cast if there are not many units in front of hero
    heroPos = UnitGetPosition(aiUnit);
    directionAngle = AngleBetweenPoints(heroPos, UnitGetPosition(targetEnemy));
    inFrontOfHero = PointWithOffsetPolar(heroPos, 3.5, directionAngle);

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast1Creep;
        minMinions = c_Storm_AI_AtLeast2Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    if (!EnoughEnemiesInArea(scanGroup, inFrontOfHero, 3.5, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, inFrontOfHero);
}

//---------------------------------------------------------------------------------------------
bool WitchDoctorGargantuan (int player, unit aiUnit, unitgroup scanGroup) {
    // Summons gargantuan at target location
    order spellOrd;
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_WitchDoctorGargantuan, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    query.lv_maxDistance = 8.0;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetHero));
}


//---------------------------------------------------------------------------------------------
bool WitchDoctorGargantuanStompCommand (int player, unit aiUnit, unitgroup scanGroup) {
    // Orders the gargantuan to attack a target
    // Removed all targeting logic for H.20 - will update in H.21
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_WitchDoctorGargantuanStomp, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool WitchDoctorRavenousSpirit (int player, unit aiUnit, unitgroup scanGroup) {
    // Summons an AOE that you can move around while channeling
    order ord;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    ord = StormHeroAICreateOrder(player, c_AB_WitchDoctorRavenousSpirit, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Don't cast if we're under attack
    if (HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }

    // Don't be offensive if we're too low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    // Do not cast this channeling ability if the enemy heroes around us outnumber our
    // allies by 2 or more heroes.
    if (CountTeamOutnumberedBy(player, scanGroup, UnitGetPosition(aiUnit), c_WitchDoctorVisionRadius) > 1) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }

    // Find a target that is a bit away, so you wont get attacked while channeling
    query.lv_minDistance = 2.0;
    query.lv_maxDistance = 10.0;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets; //easier to chase
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueReplace, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool WitchDoctorRavenousSpiritCancel (int player, unit aiUnit, unitgroup scanGroup) {
    bool stopChannel;
    order cancelOrd;

    // If WitchDoctor is getting attacked, cancel channeling
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        stopChannel = true;
    }
    else {
        // Stop channelling if the enemy heroes around us outnumber our
        // allies by 2 or more heroes.
        if (CountTeamOutnumberedBy(player, scanGroup, UnitGetPosition(aiUnit), c_WitchDoctorVisionRadius) > 1) {
            stopChannel = true;
        }
    }

    if (stopChannel) {
        cancelOrd = StormHeroAICreateOrder(player, c_AB_WitchDoctorRavenousSpiritCancel, 0);
        if (UnitOrderIsValid(aiUnit, cancelOrd)) {
            HeroClaimForTactical(player, 0.0, false);

            // Don't use HeroIssueOrder for channeling
            return UnitIssueOrder(aiUnit, cancelOrd, c_orderQueueReplace);
        }
    }
    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkWitchDoctor (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    // offensive items are placed before any other abilties because all of the other abilities have low cooldowns, and
    // low difficulty AI doesn't run tactical often and so would always use abilities rather than consider offensive items.
    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (WitchDoctorCorpseSpiders(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && WitchDoctorGargantuan(player, aiUnit, scanGroup)) {
        return;
    }

    if (WitchDoctorPlagueofToads(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && WitchDoctorRavenousSpirit(player, aiUnit, scanGroup)) {
        return;
    }

    if (WitchDoctorZombieWall(player, aiUnit, scanGroup)) {
        return;
    }

    if (WitchDoctorGargantuanStompCommand(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// WitchDoctorRavenousSpirit Tactical
//---------------------------------------------------------------------------------------------

void AIThinkWitchDoctorRavenousSpirit (int player, unit aiUnit, unitgroup scanGroup) {
    unit targetEnemy;
    int witchDoctorPlayer;
    unitgroup testGroup;
    order ord;
    order cancelOrd;
    Storm_AI_TargetQueryOptions query;

    witchDoctorPlayer = UnitGetOwner(aiUnit);
    testGroup = UnitGroupAlliance(witchDoctorPlayer, c_unitAllianceEnemy, RegionCircle(UnitGetPosition(libGame_gv_players[witchDoctorPlayer].lv_heroUnit), c_WitchDoctorVisionRadius), null, c_noMaxCount);

    // Add the RavenousSpirit unit's scangroup to the WitchDoctor scangroup
    UnitGroupAddUnitGroup(testGroup, scanGroup);

    // Only control the ability if it is an AI player
    if (libAIAI_gf_HeroAIIsAIEnabledForPlayer(witchDoctorPlayer) == false) {
        return;
    }

    // Check if should cancel channelling in the RavenousSpirit think because the WitchDoctor does not
    // run AI Think for the RavenousSpirit channel because it is an uninterruptable order.
    if (WitchDoctorRavenousSpiritCancel(witchDoctorPlayer, libGame_gv_players[witchDoctorPlayer].lv_heroUnit, testGroup)) {
        return;
    }

    // Find a target hero
    query.lv_maxDistance = 10.0;
    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    targetEnemy = FindBestTacticalTarget(testGroup, libGame_gv_players[witchDoctorPlayer].lv_heroUnit, query);

    // If no valid hero, try to find a target tower
    if (!UnitIsValid(targetEnemy)) {
        targetEnemy = FindBestUnit(UnitGroupFilterTowers(testGroup), testGroup, libGame_gv_players[witchDoctorPlayer].lv_heroUnit, query);
    }

    ord = StormHeroAICreateOrder(player, c_Storm_AB_Move, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    if (UnitIsValid(targetEnemy)) {
        OrderSetTargetUnit(ord,targetEnemy);
    }
    else {
        // If the RavenousSpirit unit is quite far away from WitchDoctor and has no target enemy
        if (DistanceBetweenPoints(UnitGetPosition(aiUnit), UnitGetPosition(libGame_gv_players[witchDoctorPlayer].lv_heroUnit)) > 20.0) {
            cancelOrd = StormHeroAICreateOrder(player, c_AB_WitchDoctorRavenousSpiritCancel, 0);
            if (UnitOrderIsValid(libGame_gv_players[witchDoctorPlayer].lv_heroUnit, cancelOrd)) {
                HeroClaimForTactical(player, 0.0, false);

                // Don't use HeroIssueOrder for channeling
                UnitIssueOrder(libGame_gv_players[witchDoctorPlayer].lv_heroUnit, cancelOrd, c_orderQueueReplace);
                return;
            }
        }
        // If no enemies, continue to move in the RavenousSpirit facing direction to search for more enemies.
        OrderSetTargetPoint(ord, PointWithOffsetPolar(UnitGetPosition(aiUnit), 4.0, UnitGetFacing(aiUnit)));
    }

    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    // Don't use HeroIssueOrder for ravenous souls, it's not casting spells, it's just moving around
    UnitIssueOrder(aiUnit, ord, c_orderQueueReplace);
}


//---------------------------------------------------------------------------------------------
// L90ETC Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_L90ETCPowerSlide        = "L90ETCPowerslide";
const string c_AB_L90ETCFaceMelt          = "L90ETCFaceMelt";
const string c_AB_L90ETCGuitarSolo        = "L90ETCGuitarSolo";
const string c_AB_L90ETCStageDive         = "L90ETCStageDive";
const string c_AB_L90ETCMoshPit           = "L90ETCMoshPit";
const string c_AB_L90ETCMoshPitCancel     = "L90ETCMoshPitCancel";

// Powerslide Constants
// Range for Powerslide lowered to mirror its effective range under AI use
const fixed c_L90ETCPowerSlideRange = 4.5;
const fixed c_L90ETCPowerSlideEffectWidth = 2.0;

// Face Melt Constants
const fixed c_L90ETCFaceMeltRange = 4.0;

// Guitar Solo Constants
const fixed c_L90ETCGuitarSoloRange = 4.0;
const string c_L90ETCGroupiesTalent = "L90ETCMasteryGuitarSoloGroupies";

// Stage Dive Constants
const fixed c_L90ETCStageDiveMinDistance = 15.0;
const fixed c_L90ETCStageDiveRange = 5.0;
const int c_L90ETCStageDiveEnemyRequiredCount = 2;
const fixed c_L90ETCStageDiveAllyCheckRadius = 8.0;
const int c_L90ETCStageDiveAllyRequiredCount = 1;

// Mosh Pit Constants
const fixed c_L90ETCMoshPitRange = 4.0;
const fixed c_L90ETCMoshPitAllyCheckRadius = 7.0; // Range to expect allies can help
const int c_L90ETCMoshPitEnemyRequiredCount = 2;
const int c_L90ETCMoshPitAllyRequiredCount = 2;

//---------------------------------------------------------------------------------------------
bool L90ETCPowerSlide (int player, unit aiUnit, unitgroup scanGroup) {
    // Charge forward damaging and stunning enemies in a line

    // three uses for now:
    //   run away to live
    //   catch a fleeing enemy hero
    //   damage minion waves

    unit targetEnemy;
    point targetPos;
    point retreatPos;
    order spellOrd;
    order attackOrd;
    Storm_AI_TargetQueryOptions query;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    spellOrd = StormHeroAICreateOrder(player, c_AB_L90ETCPowerSlide, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // retreat if you have low health
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // charge back to retreat to safety
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, c_L90ETCPowerSlideRange, null);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // don't jump into battle near a tower or we're low health
    if(CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    query.lv_minDistance = 1.0; // Prevent ETC from ending up at a disadvantage
    query.lv_maxDistance = c_L90ETCPowerSlideRange;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent; // Only go for targets in the mid-low health range
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_ignoreTargetsBehindGate = true;
    // Find a target
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (targetEnemy == null){
        // If no hero target, then use on creeps/minions if at medium energy or higher
        if (energy < libAIAI_gv_aIHeroMediumEnergyPercent){
            return false;
        }
        query.lv_maxHealthPercent = 100.0; // Disregarding unit health in this situation
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (targetEnemy == null){
            return false;
        }
        // Check for enough heroes or creeps or minions to warrant using the ability
        targetPos = UnitGetPosition(targetEnemy);
        if (!EnoughEnemiesInArea( scanGroup, targetPos, c_L90ETCPowerSlideEffectWidth, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast4Creeps )){
            return false;
        }
    }
    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool L90ETCFaceMelt (int player, unit aiUnit, unitgroup scanGroup) {
    // Pushes back and damages all nearby enemies
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minEnemyHero;
    fixed minEnemyCreep;
    fixed minEnemyMinion;
    unit nearbyHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_L90ETCFaceMelt, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast if there are many enemies in the area, based on hero energy available
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minEnemyHero = c_Storm_AI_AtLeast1Hero;
        minEnemyCreep = c_Storm_AI_AtLeast1Creep;
        minEnemyMinion = c_Storm_AI_AtLeast2Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minEnemyHero = c_Storm_AI_AtLeast2Heroes;
        minEnemyCreep = c_Storm_AI_AtLeast2Creeps;
        minEnemyMinion = c_Storm_AI_AtLeast3Minions;
    }
    else {
        minEnemyHero = c_Storm_AI_AtLeast3Heroes;
        minEnemyCreep = c_Storm_AI_AtLeast4Creeps;
        minEnemyMinion = c_Storm_AI_AtLeast5Minions;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), c_L90ETCFaceMeltRange, minEnemyHero, minEnemyCreep, minEnemyMinion)){
        return false;
    }
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool L90ETCGuitarSolo (int player, unit aiUnit, unitgroup scanGroup) {
    // Regens health over next few seconds
    order ord;
    unit targetUnit;
    int value;
    Storm_AI_TargetQueryOptions query;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    ord = StormHeroAICreateOrder(player, c_AB_L90ETCGuitarSolo, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Check if Tier 1 "Groupies" talent is selected.
    if (PlayerHasTalent(player, c_L90ETCGroupiesTalent)) {
        // Can also regen allies
        // Use if there are any nearby heroes that could use healing including self
        query.lv_maxDistance = c_L90ETCGuitarSoloRange;
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroHighHealthPercent; // Ensure this hero needs healing
        query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
        query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
        targetUnit = FindBestUnit(AllyHeroUnitsInArea(player, UnitGetPosition(aiUnit), c_L90ETCGuitarSoloRange), scanGroup, aiUnit, query);
        if (targetUnit == null) {
            return false;
        }
    }
    else {
        // Can regen only self
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) >= libAIAI_gv_aIHeroHighHealthPercent) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool L90ETCStageDive (int player, unit aiUnit, unitgroup scanGroup) {
    // Leap (teleport) to any location on the map. Landing on enemies dealing damage and stunning them.

    order ord;
    point ourPos;
    int numEnemyHeroes;
    int enemyHeroIndex;
    unit enemyHero;
    int enemyHeroScore;
    point bestPos;
    int requiredNumberOfEnemyPlayers;
    int currentNumberOfEnemyPlayers;

    ord = StormHeroAICreateOrder(player, c_AB_L90ETCStageDive, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Flee battle to survive at low health.
    // This doesn't interact well with the retreat state, which immediately cancels the ability.
    // The problem is that other states, even CastTactical don't realise that this order is a valid retreat order.
    // To fix this, we would need a teleporting home state which allows hearthstone and this ability.
    //
    // if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
    //     return false;
    // }
    // return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueReplace, null, libGame_gv_players[player].lv_spawnPoint);

    // only consider using it when we haven't been attacked recently because it can be interrupted, and is better for launching into combat
    // so we also check that we are near full health.
    if (!HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroHighHealthPercent) {
        ourPos = UnitGetPosition(aiUnit);
        numEnemyHeroes = UnitGroupCount(libAIAI_gv_aIHeroes[player].lv_visibleEnemyHeroes, c_unitCountAll);
        bestPos = c_nullPoint;
        requiredNumberOfEnemyPlayers = c_L90ETCStageDiveEnemyRequiredCount;
        for (enemyHeroIndex = 1 ; enemyHeroIndex <= numEnemyHeroes; enemyHeroIndex += 1){
            enemyHero = UnitGroupUnit(libAIAI_gv_aIHeroes[player].lv_visibleEnemyHeroes, enemyHeroIndex);
            // only use it at long-ish range otherwise it looks silly, and only to help an ally, and use it on the indicated number of enemies
            if ((DistanceBetweenPoints(ourPos, UnitGetPosition(enemyHero)) > c_L90ETCStageDiveMinDistance)
             && (RequiredAllyPlayerCountInArea(c_L90ETCStageDiveAllyRequiredCount, player, UnitGetPosition(enemyHero), c_L90ETCStageDiveAllyCheckRadius))){
                currentNumberOfEnemyPlayers = CountPlayersInUnitGroup(UnitsInArea(scanGroup, UnitGetPosition(enemyHero), c_L90ETCStageDiveRange));
                if (currentNumberOfEnemyPlayers >= requiredNumberOfEnemyPlayers){
                    bestPos = UnitGetPosition(enemyHero);
                    requiredNumberOfEnemyPlayers = currentNumberOfEnemyPlayers + 1;
                }
            }
        }
        if (bestPos != c_nullPoint) {
            // Note that this can put us a long way from our objective, but we don't reset our objective here, we do it in a trigger
            // that is called once the ability completes, because we may be interrupted before then.
            return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueReplace, null, bestPos);
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool L90ETCMoshPit (int player, unit aiUnit, unitgroup scanGroup) {
    // After a short delay, channel to stun all nearby enemies for 4 seconds
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_L90ETCMoshPit, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight -- using complicated call to check ability range and teamfight followup
    if (!RequiredEnemyPlayerCountInArea(c_L90ETCMoshPitEnemyRequiredCount, scanGroup, UnitGetPosition(aiUnit), c_L90ETCMoshPitRange) || !RequiredAllyPlayerCountInArea(c_L90ETCMoshPitAllyRequiredCount, player, UnitGetPosition(aiUnit), c_L90ETCMoshPitAllyCheckRadius)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIChannelL90ETC (int player, unit aiUnit, unitgroup scanGroup) {
    order currentOrd = UnitOrder(aiUnit, 0);
    order ord;

    if (currentOrd == null) {
        return;
    }
    else if (OrderGetAbilityCommand(currentOrd) == AbilityCommand(c_AB_L90ETCMoshPit, 0)) {
        // Cancel Mosh Pit if we are getting killed
        ord = StormHeroAICreateOrder(player, c_AB_L90ETCMoshPitCancel, 0);
        if (!UnitOrderIsValid(aiUnit, ord)) {
            return;
        }

        if (!HaveBeenAttackedRecently(aiUnit) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            return;
        }

        HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
    }
}

//---------------------------------------------------------------------------------------------
void AIThinkL90ETC (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    // stagedive can be used as movement so we shouldn't skip it simply because we are mounted
    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && L90ETCStageDive(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (L90ETCGuitarSolo(player, aiUnit, scanGroup)) {
        return;
    }

    if (L90ETCPowerSlide(player, aiUnit, scanGroup)) {
        return;
    }

    if (L90ETCFaceMelt(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && L90ETCMoshPit(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Diablo Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_DiabloShadowCharge                = "DiabloShadowCharge";
const string c_AB_DiabloFireStomp                   = "DiabloFireStomp";
const string c_AB_DiabloOverpower                   = "DiabloOverpower";
const string c_AB_DiabloLightningBreath     = "DiabloLightningBreath";
const string c_AB_DiabloLightningBreathCancel = "LightningBreathCancel";
const string c_AB_DiabloApocalypse                  = "DiabloApocalypse";
const string c_AB_DiabloSiphonTheDead               = "SiphonTheDead";

const string c_DiabloLightningBreathActive        = "DiabloLightningBreathActive";

// Setting this to half the range of the missiles, as they move outward in a way that makes them more difficult to purposefully aim
const fixed c_DiabloFireStompEffectiveRange = 5.25;

const fixed c_DiabloShadowChargeRange = 5.0;
const fixed c_DiabloOutnumberedRange = 7.0;
const fixed c_DiabloOutnumberedCount = 3.0;
const string c_DiabloShadowChargeOverwhelmingForceTalent = "DiabloTalentOverwhelmingForceShadowCharge";
const fixed c_DiabloShadowChargeOverwhelmingForceRangeModifier = 1.75;

const fixed c_DiabloOverpowerTargetingRange = 4.0;
// Range here is reduced to establish effectiveness of the heroic
const fixed c_DiabloLightningBreathRange = 6.0;
const fixed c_DiabloLightningBreathWidth = 2.0;

const fixed c_DiabloApocalypseTeamFightRange = 8.0;

//---------------------------------------------------------------------------------------------
bool DiabloSiphonTheDead (int player, unit aiUnit, unitgroup scanGroup) {
    // Consume souls to regens health
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DiabloSiphonTheDead, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    // Heal is unnecessary if we're above mid-health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroMediumHealthPercent) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool DiabloFireStomp (int player, unit aiUnit, unitgroup scanGroup) {
    // Shoots fireballs radially in all direction
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unit nearbyHero;
    Storm_AI_TargetQueryOptions query;
    fixed minEnemyHero;
    fixed minEnemyCreep;
    fixed minEnemyMinion;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DiabloFireStomp, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast if there is a weak, close hero
    query.lv_maxDistance = c_DiabloFireStompEffectiveRange;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;


    // Find closest needs to be replaced
    nearbyHero = FindBestHero(scanGroup, aiUnit, query);
    if (nearbyHero != null) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Cast if there are many enemies in the area
    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minEnemyHero = 1;
        minEnemyCreep = 2;
        minEnemyMinion = 3;
    }
    else {
        minEnemyHero = 2;
        minEnemyCreep = 4;
        minEnemyMinion = 8;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), c_DiabloFireStompEffectiveRange, minEnemyHero, minEnemyCreep, minEnemyMinion)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool DiabloShadowCharge (int player, unit aiUnit, unitgroup scanGroup) {
    // Charge at an enemy pushing them back. Stuns them if it pushes them into a wall.
    unit targetEnemy;
    order spellOrd;
    order attackOrd;
    Storm_AI_TargetQueryOptions query;
    fixed abilityRange;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_DiabloShadowCharge, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        attackOrd = null;
    }

    // Don't jump into battle with low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    // setup target options
    abilityRange = c_DiabloShadowChargeRange;
    if (PlayerHasTalent(player, c_DiabloShadowChargeOverwhelmingForceTalent)) {
        abilityRange = (c_DiabloShadowChargeRange+c_DiabloShadowChargeOverwhelmingForceRangeModifier);
    }
    query.lv_minDistance = 1.0;
    query.lv_maxDistance = abilityRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_ignoreTargetsBehindGate = true;

    // Cast if enemy health is low enough
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroHighHealthPercent;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }

    // Find a target hero
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (targetEnemy == null){
        return false;
    }
    // Ensure he's not too outnumbered
    if (CountTeamOutnumberedBy(player, scanGroup, UnitGetPosition(targetEnemy), c_DiabloOutnumberedRange) >= c_DiabloOutnumberedCount){
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool DiabloOverpower (int player, unit aiUnit, unitgroup scanGroup) {
    // Flips the target behind Diablo and stuns them
    unit targetEnemy;
    order spellOrd;
    order attackOrd;
    Storm_AI_TargetQueryOptions query;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_DiabloOverpower, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // If low on health don't flip
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroLowHealthPercent) {
        return false;
    }

    // Cast if enemy health is low enough
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroHighHealthPercent;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }

    // Find a target hero
    query.lv_maxDistance = c_DiabloOverpowerTargetingRange;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    // No health preferences to keep this ability viable as CC for high and low targets
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (targetEnemy == null) {
        // Try to find a creep that fits the same criteria, but ultimately don't do this on a minion
        targetEnemy = FindBestAggroCreep(scanGroup, aiUnit, query);
        if (targetEnemy == null) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool DiabloLightningBreathActive (int player, unit aiUnit, unitgroup scanGroup) {
    // Update direction of breath cone or cancel if very low health
    unit targetEnemy;
    order cancelOrd;
    Storm_AI_TargetQueryOptions query;

    if (!UnitHasBehavior2(aiUnit, c_DiabloLightningBreathActive)) {
        return false;
    }

    // Stop channelling if in danger
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        cancelOrd = StormHeroAICreateOrder(player, c_AB_DiabloLightningBreathCancel, 0);
        if (UnitOrderIsValid(aiUnit, cancelOrd)) {
            HeroClaimForTactical(player, 0.0, false);

            // Don't use HeroIssueOrder for channeling
            UnitIssueOrder(aiUnit, cancelOrd, c_orderQueueReplace);
            return true;
        }
    }

    // Pauses Tactical AI for the duration
    HeroClaimForTactical(player, 1.25, false);
    // Find Diablo a good close and weak target
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets;
    query.lv_maxDistance = c_DiabloLightningBreathRange;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (targetEnemy == null) {
        // Use for tower damage if there's no compatible hero
        targetEnemy = GetNearbyTower(aiUnit, scanGroup);
        if (targetEnemy == null) {
            return true;
        }
    }

    return UnitUpdateChanneledOrderTarget (aiUnit, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool DiabloLightningBreath (int player, unit aiUnit, unitgroup scanGroup) {
    // Slow target and shoot multiple fireballs toward them
    order spellOrd;
    order moveOrd;
    unit targetEnemy;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DiabloLightningBreath, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    moveOrd = StormHeroAICreateOrder(player, c_Storm_AB_Move, 4);
    if (!UnitOrderIsValid(aiUnit, moveOrd)) {
        return false;
    }

    if (energy >= libAIAI_gv_aIHeroMediumEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroHighHealthPercent;
    }
    else if (energy >= libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumEnergyPercent;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }

    // Find a new target, preferring close and unhealthy
    query.lv_maxDistance = c_DiabloLightningBreathRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    // Ensure that our target has a player near them that can benefit from some fiery damage
    if (targetEnemy == null
    || !RequiredEnemyPlayerCountInArea(2, scanGroup, UnitGetPosition(targetEnemy), c_DiabloLightningBreathWidth)) {
        return false;
    }

    OrderSetTargetPoint(moveOrd, UnitGetPosition(targetEnemy));
    if (!UnitOrderIsValid(aiUnit, moveOrd)) {
        return false;
    }

    UnitIssueOrder(aiUnit, moveOrd, c_orderQueueReplace); // turn to face enemy, then cast which should always succeed
    if (HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToEnd, targetEnemy, null)) {
        HeroClaimForTactical(player, 1.25, false);
        return true;
    }
    return false;
}

//---------------------------------------------------------------------------------------------
bool DiabloApocalypse (int player, unit aiUnit, unitgroup scanGroup) {
    // Create a fire under all enemy heroes revealing them and damaging them if they don't move out in time
    order ord;
    unit targetHero;
    int enemyHeroIndex;
    int numEnemyHeroes;
    point targetPosition;

    ord = StormHeroAICreateOrder(player, c_AB_DiabloApocalypse, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Cast it any time Diablo sees a favorable teamfight with a weakened enemy
    numEnemyHeroes = UnitGroupCount(libAIAI_gv_aIHeroes[player].lv_visibleEnemyHeroes, c_unitCountAll);
    for (enemyHeroIndex = 1 ; enemyHeroIndex <= numEnemyHeroes; enemyHeroIndex += 1){
        targetHero = UnitGroupUnit(libAIAI_gv_aIHeroes[player].lv_visibleEnemyHeroes, enemyHeroIndex);
        if (targetHero != null) {
            targetPosition = UnitGetPosition(targetHero);
            if ((UnitGetPropertyFixed(targetHero, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroMediumHealthPercent)
            && (TeamFightInArea(player, scanGroup, targetPosition, c_DiabloApocalypseTeamFightRange))
            && (CountTeamOutnumberedBy(player, scanGroup, targetPosition, c_DiabloApocalypseTeamFightRange) >= 0)) {
                return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
            }
        }
    }
    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkDiablo (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (DiabloSiphonTheDead(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (DiabloOverpower(player, aiUnit, scanGroup)) {
        return;
    }

    // Sometimes is used as a combo with Overpower
    if (DiabloShadowCharge(player, aiUnit, scanGroup)) {
        return;
    }

    if (DiabloFireStomp(player, aiUnit, scanGroup)) {
        return;
    }

    if (DiabloLightningBreathActive(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && DiabloApocalypse(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && DiabloLightningBreath(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Malfurion Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_MalfurionRegrowth         = "MalfurionRegrowth";
const string c_AB_MalfurionMoonfire         = "MalfurionMoonfire";
const string c_AB_MalfurionEntanglingRoots  = "MalfurionEntanglingRoots";
const string c_AB_MalfurionTranquility      = "MalfurionTranquility";
const string c_AB_MalfurionTwilightDream    = "MalfurionTwilightDream";
const string c_AB_MalfurionInnervate        = "MalfurionInnervate";

const fixed c_AB_MalfurionRegrowthRange = 8.0;

const fixed c_AB_MalfurionMoonfireRange = 9.0;
const fixed c_AB_MalfurionMoonfireRadius = 1.5;

const fixed c_AB_MalfurionEntanglingRootsRange = 7.0;
const fixed c_AB_MalfurionEntanglingRootsRadius = 3.0;

const fixed c_AB_MalfurionTranquilityRadius = 6.5;

const fixed c_AB_MalfurionTwilightDreamRadius = 6.0;

const fixed c_AB_MalfurionInnervateRange = 7.0;

const string c_MalfurionElunesGraceTalent = "MalfurionCombatStyleElunesGrace";
const fixed c_MalfurionElunesGraceRangeMultiplier = 1.3;

const string c_MalfurionFullMoonfireTalent = "MalfurionMasteryFullMoonfire";
const fixed c_MalfurionFullMoonfireMoonfireRadiusModifier = 0.9;

const string c_MalfurionTenaciousRootsTalent = "MalfurionMasteryTenaciousRootsEntanglingRoots";
const fixed c_MalfurionTenaciousRootsRadiusModifier = 0.75;
//---------------------------------------------------------------------------------------------
bool MalfurionRegrowth (int player, unit aiUnit, unitgroup scanGroup) {
    // Heals a single target with a h.o.t. after
    order ord;
    unit targetUnit;
    fixed targetHealth;
    fixed abilityRange;

    ord = StormHeroAICreateOrder(player, c_AB_MalfurionRegrowth, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }
    abilityRange = c_AB_MalfurionRegrowthRange;
    if (PlayerHasTalent(player, c_MalfurionElunesGraceTalent)) {
        abilityRange *= c_MalfurionElunesGraceRangeMultiplier;
    }

    // Find weak nearby ally to heal
    targetUnit = FindBestHealTarget(player, aiUnit, abilityRange, c_Storm_AI_OnlyEssentialHealing, false);
    if (!UnitIsValid(targetUnit)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null);
}

//---------------------------------------------------------------------------------------------
bool MalfurionMoonfire (int player, unit aiUnit, unitgroup scanGroup) {
    // AOE damage spell with short cooldown
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unit targetEnemy;
    point targetPosition;
    Storm_AI_TargetQueryOptions query;
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    fixed abilityRange;
    fixed abilityRadius;

    spellOrd = StormHeroAICreateOrder(player, c_AB_MalfurionMoonfire, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    abilityRange = c_AB_MalfurionMoonfireRange;
    if (PlayerHasTalent(player, c_MalfurionElunesGraceTalent)) {
        abilityRange *= c_MalfurionElunesGraceRangeMultiplier;
    }
    // Cast on a weak enemy hero
    query.lv_maxDistance = abilityRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (targetEnemy != null) {
        targetPosition = UnitGetPosition(targetEnemy);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPosition);
    }
    query.lv_maxHealthPercent = 100.0;
    // If we weren't able to find a vulnerable Hero, then search for any with these conditions
    if (energy > libAIAI_gv_aIHeroMediumEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minMinions = c_Storm_AI_AtLeast2Minions;
        minCreeps = c_Storm_AI_AtLeast1Creep;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minMinions = c_Storm_AI_AtLeast3Minions;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
    }
    else {
        // Limit the target health to conserve mana
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minMinions = c_Storm_AI_AtLeast4Minions;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
    }
    // Currently, this is saying under low energy attack this weak hero or under higher energy heal minions
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (targetEnemy == null) {
        return false;
    }
    targetPosition = UnitGetPosition(targetEnemy);
    abilityRadius = c_AB_MalfurionMoonfireRadius;
    if (PlayerHasTalent(player, c_MalfurionFullMoonfireTalent)) {
        abilityRadius += c_MalfurionFullMoonfireMoonfireRadiusModifier;
    }
    if (!EnoughEnemiesInArea(scanGroup, targetPosition, abilityRadius, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPosition);
}

//---------------------------------------------------------------------------------------------
bool MalfurionEntanglingRoots (int player, unit aiUnit, unitgroup scanGroup) {
     // AOE damage spell with short cooldown
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unitgroup nearbyEnemies;
    unit targetEnemy;
    point targetPosition;
    Storm_AI_TargetQueryOptions query;
    fixed minHeroes;
    fixed minCreeps;
    fixed minMinions;
    fixed abilityRange;
    fixed abilityRadius;

    spellOrd = StormHeroAICreateOrder(player, c_AB_MalfurionEntanglingRoots, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    abilityRange = c_AB_MalfurionEntanglingRootsRange;
    if (PlayerHasTalent(player, c_MalfurionElunesGraceTalent)) {
        abilityRange *= c_MalfurionElunesGraceRangeMultiplier;
    }
    // Prefer close, unhealthy targets that have a chunk of life already gone
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = abilityRange;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (targetEnemy != null) {
        targetPosition = UnitGetPosition(targetEnemy);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPosition);
    }
    query.lv_maxHealthPercent = 100.0;
    // Limit usage of the ability through more extreme minimum target requirements
    if (energy > libAIAI_gv_aIHeroMediumEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast1Hero;
        minCreeps = c_Storm_AI_AtLeast2Creeps;
        minMinions = c_Storm_AI_AtLeast3Minions;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minHeroes = c_Storm_AI_AtLeast2Heroes;
        minCreeps = c_Storm_AI_AtLeast3Creeps;
        minMinions = c_Storm_AI_AtLeast4Minions;
    }
    else {
        minHeroes = c_Storm_AI_AtLeast3Heroes;
        minCreeps = c_Storm_AI_AtLeast4Creeps;
        minMinions = c_Storm_AI_AtLeast6Minions;
    }

    // Find a target based on the previous filters
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (targetEnemy == null) {
        return false;
    }
    abilityRadius = c_AB_MalfurionEntanglingRootsRadius;
    if (PlayerHasTalent(player, c_MalfurionTenaciousRootsTalent)){
        abilityRadius += c_MalfurionTenaciousRootsRadiusModifier;
    }
    targetPosition = UnitGetPosition(targetEnemy);
    if (!EnoughEnemiesInArea(scanGroup, targetPosition, abilityRadius, minHeroes, minCreeps, minMinions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPosition);
}

//---------------------------------------------------------------------------------------------
bool MalfurionTranquility (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE heal of all nearby allies. Moves with Malfurion.
    unit targetUnit;
    order ord;

    ord = StormHeroAICreateOrder(player, c_AB_MalfurionTranquility, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Find weakest nearby ally hero
    targetUnit = FindWeakestNearbyAllyHero(player, aiUnit, c_AB_MalfurionTranquilityRadius, libAIAI_gv_aIHeroLowHealthPercent, 300, false);

    if (!UnitIsValid(targetUnit)) {
        return false;
    }

    // Only activate if they are being attacked
    if (!HaveBeenAttackedRecently(targetUnit)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool MalfurionTwilightDream (int player, unit aiUnit, unitgroup scanGroup) {
    // Silence and slow all nearby enemies
    order spellOrd;
    unit targetHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_MalfurionTwilightDream, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!AnyHeroesInArea(scanGroup, UnitGetPosition(aiUnit), c_AB_MalfurionTwilightDreamRadius) || !RequiredAllyPlayerCountInArea(2, player, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange )) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool MalfurionInnervate (int player, unit aiUnit, unitgroup scanGroup) {
    // Grants mana regen to ally
    order ord;
    unit allyHero;
    unit targetAlly;
    int allyHeroIndex;
    int numAllies;
    fixed allyEnergy;
    fixed bestAllyEnergy;
    unitgroup allyUnitGroup;

    ord = StormHeroAICreateOrder(player, c_AB_MalfurionInnervate, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    allyUnitGroup = AllyHeroUnitsInArea(player, UnitGetPosition(aiUnit), c_AB_MalfurionInnervateRange);
    if (allyUnitGroup == null) {
        return false;
    }
    numAllies = CountPlayersInUnitGroup(allyUnitGroup);
    bestAllyEnergy = libAIAI_gv_aIHeroMediumEnergyPercent;
    // Cast on a low-energy ally
    for (allyHeroIndex = 1; allyHeroIndex <= numAllies; allyHeroIndex += 1) {
        allyHero = UnitGroupUnit(allyUnitGroup, allyHeroIndex);
        if (UnitIsValid(allyHero) && allyHero != aiUnit) {
            allyEnergy = UnitGetPropertyFixed(allyHero, c_unitPropEnergyPercent, c_unitPropCurrent);
            if (allyEnergy < bestAllyEnergy) {
               targetAlly = allyHero;
               bestAllyEnergy = allyEnergy;
            }
        }
    }
    if (!UnitIsValid(targetAlly)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetAlly, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkMalfurion (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (MalfurionRegrowth(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && MalfurionTranquility(player, aiUnit, scanGroup)) {
        return;
    }

    if (MalfurionInnervate(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && MalfurionTwilightDream(player, aiUnit, scanGroup)) {
        return;
    }

    if (MalfurionEntanglingRoots(player, aiUnit, scanGroup)) {
        return;
    }

    if (MalfurionMoonfire(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Falstad Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_FalstadHammerang          = "FalstadHammerang";
const string c_AB_FalstadLightningRod       = "FalstadLightningRod";
const string c_AB_FalstadBarrelRoll         = "FalstadBarrelRoll";
const string c_AB_FalstadHinterlandBlast    = "FalstadHinterlandBlast";
const string c_AB_FalstadMightyGust         = "FalstadMightyGust";

//---------------------------------------------------------------------------------------------
bool FalstadHammerang (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages enemies in a line and slows them
    unit targetEnemy;
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    point targetPosition;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_FalstadHammerang, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Find a target hero
    query.lv_maxDistance = 8;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor  = c_Storm_AI_StronglyPreferUnhealthyTargets;
    targetEnemy = FindBestTacticalTarget (scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        // If we have a decent amount of energy, we're allowed to target minions
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        query.lv_minScore = 0;
        targetEnemy = FindBestTacticalTarget (scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }

        // Only if there are at least 2 other minions or 1 hero near that minion
        targetPosition = UnitGetPosition(targetEnemy);
        if (!EnoughEnemiesInArea(scanGroup, targetPosition, 2, 1, 2, 2)) {
            return false;
        }
    }
    else {
    targetPosition = UnitGetPosition(targetEnemy);
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPosition);
}

//---------------------------------------------------------------------------------------------
bool FalstadLightningRod (int player, unit aiUnit, unitgroup scanGroup) {
    // Deal damages to an enemy and additional damage over 4 seconds if falstad remains close to the target
    order spellOrd;
    order attackOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_FalstadLightningRod, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        healthReq = 100.0;
    }
    else {
        healthReq = 60.0;
    }

    // Find a target hero
    query.lv_maxDistance = 5.5;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxHealthPercent = healthReq;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    targetEnemy = FindBestTacticalTarget (scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueReplace, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool FalstadBarrelRoll (int player, unit aiUnit, unitgroup scanGroup) {
    // Dash toward target location and gain a small shield for a short duration

    // Two uses for now:
    //   Run away to live
    //   Catch a fleeing enemy hero
    unit targetEnemy;
    point retreatPos;
    order spellOrd;
    order attackOrd;
    point targetPosition;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_FalstadBarrelRoll, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Retreat if you have low health
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // Dash back to retreat to safety
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 8.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Don't jump into battle near a tower or low health
    if(CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, 75.0)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find a target hero
    query.lv_minDistance = 5.0;
    query.lv_maxDistance = 9.0;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxHealthPercent = 40.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    targetEnemy = FindBestTacticalTarget (scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }
    // If the target has too many allies around, don't engage
    targetPosition = UnitGetPosition(targetEnemy);
    if (EnoughEnemiesInArea(scanGroup, targetPosition, 4, c_Storm_AI_AtLeast3Heroes, 0, 0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, targetPosition);
}

//---------------------------------------------------------------------------------------------
bool FalstadHinterlandBlast (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages all enemies in a wide beam after a short delay
    order ord;
    unitgroup enemyHeroes;
    unit targetEnemy;
    point center;

    ord = StormHeroAICreateOrder(player, c_AB_FalstadHinterlandBlast, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Don't use if retreating. It has a long cast time and can't be canceled.
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    // Center on the heroes if one is nearby
    enemyHeroes = UnitGroupFilterHeroes(scanGroup);
    if (UnitGroupCount(enemyHeroes, c_unitCountAll) > 0) {
        center = UnitGroupCenterOfGroup(enemyHeroes);
    }

    // Only use on large group of enemies

    if (!EnoughEnemiesInArea(scanGroup, center, 3, 3, 6, 9)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, center);
}

//---------------------------------------------------------------------------------------------
bool FalstadMightyGust (int player, unit aiUnit, unitgroup scanGroup) {
    // Pushes back all enemies in a wide rectangle and slows them 60%
    // Use in a losing team fight, or to save falstad.
    order spellOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_FalstadMightyGust, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // If we've been attacked recently and are low health, we want to cast, else consider the team fight case
    if (!HaveBeenAttackedRecently(aiUnit) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_endOffensiveHealth) {

        // Only activate if there is a team fight and we are outnumbered
        if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)
        || (CountTeamOutnumberedBy(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange) < 0 )) {
            return false;
        }
        // Don't activate if we're close to full health
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
            return false;
        }
    }
    query.lv_healthFactor = c_Storm_AI_PreferHealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets;
    // find a target enemy
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
void AIThinkFalstad (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (FalstadBarrelRoll(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && FalstadMightyGust(player, aiUnit, scanGroup)) {
        return;
    }

    if (FalstadLightningRod(player, aiUnit, scanGroup)) {
        return;
    }

    if (FalstadHammerang(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && FalstadHinterlandBlast(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Demon Hunter Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_DemonHunterHungeringArrow     = "DemonHunterHungeringArrow";
const string c_AB_DemonHunterMultishot          = "DemonHunterMultishot";
const string c_AB_DemonHunterVault              = "DemonHunterVault";
const string c_AB_DemonHunterRainOfVengeance    = "DemonHunterRainOfVengeance";
const string c_AB_DemonHunterStrafe             = "DemonHunterStrafe";
const string c_DemonHunterFrostShotTalent       = "DemonHunterMasteryFrostShot";

//---------------------------------------------------------------------------------------------
bool DemonHunterHungeringArrow (int player, unit aiUnit, unitgroup scanGroup) {
    // Skillshot that damages other nearby enemies
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DemonHunterHungeringArrow, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        healthReq = 100.0;
    }
    else {
        healthReq = 50.0;
    }

    query.lv_maxDistance = 9.5;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxHealthPercent = healthReq;
    query.lv_lineOfSightRequired =  true;
    targetEnemy = FindBestTacticalTarget (scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        // Shoot a minion if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        query.lv_minScore = 0;
        query.lv_maxHealthPercent = 100;
        query.lv_lineOfSightRequired =  false;
        targetEnemy = FindBestTacticalTarget (scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool DemonHunterMultishot (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals damage to all enemies in fron to hero
    order spellOrd;
    unitgroup nearbyEnemies;
    unit targetEnemy;
    point center;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed minEnemyEval;
    Storm_AI_TargetQueryOptions query;
    fixed range;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DemonHunterMultishot, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (PlayerHasTalent(player, c_DemonHunterFrostShotTalent)) {
        range = 11.0;
    }
    else {
        range = 9.0;
    }
    // Cast on a weak enemy hero

    query.lv_maxDistance = range;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxHealthPercent = 40;
    targetEnemy = FindBestTacticalTarget (scanGroup, aiUnit, query);

    if (UnitIsValid(targetEnemy)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
    }

    // Cast if there is a large number of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minEnemyEval = 4;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minEnemyEval = 6;
    }
    else {
        minEnemyEval = 8;
    }

    nearbyEnemies = UnitsInArea(scanGroup, UnitGetPosition(aiUnit), 8.0);
    center = UnitGroupCenterOfGroup(nearbyEnemies);

    if (!EnoughEnemiesInArea(nearbyEnemies, center, 3, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast3Creeps, minEnemyEval)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, center);
}

//---------------------------------------------------------------------------------------------
bool DemonHunterVault (int player, unit aiUnit, unitgroup scanGroup) {
    // Dash to target location
    point retreatPos;
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;
    point targetPosition;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DemonHunterVault, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // Jump towards your spawn for safety
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 7.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Don't jump into battle near a tower or low health
    if(CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, 75.0)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find a target hero
    query.lv_minDistance = 4.5;
    query.lv_maxDistance = 8;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxHealthPercent = 40;
    targetEnemy = FindBestTacticalTarget (scanGroup, aiUnit, query);


    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    // If the target has too many allies around, don't engage
    targetPosition = UnitGetPosition(targetEnemy);
    if (EnoughEnemiesInArea(scanGroup, targetPosition, 4, c_Storm_AI_AtLeast3Heroes, 0, 0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, targetPosition);
}

//---------------------------------------------------------------------------------------------
bool DemonHunterRainOfVengeance (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals damage and stuns to all enemies in front of hero
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit target;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DemonHunterRainOfVengeance, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }


    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    // One less than the max to give us time to catch a running unit.
    query.lv_maxDistance = 6.0;
    query.lv_ignoreTargetsBehindGate = true;
    target = FindBestHero(scanGroup, aiUnit, query);


    if (UnitIsValid(target)
        && (RequiredEnemyPlayerCountInArea(2, scanGroup, UnitGetPosition(target), 1.5)
         || UnitGetPropertyFixed(target, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroLowHealthPercent)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, UnitGetPosition(target));
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool DemonHunterStrafe (int player, unit aiUnit, unitgroup scanGroup) {
    // Shoots arrows at nearby enemies over next few seconds
    order spellOrd;
    unit targetHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_DemonHunterStrafe, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 9.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkDemonHunter (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (DemonHunterVault(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && DemonHunterRainOfVengeance(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && DemonHunterStrafe(player, aiUnit, scanGroup)) {
        return;
    }

    if (DemonHunterHungeringArrow(player, aiUnit, scanGroup)) {
        return;
    }

    if (DemonHunterMultishot(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Tychus Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_TychusGrenade                 = "TychusGrenade";
const string c_AB_TychusRunAndGun               = "TychusRunAndGun";
const string c_AB_TychusOverkillTargeted        = "TychusOverkillTargeted";
const string c_AB_TychusOdin                    = "TychusOdinNoHealth";
const string c_AB_OdinAnnihilate                = "TychusOdinAnnihilate";
const string c_AB_OdinRagnarokMissiles          = "TychusOdinRagnarokMissilesTargeted";
const string c_AB_OdinNuclearBlast              = "TychusOdinNuclearBlast";
const string c_AB_TychusDrakkenLaserDrill       = "TychusDrakkenLaserDrill";
const string c_AB_TychusMinigunActive           = "TychusMinigunActive";
const string c_NeosteelPlatingItem              = "TychusNeosteelCoating";

const fixed c_TychusOverkillRange                = 6.0;
const fixed c_TychusOverkillRadius               = 5.0;
const fixed c_TychusGrenadeRange                 = 7.0;
const fixed c_TychusGrenadeRadius                = 2.0;
const fixed c_TychusRunAndGunRange               = 8.0;
const fixed c_TychusOdinUseRange                 = 8.0;
const fixed c_TychusAnnihilateRange              = 18.0;
const fixed c_TychusAnnihilateRadius             = 2.0;
const fixed c_TychusRagnarokMissileRange         = 14.0;
const fixed c_TychusRagnarokMissileRadius        = 4.0;
const fixed c_TychusDrakkenLaserDrillRange       = 10.0;
const fixed c_TychusDrakkenLaserDrillRadius      = 10.0;

//---------------------------------------------------------------------------------------------
bool TychusGrenade (int player, unit aiUnit, unitgroup scanGroup) {
    // Lob Grenade that deals damage and knocks enemies away from impact point
    unit targetUnit;
    point targetPos;
    fixed energy;
    Storm_AI_TargetQueryOptions query;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusGrenade, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = c_TychusGrenadeRange;

    energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroHighHealthPercent;
    }
    else if (energy > libAIAI_gv_aIHeroMediumEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }

    // Target best hero
    targetUnit = FindBestHero(scanGroup, aiUnit, query);

    // Check if hero is valid
    if (UnitIsValid(targetUnit)) {
        targetPos = UnitGetPosition(targetUnit);
    }
    else {
        // Target a minion if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        targetUnit = FindBestUnit(scanGroup, scanGroup, aiUnit, query);
        if (UnitIsValid(targetUnit)) {
            targetPos = UnitGetPosition(targetUnit);
            if (!EnoughEnemiesInArea(scanGroup, targetPos, c_TychusGrenadeRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast3Minions, c_Storm_AI_AtLeast3Creeps)) {
                return false;
            }
        }
        else {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TychusRunAndGun (int player, unit aiUnit, unitgroup scanGroup) {
    // Dashes to target position and winds up his gun
    order attackOrd;
    point retreatPos;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusRunAndGun, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Dash to safety if low health
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 5.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Don't jump into battle if near a tower or have low health
    if (CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    query.lv_maxDistance = c_TychusRunAndGunRange;

    // Find a target hero
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool TychusOverkillTargeted (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages all enemies in front of hero over next few seconds
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusOverkillTargeted, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Don't use in battle if near a tower or have low health
    if(CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    query.lv_maxDistance = c_TychusOverkillRange;

    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    // only activate if there are other nearby enemies for it to hit
    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetHero), c_TychusOverkillRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast3Minions, c_Storm_AI_AtLeast3Creeps)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool TychusOdin (int player, unit aiUnit, unitgroup scanGroup) {
    // Transform into odin
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusOdin, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {
        return false;
    }

    query.lv_maxDistance = c_TychusOdinUseRange;

    // Attack nearest hero after transforming
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    // deliberately setting the attackOrd target here and passing in "null, null" for the target since odin itself has no target
    OrderSetTargetUnit(attackOrd, targetHero);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool OdinAnnihilate (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals AoE damage in a line
    point center;
    unit targetUnit;
    Storm_AI_TargetQueryOptions query;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_OdinAnnihilate, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = c_TychusAnnihilateRange;

    targetUnit = FindBestUnit(scanGroup, scanGroup, aiUnit, query);
    if (!UnitIsValid(targetUnit)) {
        return false;
    }

    center = UnitGetPosition(targetUnit);
    if (!EnoughEnemiesInArea(scanGroup, center, c_TychusAnnihilateRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast4Creeps, c_Storm_AI_AtLeast5Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, center);
}

//---------------------------------------------------------------------------------------------
bool OdinRagnarokMissiles (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages all nearby enemies
    Storm_AI_TargetQueryOptions query;
    unit nearbyEnemy;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_OdinRagnarokMissiles, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = c_TychusRagnarokMissileRange;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;

    // Cast if there is a weak hero
    nearbyEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(nearbyEnemy)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(nearbyEnemy));
    }

    // Cast if there is a weak tower
    nearbyEnemy = FindBestUnit(UnitGroupFilterTowers(scanGroup), scanGroup, aiUnit, query);
    if (UnitIsValid(nearbyEnemy)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(nearbyEnemy));
    }

    // Cast if there are many enemies in the area
    query.lv_maxHealthPercent = 100.0;
    nearbyEnemy = FindBestUnit(scanGroup, scanGroup, aiUnit, query);
    if (!UnitIsValid(nearbyEnemy)) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(nearbyEnemy), c_TychusRagnarokMissileRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast4Creeps, c_Storm_AI_AtLeast5Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(nearbyEnemy));
}

//---------------------------------------------------------------------------------------------
bool TychusDrakkenLaserDrill (int player, unit aiUnit, unitgroup scanGroup) {
    // Places a turret that shoots nearby enemies
    Storm_AI_TargetQueryOptions query;
    unit targetHero;
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusDrakkenLaserDrill, 0);

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {
        return false;
    }

    query.lv_maxDistance = c_TychusDrakkenLaserDrillRange;

    // Place on a group of nearby heroes
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetHero), c_TychusDrakkenLaserDrillRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast4Creeps, c_Storm_AI_AtLeast5Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetHero));
}

//---------------------------------------------------------------------------------------------
bool TychusMinigunActive (int player, unit aiUnit, unitgroup scanGroup) {
    // Activate to deal giant killer damage
    order spellOrd;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TychusMinigunActive, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange)) {
        return false;
    }

    return UnitIssueOrder (aiUnit, spellOrd, c_orderQueueAddToFront);
}

//---------------------------------------------------------------------------------------------
bool TychusDefensiveItemCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    if (itemType == c_NeosteelPlatingItem) {
        if (!HaveBeenAttackedRecently(aiUnit) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
            return false;
        }
        return UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkTychus (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseItem(player, aiUnit, scanGroup, TychusDefensiveItemCallback)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (OdinRagnarokMissiles(player, aiUnit, scanGroup)) {
        return;
    }

    if (OdinAnnihilate(player, aiUnit, scanGroup)) {
        return;
    }

    if (TychusRunAndGun(player, aiUnit, scanGroup)) {
        return;
    }

    if (TychusGrenade(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TychusDrakkenLaserDrill(player, aiUnit, scanGroup)) {
        return;
    }

    if (TychusOverkillTargeted(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TychusOdin(player, aiUnit, scanGroup)) {
        return;
    }

    if (TychusMinigunActive(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Tyrande Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_TyrandeLightofElune   = "TyrandeLightofElune";
const string c_AB_TyrandeSentinelShot   = "TyrandeSentinelShot";
const string c_AB_TyrandeLunarFlare     = "TyrandeLunarFlare";
const string c_AB_TyrandeShadowStalk    = "TyrandeShadowstalk";
const string c_AB_TyrandeStarfall       = "TyrandeStarfall";
const string c_AB_TyrandeHuntersMark    = "TyrandeHuntersMark";
const string c_TyrandeLunarBlazeTalent = "TyrandeMasteryLunarBlaze";
const fixed c_TyrandeHuntersMarkRange   = 5.5;

//---------------------------------------------------------------------------------------------
bool TyrandeLightofElune (int player, unit aiUnit, unitgroup scanGroup) {
    // Heals target ally and self
    unit targetUnit;
    order ord;
    fixed targetHealth;

    ord = StormHeroAICreateOrder(player, c_AB_TyrandeLightofElune, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Find weak nearby ally to heal
    targetUnit = FindBestHealTarget(player, aiUnit, 8.5, c_Storm_AI_OnlyEssentialHealing, false);
    if (!UnitIsValid(targetUnit)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null);
}

//---------------------------------------------------------------------------------------------
bool TyrandeSentinelShot (int player, unit aiUnit, unitgroup scanGroup) {
    // Shoots an owl across the map that gives vision and damages an enemy hero if it hits them
    order spellOrd;
    order attackOrd;
    unit targetHero;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyrandeSentinelShot, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        healthReq = 100.0;
    }
    else {
        healthReq = 60.0;
    }

    // Use on a weak enemy hero
    query.lv_maxDistance = 13;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxHealthPercent = healthReq;
    targetHero = FindBestTacticalTarget (scanGroup, aiUnit, query);

    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool TyrandeLunarFlare (int player, unit aiUnit, unitgroup scanGroup) {
    // AoE shot that damages/stuns targets in a small area
    order spellOrd;
    unit targetHero;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;
    fixed range;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyrandeLunarFlare, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        healthReq = 100.0;
    }
    else {
        healthReq = 60.0;
    }

    if (PlayerHasTalent(player, c_TyrandeLunarBlazeTalent)) {
        range = 13.0;
    }
    else {
        range = 9.0;
    }
    // Shoot at any nearby hero
    query.lv_maxDistance = range;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxHealthPercent = healthReq;
    targetHero = FindBestTacticalTarget (scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        // Shoot minions if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        targetPos = UnitGroupCenterOfGroup(scanGroup);
        if (!EnoughEnemiesInArea(scanGroup, targetPos, 2.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
            return false;
        }
    }
    else {
        targetPos = UnitGetPosition(targetHero);
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TyrandeShadowStalk (int player, unit aiUnit, unitgroup scanGroup) {
    // Cloaks all nearby allies
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyrandeShadowStalk, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!HaveBeenAttackedRecently(aiUnit) || !TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 8.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool TyrandeStarfall (int player, unit aiUnit, unitgroup scanGroup) {
    // Damage/slow nearby enemies
    order spellOrd;
    order attackOrd;
    unitgroup nearbyEnemies;
    unitgroup nearbyEnemyHeroes;
    point center;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyrandeStarfall, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 10.0)) {
        return false;
    }

    // Center on heroes are any is nearby
    nearbyEnemies = UnitsInArea(scanGroup, UnitGetPosition(aiUnit), 8.0);
    nearbyEnemyHeroes = UnitGroupFilterHeroes(nearbyEnemies);

    if (UnitGroupCount(nearbyEnemyHeroes, c_unitCountAll) == 0) {
        return false;
    }

    center = UnitGroupCenterOfGroup(nearbyEnemyHeroes);

    if (!EnoughEnemiesInArea(scanGroup, center, 6.0, c_Storm_AI_AtLeast3Heroes, 5, 9)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, center);
}

//---------------------------------------------------------------------------------------------
bool TyrandeHuntersMark (int player, unit aiUnit, unitgroup scanGroup) {
    // Make a target enemy vulnerable
    order spellOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyrandeHuntersMark, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Target a weaker nearby hero
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = c_TyrandeHuntersMarkRange;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkTyrande (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (TyrandeLightofElune(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (TyrandeLunarFlare(player, aiUnit, scanGroup)) {
        return;
    }

    if (TyrandeSentinelShot(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TyrandeShadowStalk(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TyrandeStarfall(player, aiUnit, scanGroup)) {
        return;
    }

    if (TyrandeHuntersMark(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Faerie Dragon Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_FaerieDragonArcaneFlare       = "FaerieDragonArcaneFlare";
const string c_AB_FaerieDragonPolymorph         = "FaerieDragonPolymorph";
const string c_AB_FaerieDragonPixieDust         = "FaerieDragonPixieDust";
const string c_AB_FaerieDragonBlinkHeal         = "FaerieDragonBlinkHeal";
const string c_AB_FaerieDragonBlinkHealDash     = "FaerieDragonBlinkHealDash";
const string c_AB_FaerieDragonEmeraldWind       = "FaerieDragonEmeraldWind";
const string c_FaeriesDragonArcaneBarrageTalent = "BrightwingArcaneBarrageArcaneFlare";

//---------------------------------------------------------------------------------------------
bool FaerieDragonArcaneFlare (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals damage to target area
    order spellOrd;
    unit targetHero;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;
    fixed range;

    spellOrd = StormHeroAICreateOrder(player, c_AB_FaerieDragonArcaneFlare, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        healthReq = 95.0;
    }
    else {
        healthReq = 60.0;
    }

    if (PlayerHasTalent(player, c_FaeriesDragonArcaneBarrageTalent)) {
        range = 12.0;
    }
    else {
        range = 8.0;
    }
    // Shoot a nearby hero
    query.lv_maxHealthPercent = healthReq;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = range;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        // Shoot a group of minions if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        targetPos = UnitGroupCenterOfGroup(scanGroup);
        if (!EnoughEnemiesInArea(scanGroup, targetPos, 2.5, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
            return false;
        }
    }
    else {
        targetPos = UnitGetPosition(targetHero);
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool FaerieDragonPolymorph (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages and debuffs target unit
    order spellOrd;
    fixed healthPercent = 50;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_FaerieDragonPolymorph, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Always cast while retreating from attacker
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        healthPercent = 100.0;
    }
    // Otherwise, always cast if outnumbered or participating in a chase with allies
    else if (RequiredEnemyPlayerCountInArea(2, scanGroup, UnitGetPosition(aiUnit), 6.0) || RequiredAllyPlayerCountInArea(2, player, UnitGetPosition(aiUnit), 6.0)) {
        healthPercent = 100.0;
    }

    query.lv_maxHealthPercent = healthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = 6.0;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool FaerieDragonPixieDust (int player, unit aiUnit, unitgroup scanGroup) {
    // Increases move speed and blocks a few incoming attacks, use if any ally has been attacked recently and is below 70% health
    //  Future use could be to chase down a fleeing enemy
    order ord;
    unit targetUnit;

    ord = StormHeroAICreateOrder(player, c_AB_FaerieDragonPixieDust, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Find weakest nearby ally hero that is being attacked
    targetUnit = FindWeakestNearbyAllyHero(player, aiUnit, 10.0, 70.0, -1.0, false);

    if (UnitIsValid(targetUnit)) {
        if (HaveBeenAttackedRecently(targetUnit)) {
            if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null)) {
                return true;
            }
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool FaerieDragonBlinkHeal (int player, unit aiUnit, unitgroup scanGroup) {
    // Gives us the ability to dash to nearby ally heros and heal them for 10 seconds.
    //   In the future could be used to save ourselves, but for now just used to heal allies
    order ord;
    unit targetUnit;
    fixed targetHealth;

    ord = StormHeroAICreateOrder(player, c_AB_FaerieDragonBlinkHeal, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Activate if there is a team fight
    if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 6.0)) {
        // And any damaged ally hero
        targetUnit = FindWeakestNearbyAllyHero(player, aiUnit, 10.0, 80.0, -1.0, false);
        if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null)) {
            return true;
        }
    }

    // Or if we find a nearby weak ally hero that is under attacked
    targetUnit = FindWeakestNearbyAllyHero(player, aiUnit, 10.0, 65.0, -1.0, false);
    if (UnitIsValid(targetUnit)) {
        if (HaveBeenAttackedRecently(targetUnit)) {
            if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null)) {
                return true;
            }
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool FaerieDragonBlinkHealDash (int player, unit aiUnit, unitgroup scanGroup) {
    // Dash to an ally giving them a heal & a hot
    order ord;
    unit targetUnit;

    ord = StormHeroAICreateOrder(player, c_AB_FaerieDragonBlinkHealDash, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Find weakest nearby ally hero that is being attacked
    targetUnit = FindWeakestNearbyAllyHero(player, aiUnit, 10.0, 70.0, -1.0, false);

    if (UnitIsValid(targetUnit)) {
        if (HaveBeenAttackedRecently(targetUnit)) {
            if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, targetUnit, null)) {
                return true;
            }
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool FaerieDragonEmeraldWind (int player, unit aiUnit, unitgroup scanGroup) {
    // AOE around hero that damages and pushes back enemies
    order spellOrd;
    unit targetHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_FaerieDragonEmeraldWind, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!RequiredEnemyPlayerCountInArea(2, scanGroup, UnitGetPosition(aiUnit), 6.0) || !RequiredAllyPlayerCountInArea(2, player, UnitGetPosition(aiUnit), 10.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkFaerieDragon (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (FaerieDragonPixieDust(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && FaerieDragonBlinkHeal(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && FaerieDragonBlinkHealDash(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && FaerieDragonEmeraldWind(player, aiUnit, scanGroup)) {
        return;
    }

    if (FaerieDragonPolymorph(player, aiUnit, scanGroup)) {
        return;
    }

    if (FaerieDragonArcaneFlare(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Tyrael Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_TyraelElDruinsMight                       = "TyraelElDruinsMight";
const string c_AB_TyraelElDruinsMightAngelicFlash           = "ElDruinsMightAngelicFlash";
const string c_AB_TyraelElDruinsMightAngelicFlashMastery    = "ElDruinsMightAngelicFlashMastery";
const string c_AB_TyraelRighteousness                       = "TyraelRighteousness";
const string c_AB_TyraelSmite                               = "TyraelSmite";
const string c_AB_TyraelJudgement                           = "TyraelJudgement";
const string c_AB_TyraelSanctification                      = "TyraelSanctificationStationary";
const string c_AB_TyraelSanctificationCancel                = "CancelSanctification";

const string c_EldruinSwordUnit                             = "TyraelEldruinSword";

//---------------------------------------------------------------------------------------------
bool TyraelElDruinsMight (int player, unit aiUnit, unitgroup scanGroup) {
    // Throw sword damaging and slowing all enemies in target area
    order spellOrd;
    point retreatPos;
    unit targetHero;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelElDruinsMight, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Throw sword toward spawn if low health to use the teleport to retreat faster
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 9.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        healthReq = 100.0;
    }
    else {
        healthReq = 60.0;
    }

    // Shoot any nearby hero
    query.lv_maxHealthPercent = healthReq;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = 9.0;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        // Shoot a group of minions if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        targetPos = UnitGroupCenterOfGroup(scanGroup);
        if (!EnoughEnemiesInArea(scanGroup, targetPos, 2.5, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
            return false;
        }
    }
    else {
        targetPos = UnitGetPosition(targetHero);
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool ElDruinsMightAngelicFlash (int player, unit aiUnit, unitgroup scanGroup) {
    // Teleports Tyrael to where the sword was thrown
    order spellOrd;
    order attackOrd;
    unitgroup nearbySwords;
    unit sword;
    fixed healthPercent = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    unitgroup enemiesNearSword;
    unit targetHero;
    fixed heroToHomeDistance;
    fixed swordToHomeDistance;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelElDruinsMightAngelicFlash, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelElDruinsMightAngelicFlashMastery, 0);
        if (!UnitOrderIsValid(aiUnit, spellOrd)) {
            return false;
        }
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find the position of his sword
    nearbySwords = UnitGroup(c_EldruinSwordUnit, player, RegionCircle(UnitGetPosition(aiUnit), 500.0), null, 0);
    if (UnitGroupCount(nearbySwords, c_unitCountAll) == 0) {
        return false;
    }

    sword = UnitGroupUnit(nearbySwords, 1);

    // Teleport if you are low health and your sword is closer to home
    if (healthPercent < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        heroToHomeDistance = DistanceBetweenPoints(UnitGetPosition(aiUnit), libGame_gv_players[player].lv_spawnPoint);
        swordToHomeDistance = DistanceBetweenPoints(UnitGetPosition(sword), libGame_gv_players[player].lv_spawnPoint);

        if (swordToHomeDistance < heroToHomeDistance) {
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
        }
    }

    // Teleport if the sword is near a weak enemy
    if(!CheckIfTooLowHealthOrNearbyTower(aiUnit, scanGroup, 60.0)) {
        enemiesNearSword = UnitsInArea(scanGroup, UnitGetPosition(sword), 3.0);
        query.lv_maxHealthPercent = 50;
        query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
        query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
        query.lv_maxDistance = 3.0;
        targetHero = FindBestHero(enemiesNearSword, sword, query);

        if (UnitIsValid(targetHero)) {
            // deliberately setting the attackOrd target here and passing in "null, null" for the target
            //      since ReturnSword itself has no target
            OrderSetTargetUnit(attackOrd, targetHero);
            if (!UnitOrderIsValid(aiUnit, attackOrd)) {
                return false;
            }

            return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueReplace, null, null);
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool TyraelRighteousness (int player, unit aiUnit, unitgroup scanGroup) {
    // Casts a temporary shield on self, minor shield on nearby allies
    order spellOrd;
    fixed health = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelRighteousness, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use if you are being attacked while retreating or a decent amount of energy
    if (HaveBeenAttackedRecently(aiUnit)) {
        if ((energy > libAIAI_gv_aIHeroMediumEnergyPercent && health < 80) || health < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
        }
    }

    // Activate if there is a team fight
    if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 6.0)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool TyraelSmite (int player, unit aiUnit, unitgroup scanGroup) {
    // aoe damage
    order spellOrd;
    unit targetHero;
    point targetPos;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelSmite, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        healthReq = 100.0;
    }
    else {
        healthReq = 60.0;
    }

        // Shoot any nearby hero
    query.lv_maxHealthPercent = healthReq;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = 8.0;
    targetHero = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetHero)) {
        // Shoot a group of minions if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }

        targetPos = UnitGroupCenterOfGroup(scanGroup);
        if (!EnoughEnemiesInArea(scanGroup, targetPos, 3.5, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
            return false;
        }
    }
    else {
        targetPos = UnitGetPosition(targetHero);
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//---------------------------------------------------------------------------------------------
bool TyraelJudgement (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages and stuns enemy. Knocks back all surrounding enemies.
    order spellOrd;
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelJudgement, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    query.lv_maxHealthPercent = 50;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = 11.0;
    query.lv_minDistance = 1.0;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool TyraelSanctification (int player, unit aiUnit, unitgroup scanGroup) {
    // Makes nearby allies invulnerable while channeling
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_TyraelSanctification, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Only activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 6.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}


//---------------------------------------------------------------------------------------------
void AIThinkTyrael (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }


    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (ElDruinsMightAngelicFlash(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (TyraelRighteousness(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TyraelSanctification(player, aiUnit, scanGroup)) {
        return;
    }

    if (TyraelElDruinsMight(player, aiUnit, scanGroup)) {
        return;
    }

    if (TyraelSmite(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && TyraelJudgement(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Sonya Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_BarbarianBash                     = "BarbarianSeismicSlam";
const string c_AB_BarbarianWhirlwind                = "BarbarianWhirlwind";
const string c_AB_BarbarianWhirlwindCancel          = "BarbarianWhirlwindCancel";
const string c_AB_BarbarianAncientSpear             = "BarbarianAncientSpear";
const string c_AB_BarbarianLeap                     = "BarbarianLeap";
const string c_AB_BarbarianWrathOfTheBeserker       = "BarbarianWrathoftheBerserker";
const string c_AB_BarbarianShotofFury               = "BarbarianShotofFury";

const string c_BarbarianWhirlwindChannelBehavior    = "BarbarianWhirlwindChannel";
const string c_BarbarianCompositeSpearTalent        = "BarbarianMasteryCompositeSpearAncientSpear";

//---------------------------------------------------------------------------------------------
bool BarbarianBash (int player, unit aiUnit, unitgroup scanGroup) {
    // Strong melee attack
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_BarbarianBash, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Use on a weak enemy hero
    query.lv_maxDistance = 3.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        // Only try for a minion if we have pleny of enerygy. This allows us to save up to use whirlwind.
        // 65 is the cost of whirlwind plus bash.
        if(UnitGetPropertyFixed(aiUnit, c_unitPropEnergy, c_unitPropCurrent) < 65) {
            return false;
        }
        query.lv_minScore = 0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool BarbarianWhirlwind (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE that damages nearby enemies over the next few seconds.
    order ord;

    // only cast if we are healthy enough to maintain for a little while
    if(UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    ord = StormHeroAICreateOrder(player, c_AB_BarbarianWhirlwind, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // If there are not enough enemy units around the hero, do not cast
    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 4.0, c_Storm_AI_AtLeast2Heroes, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast4Minions)) {
        return false;
    }


    if(HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueReplace, null, null)) {
        HeroClaimForTactical(player, 3.0, false); // let whirlwind move the player until it stops
        return true;
    }
    return false;
}

//--------------------------------------------------------------------------------------------
void AIChannelBarbarianWhirlwind (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    // Move to the closest enemy
    query.lv_maxDistance = 8.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        targetEnemy = FindClosestWeakMinion(scanGroup, aiUnit, 0.0, 8.0, 100.0, -1, -1, c_Storm_AI_LOS_Optional);
        query.lv_minScore = 0;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    }
    if (UnitIsValid(targetEnemy) && !(HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth)) {
        ord = StormHeroAICreateOrder(player, c_Storm_AB_Move, 0);
        if (!UnitOrderIsValid(aiUnit, ord)) {
            return;
        }
        OrderSetTargetUnit(ord, targetEnemy);
        if (!UnitOrderIsValid(aiUnit, ord)) {
            return;
        }
        UnitIssueOrder(aiUnit, ord, c_orderQueueReplace);
    }
    else {
        // no target or we are in danger, so cancel
        HeroReleaseFromTactical(player);
        ord = StormHeroAICreateOrder(player, c_AB_BarbarianWhirlwindCancel, 0);
        if (!UnitOrderIsValid(aiUnit, ord)) {
            return;
        }
        HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null);
    }
}

//---------------------------------------------------------------------------------------------
bool BarbarianAncientSpear (int player, unit aiUnit, unitgroup scanGroup) {
    // Skillshot that drags Barbarian to the target it hits and that generates fury
    order spellOrd;
    order attackOrd;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;
    fixed range;


    spellOrd = StormHeroAICreateOrder(player, c_AB_BarbarianAncientSpear, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Don't jump into enemies if we are low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    if (PlayerHasTalent(player, c_BarbarianCompositeSpearTalent)) {
        range = 9.5;
    }
    else {
        range = 7.0;
    }

    // grab nearest enemy if they are low health
    query.lv_maxHealthPercent = 80;
    query.lv_maxDistance = range;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    query.lv_ignoreTargetsBehindGate = true;
    targetHero = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, UnitGetPosition(targetHero));
}

//---------------------------------------------------------------------------------------------
bool BarbarianLeap (int player, unit aiUnit, unitgroup scanGroup) {
   // Moves leaps to target dealing damage to it
    order spellOrd;
    order attackOrd;
    point retreatPos;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_BarbarianLeap, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Jump towards your spawn for safety if you are low health
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // Find position that is 6 units from current position towards the base
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, 8.0, null);

        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Don't jump into enemies if we are low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Find a target hero
    query.lv_maxHealthPercent = 70;
    query.lv_maxDistance = 9.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_ignoreTargetsBehindGate = true;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool BarbarianWrathOfTheBeserker (int player, unit aiUnit, unitgroup scanGroup) {
    // Increase attack speed and become invulnerable to CC effects
    order spellOrd;
    unit targetHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_BarbarianWrathOfTheBeserker, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Activate if there is a team fight
    if (!HaveBeenAttackedRecently(aiUnit) || !TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 6.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool BarbarianShotofFury (int player, unit aiUnit, unitgroup scanGroup) {
    // Instantly gain fury
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_BarbarianShotofFury, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkBarbarian (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UnitHasBehavior(aiUnit, c_BarbarianWhirlwindChannelBehavior) == true) {
        AIChannelBarbarianWhirlwind(player, aiUnit, scanGroup);
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && BarbarianLeap(player, aiUnit, scanGroup)) {
        return;
    }

    // whirlwind should be above other abilities because it has more requirements to cast and needs to be used more often (this only makes a tiny difference, but it's worth noting).
    if (BarbarianWhirlwind(player, aiUnit, scanGroup)) {
        return;
    }

    if (BarbarianShotofFury(player, aiUnit, scanGroup)) {
        return;
    }

    if (BarbarianBash(player, aiUnit, scanGroup)) {
        return;
    }

    if (BarbarianAncientSpear(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && BarbarianWrathOfTheBeserker(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Raynor Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_RaynorPenetratingRound     = "RaynorPenetratingRound";
const string c_AB_RaynorInspire              = "RaynorInspire";
const string c_AB_RaynorAdrenalineRush       = "RaynorAdrenalineRush";
const string c_AB_RaynorHyperion             = "RaynorHyperion";
const string c_AB_RaynorRaynorsBanshee       = "RaynorRaynorsBansheeTargeted";
const string c_AB_RaynorRaynorsBansheeRetarget = "RaynorRaynorsBansheeIssueOrder";

//---------------------------------------------------------------------------------------------
bool RaynorPenetratingRound (int player, unit aiUnit, unitgroup scanGroup) {
    // Skill-shot, high damage single target
    order spellOrd;
    unit targetEnemy;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_RaynorPenetratingRound, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        healthReq = 100.0;
    }
    else {
        healthReq = 60.0;
    }

    // Shoot any nearby enemy if there is a clear shot
    query.lv_maxHealthPercent = healthReq;
    query.lv_maxDistance = 8.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        // Shoot a minion if high mana
        if (energy < libAIAI_gv_aIHeroHighEnergyPercent) {
            return false;
        }
        query.lv_maxHealthPercent = 100;
        query.lv_minScore = 0;
        query.lv_lineOfSightRequired = c_Storm_AI_LOS_Optional;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool RaynorInspire (int player, unit aiUnit, unitgroup scanGroup) {
    // Buffs the attack and movement speed of all nearby allies
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_RaynorInspire, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use if attacked and allies nearby
    if (HaveBeenAttackedRecently(aiUnit) && (UnitGroupCount(AllyUnitsInArea(player, UnitGetPosition(aiUnit), 8), c_unitCountAlive) > 3) ) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
    }

    // Use if attacked and high energy
    if (HaveBeenAttackedRecently(aiUnit) && energy >= libAIAI_gv_aIHeroHighEnergyPercent) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
    }

    // Activate if there is a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 10.0)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
}

//---------------------------------------------------------------------------------------------
bool RaynorAdrenalineRush (int player, unit aiUnit, unitgroup scanGroup) {
    // Cast heal over time on self, autocast below 30% but saves 10 seconds on cooldown if manually cast before that
    order spellOrd;
    unit targetHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_RaynorAdrenalineRush, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) > 50.0) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool RaynorHyperion (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals damage to large area in front of hero
    order spellOrd;
    point center;

    spellOrd = StormHeroAICreateOrder(player, c_AB_RaynorHyperion, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    // Only use during a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 10.0)) {
        return false;
    }

    center = UnitGroupCenterOfGroup(scanGroup);

    if (!EnoughEnemiesInArea(scanGroup, center, 10, c_Storm_AI_AtLeast3Heroes, c_Storm_AI_AtLeast4Creeps, c_Storm_AI_AtLeast9Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, center);
}

//---------------------------------------------------------------------------------------------
bool RaynorRaynorsBansheeRetarget (int player, unit aiUnit, unitgroup scanGroup) {
    // Spawns two banshees that help raynor
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit target;

    spellOrd = StormHeroAICreateOrder(player, c_AB_RaynorRaynorsBansheeRetarget, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_maxDistance = 20.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    target = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (target == null) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, target, null);
}

//---------------------------------------------------------------------------------------------
bool RaynorRaynorsBanshee (int player, unit aiUnit, unitgroup scanGroup) {
    // Spawns two banshees that help raynor
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit targetHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_RaynorRaynorsBanshee, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return RaynorRaynorsBansheeRetarget(player, aiUnit, scanGroup);
    }

    // Only use during a team fight
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 10.0)) {
        return false;
    }

    query.lv_maxDistance = 10.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_minScore = c_Storm_AI_FullHeroScore;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (targetHero == null) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkRaynor (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RaynorAdrenalineRush(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (RaynorInspire(player, aiUnit, scanGroup)) {
        return;
    }

    if (RaynorPenetratingRound(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && RaynorHyperion(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && RaynorRaynorsBanshee(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Abathur Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_AbathurSymbiote               = "AbathurSymbiote";
const string c_AB_AbathurToxicNest              = "AbathurToxicNest";
const string c_AB_AbathurDeepTunnel             = "AbathurDeepTunnel";
const string c_AB_AbathurUltimateEvolution      = "AbathurUltimateEvolution";
const string c_AB_AbathurEvolveMonstrosity      = "AbathurEvolveMonstrosity";

const string c_AB_AbathurAssumingDirectControlCancel = "AbathurAssumingDirectControlCancel";

const string c_AbathurAssumingDirectControlBehavior       = "AssumingDirectControlBehavior";

//---------------------------------------------------------------------------------------------
bool AbathurSymbiote (int player, unit aiUnit, unitgroup scanGroup) {
    // Place a symbiote on an ally hero that can cast abilities
    order spellOrd;
    unit allyHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurSymbiote, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Don't start channeling if there is an enemy likely to attack Abathur
    if (EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 12.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast1Minion)) {
        return false;
    }

    allyHero = libAIAI_gf_HeroAIGetRandomAllyHeroInBattle(player, 500.0, false);
    if (!UnitIsValid(allyHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, allyHero, null);
}

//---------------------------------------------------------------------------------------------
bool AbathurToxicNest (int player, unit aiUnit, unitgroup scanGroup) {
    // Places a proximity bomb anywhere on the map
    order spellOrd;
    point contentionPoint;
    region nearContentionPoint;
    point position;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurToxicNest, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    contentionPoint = libAIAI_gf_HeroAIGetRandomContentionPoint(player, 70.0);
    if (contentionPoint == null) {
        return false;
    }

    nearContentionPoint = RegionCircle(contentionPoint, 4.0);
    position = RegionRandomPoint(nearContentionPoint);

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, position);
}

//---------------------------------------------------------------------------------------------
bool AbathurDeepTunnel (int player, unit aiUnit, unitgroup scanGroup) {
    // Teleport to the target position
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurDeepTunnel, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Currently unused by the Tactical AI
    return false;
}

//---------------------------------------------------------------------------------------------
bool AbathurUltimateEvolution (int player, unit aiUnit, unitgroup scanGroup) {
    // Create a copy of an ally hero
    order spellOrd;
    unit allyHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurUltimateEvolution, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    allyHero = libAIAI_gf_HeroAIGetRandomAllyHeroInBattle(player, 500.0, false);
    if (!UnitIsValid(allyHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, allyHero, null);
}

//---------------------------------------------------------------------------------------------
bool AbathurEvolveMonstrosity (int player, unit aiUnit, unitgroup scanGroup) {
    // Turns a minion or locust into a monster. Abathur can symbiote the monster  (can be used anywhere on the map)
    // For now I'll just try to use it to help an ally in battle  (similar logic to ultimate evolution)
    order spellOrd;
    unit allyHero;
    unit target;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurEvolveMonstrosity, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    allyHero = libAIAI_gf_HeroAIGetRandomAllyHeroInBattle(player, 500.0, true);
    if (!UnitIsValid(allyHero)) {
        return false;
    }

    target = FindClosestAllyMinion(UnitGetOwner(aiUnit), UnitGetPosition(allyHero), 6.0);
    if (!UnitIsValid(target)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, target, null);
}

//---------------------------------------------------------------------------------------------
void AIChannelAbathurAssumingDirectControl (int player, unit aiUnit, unitgroup scanGroup) {
    order cancelOrd;

    // Symbiote
    if (UnitIsValid(abathurSymbioteUnit[player - 1])) {
        cancelOrd = StormHeroAICreateOrder(player, c_AB_AbathurAssumingDirectControlCancel, 0);
        if (!UnitOrderIsValid(abathurSymbioteUnit[player - 1], cancelOrd)) {
            return;
        }

        if (HaveBeenAttackedRecently(aiUnit) || EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 10.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast1Minion))  {
            UnitIssueOrder(abathurSymbioteUnit[player - 1], cancelOrd, c_orderQueueReplace);
        }
    }

    // Ultimate evolution
    if (UnitIsValid(abathurUltimateEvolutionUnit[player - 1])) {
        // Hook it into the MinionAI if it has not been yet
        if (libAIAI_gf_MinionAIGetIndexForMinion(abathurUltimateEvolutionUnit[player - 1]) == 0) {
            libAIAI_gf_MinionAIStartMinionAISimple(abathurUltimateEvolutionUnit[player - 1]);
        }

        cancelOrd = StormHeroAICreateOrder(player, c_AB_AbathurAssumingDirectControlCancel, 0);
        if (!UnitOrderIsValid(abathurUltimateEvolutionUnit[player - 1], cancelOrd)) {
            return;
        }

        if (HaveBeenAttackedRecently(aiUnit))  {
            UnitIssueOrder(abathurUltimateEvolutionUnit[player - 1], cancelOrd, c_orderQueueReplace);
        }
    }
}

//---------------------------------------------------------------------------------------------
bool AbathurForceAssumingDirectControl (int player) {
    order cancelOrd;

    // Symbiote
    if (UnitIsValid(abathurSymbioteUnit[player - 1])) {
        cancelOrd = StormHeroAICreateOrder(player, c_AB_AbathurAssumingDirectControlCancel, 0);
        if (!UnitOrderIsValid(abathurSymbioteUnit[player - 1], cancelOrd)) {
            return false;
        }

        return UnitIssueOrder(abathurSymbioteUnit[player - 1], cancelOrd, c_orderQueueReplace);
    }

    // Ultimate evolution
    if (UnitIsValid(abathurUltimateEvolutionUnit[player - 1])) {
        // Hook it into the MinionAI if it has not been yet
        if (libAIAI_gf_MinionAIGetIndexForMinion(abathurUltimateEvolutionUnit[player - 1]) == 0) {
            libAIAI_gf_MinionAIStartMinionAISimple(abathurUltimateEvolutionUnit[player - 1]);
        }

        cancelOrd = StormHeroAICreateOrder(player, c_AB_AbathurAssumingDirectControlCancel, 0);
        if (!UnitOrderIsValid(abathurUltimateEvolutionUnit[player - 1], cancelOrd)) {
            return false;
        }

        return UnitIssueOrder(abathurUltimateEvolutionUnit[player - 1], cancelOrd, c_orderQueueReplace);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkAbathur (int player, unit aiUnit, unitgroup scanGroup) {
    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UnitHasBehavior(aiUnit, c_AbathurAssumingDirectControlBehavior)) {
        AIChannelAbathurAssumingDirectControl(player, aiUnit, scanGroup);
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (AbathurToxicNest(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && AbathurUltimateEvolution(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && AbathurEvolveMonstrosity(player, aiUnit, scanGroup)) {
        return;
    }

    if (AbathurSymbiote(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Illidan Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_IllidanDive                       = "IllidanDive";
const string c_AB_IllidanSweepingStrike             = "IllidanSweepingStrike";
const string c_AB_IllidanEvasion                    = "IllidanEvasion";
const string c_AB_IllidanTheHunt                    = "IllidanTheHunt";
const string c_AB_IllidanMetamorphosisTargeted      = "IllidanMetamorphosisTargeted";

const fixed c_AB_IllidanDiveRange                                   = 6.5;
const string c_AB_IllidanMasteryFriendOrFoeDive                     = "IllidanMasteryFriendOrFoeDive";
const fixed c_AB_IllidanMasteryFriendOrFoeDiveRangeModifier         = 2.0;

const fixed c_AB_IllidanSweepingStrikeRange                         = 5.5;
const string c_AB_IllidanMasteryFelReachSweepingStrike              = "IllidanMasteryFelReachSweepingStrike";
const fixed c_AB_IllidanMasteryFelReachSweepingStrikeRangeModifier  = 1.0;

const fixed c_AB_IllidanTheHuntRange                                = 45.0;
const fixed c_AB_IllidanTheHuntMinDistance                          = 8.0;
const string c_AB_IllidanMasteryNowhereToHideTheHunt                = "IllidanMasteryNowhereToHideTheHunt";

const fixed c_AB_IllidanMetamorphosisRange                          = 12.0;

const string c_BladesOfAzzinothItem                             = "IllidanBladesOfAzzinoth";

//---------------------------------------------------------------------------------------------
bool IllidanDive (int player, unit aiUnit, unitgroup scanGroup) {
    // Dives at the target and flips to the other side, does a small amount of damage and slows the target
    order spellOrd;
    order attackOrd;
    unitgroup nearbyAllies;
    unit targetUnit;
    point retreatPos;
    fixed abilityRange;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_IllidanDive, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    abilityRange = c_AB_IllidanDiveRange;

    // Dive an ally if Illidan is attacked and has the Friend & Foe talent.
    if (PlayerHasTalent(player, c_AB_IllidanMasteryFriendOrFoeDive)) {
        abilityRange += c_AB_IllidanMasteryFriendOrFoeDiveRangeModifier;
        if (HaveBeenAttackedRecently(aiUnit) || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
            // We are taking damage, so jump to an ally player that is closer to our retreat position than us.
            retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, abilityRange, null);
            nearbyAllies = AllyHeroUnitsInArea(player, UnitGetPosition(aiUnit), abilityRange);
            query.lv_distanceFactor = c_Storm_AI_StronglyPreferDistantTargets;
            query.lv_maxDistance = abilityRange;
            targetUnit = FindBestUnit(nearbyAllies, scanGroup, aiUnit, query);
            if (targetUnit != null) {
                return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetUnit, null);
            }
        }
    }

    // Only use if we have enough health charge forward
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // Only use on a weakened enemy hero
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = abilityRange;
    query.lv_ignoreTargetsBehindGate = c_Storm_AI_LOS_Required;
    targetUnit = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetUnit)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetUnit, null);
}

//---------------------------------------------------------------------------------------------
bool IllidanSweepingStrike (int player, unit aiUnit, unitgroup scanGroup) {
    // Dashes to a point and damages units on the way + gives Illidan a minor attack boost
    // Three uses for now:
    //   Run away to live
    //   Catch a weak enemy hero
    //   Damage a group of enemies
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    point retreatPos;
    point center;
    fixed abilityRange;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_IllidanSweepingStrike, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    abilityRange = c_AB_IllidanSweepingStrikeRange;
    if (PlayerHasTalent(player, c_AB_IllidanMasteryFelReachSweepingStrike)) {
        abilityRange += c_AB_IllidanMasteryFelReachSweepingStrikeRangeModifier;
    }

    // Retreat if you have low health
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // Dash back to retreat to safety
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, abilityRange, null);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    // Only use if we have enough health charge forward
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    // Cast on a weak enemy hero
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = abilityRange;
    query.lv_ignoreTargetsBehindGate = c_Storm_AI_LOS_Required;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(targetEnemy)) {
        attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
        if (!UnitOrderIsValid(aiUnit, attackOrd)) {
            return false;
        }
        return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, UnitGetPosition(targetEnemy));
    }

    // Or cast on a group of enemies
    center = UnitGroupCenterOfGroup(UnitsInArea(scanGroup, UnitGetPosition(aiUnit), abilityRange));
    if (!EnoughEnemiesInArea(scanGroup, center, abilityRange, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast4Minions)) {
        return false;
    }
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, center);
}

//---------------------------------------------------------------------------------------------
bool IllidanEvasion (int player, unit aiUnit, unitgroup scanGroup) {
    // Evasion has a short duration and cooldown, so we should use it relatively frequently
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_IllidanEvasion, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Use it if we are being attacked
    if (HaveBeenAttackedRecently(aiUnit)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool IllidanTheHunt (int player, unit aiUnit, unitgroup scanGroup) {
    // Long range dash to target unit that deals damage when hits
    order spellOrd;
    order attackOrd;
    unit targetEnemy;

    Storm_AI_TargetQueryOptions query;
    int enemyHeroIndex;
    int numEnemyHeroes;
    point targetPosition;

    spellOrd = StormHeroAICreateOrder(player, c_AB_IllidanTheHunt, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Only use if we have enough health charge forward
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }

    // When Illidan has the level 20 talent, cast it any time Illidan sees a favorable teamfight with a weakened enemy
    if (PlayerHasTalent(player, c_AB_IllidanMasteryNowhereToHideTheHunt)) {
        numEnemyHeroes = UnitGroupCount(libAIAI_gv_aIHeroes[player].lv_visibleEnemyHeroes, c_unitCountAll);
        for (enemyHeroIndex = 1; enemyHeroIndex <= numEnemyHeroes; enemyHeroIndex += 1){
            targetEnemy = UnitGroupUnit(libAIAI_gv_aIHeroes[player].lv_visibleEnemyHeroes, enemyHeroIndex);
            if (UnitIsValid(targetEnemy)) {
                targetPosition = UnitGetPosition(targetEnemy);
                if (DistanceBetweenPoints(UnitGetPosition(aiUnit), targetPosition) > c_AB_IllidanTheHuntMinDistance) {
                    if((CountTeamOutnumberedBy(player, scanGroup, targetPosition, c_Storm_AI_DefaultTeamfightRange) <= 2) || (libAIAI_gv_heroAITeamData[libAIAI_gf_HeroAIGetAllyTeamIndex(player)].lv_numberOfMissingEnemies <= 3)) {
                        if(UnitGetPropertyFixed(targetEnemy, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroLowHealthPercent) {
                            return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
                        }
                    }
                }
            }
        }
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    // Only use if we'll travel a decent distance
    query.lv_minDistance = c_AB_IllidanTheHuntMinDistance;
    query.lv_maxDistance = c_AB_IllidanTheHuntRange;
    query.lv_ignoreTargetsBehindGate = c_Storm_AI_LOS_Required;
    // Find a target hero
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }
    if((CountTeamOutnumberedBy(player, scanGroup, UnitGetPosition(targetEnemy), c_Storm_AI_DefaultTeamfightRange) >= 2) || (libAIAI_gv_heroAITeamData[libAIAI_gf_HeroAIGetAllyTeamIndex(player)].lv_numberOfMissingEnemies >= 3)) {
        return false;
    }
    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool IllidanMetamorphosisTargeted (int player, unit aiUnit, unitgroup scanGroup) {
    // Transform and launch to target location. Deals AoE damage to target location and gives attack and movements speed buff.
    point center;
    point retreatPos;
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_IllidanMetamorphosisTargeted, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }
    // Use to run away
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        retreatPos = libAIAI_gf_HeroAIGetRetreatPosition(player, c_AB_IllidanMetamorphosisRange, null);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, retreatPos);
    }

    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), c_AB_IllidanMetamorphosisRange)) {
        return false;
    }

    // Only use if we have enough health charge forward
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    // Cast on a weak enemy hero
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = c_AB_IllidanMetamorphosisRange;
    query.lv_ignoreTargetsBehindGate = c_Storm_AI_LOS_Required;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(targetEnemy)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
    }

    // Or cast on a group of enemies
    center = UnitGroupCenterOfGroup(UnitGroupFilterHeroes(UnitsInArea(scanGroup, UnitGetPosition(aiUnit), c_AB_IllidanMetamorphosisRange)));
    if (!EnoughEnemiesInArea(scanGroup, center, c_AB_IllidanMetamorphosisRange, c_Storm_AI_AtLeast2Heroes, c_Storm_AI_AtLeast4Creeps, c_Storm_AI_AtLeast6Minions)) {
        return false;
    }
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, center);
}

//----------------------------------------------------------------------------------------------
bool IllidanOffensiveItemCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    // Increases Illidan's attack damage for a short duration
    if (itemType == c_BladesOfAzzinothItem) {
        // Only use if we have enough health charge forward
        if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
            return false;
        }

        query.lv_healthFactor = c_Storm_AI_PreferCloserTargets;
        query.lv_maxDistance = c_AB_IllidanDiveRange;
        targetEnemy = FindBestHero(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
        return UnitIssueOrder(aiUnit, ord, c_orderQueueAddToFront);
    }
    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkIllidan (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (IllidanDive(player, aiUnit, scanGroup)) {
        return;
    }

    if (IllidanSweepingStrike(player, aiUnit, scanGroup)) {
        return;
    }

    if (IllidanEvasion(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player)) {
        if(IllidanMetamorphosisTargeted(player, aiUnit, scanGroup)) {
            return;
        }
        if (IllidanTheHunt(player, aiUnit, scanGroup)) {
            return;
        }
    }

    if (UseItem(player, aiUnit, scanGroup, IllidanOffensiveItemCallback)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Abathur Symbiote Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_AbathurSymbioteStab           = "AbathurSymbioteStab";
const string c_AB_AbathurSymbioteSpikeBurst     = "AbathurSymbioteSpikeBurst";
const string c_AB_AbathurSymbioteCarapace       = "AbathurSymbioteCarapace";

//---------------------------------------------------------------------------------------------
bool AbathurSymbioteStab (int player, unit aiUnit, unitgroup scanGroup) {
    // Skillshot damage
    order spellOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurSymbioteStab, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Shoot any nearby enemy if there is a clear shot
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = 8.0;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        query.lv_lineOfSightRequired = c_Storm_AI_LOS_Optional;
        targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
        if (!UnitIsValid(targetEnemy)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool AbathurSymbioteSpikeBurst (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE damage
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurSymbioteSpikeBurst, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 4.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
}

//---------------------------------------------------------------------------------------------
bool AbathurSymbioteCarapace (int player, unit aiUnit, unitgroup scanGroup) {
    // Places a shield on the host
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_AbathurSymbioteCarapace, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 8.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast2Minions)) {
        return false;
    }

    // Cast when off cooldown and enemies are nearby
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkAbathurSymbiote (int player, unit aiUnit, unitgroup scanGroup) {
    if (player > libCore_gv_bALMaxPlayers) {
        return;
    }

    abathurSymbioteUnit[player - 1] = aiUnit;

    // Only control if it is an AI player
    if (libAIAI_gf_HeroAIIsAIEnabledForPlayer(player) == false) {
        return;
    }

    if (AbathurSymbioteCarapace(player, aiUnit, scanGroup)) {
        return;
    }

    if (AbathurSymbioteSpikeBurst(player, aiUnit, scanGroup)) {
        return;
    }

    if (AbathurSymbioteStab(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Li Li Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_LiLiHealingBrew       = "LiLiHealingBrew";
const string c_AB_LiLiCloudSerpent      = "LiLiCloudSerpent";
const string c_AB_LiLiBlindingWind      = "LiLiBlindingWind";
const string c_AB_LiLiJugof1000Cups     = "LiLiJugof1000Cups";
const string c_AB_LiLiWaterDragon       = "LiLiWaterDragon";
const string c_LiliProTossTalent        = "LiLiMasteryHealingBrewProToss";

//---------------------------------------------------------------------------------------------
bool LiLiHealingBrew (int player, unit aiUnit, unitgroup scanGroup) {
    // Heals a lowest health nearby ally, prefers heroes
    order ord;
    unit targetUnit;
    fixed range;

    ord = StormHeroAICreateOrder(player, c_AB_LiLiHealingBrew, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    if (PlayerHasTalent(player, c_LiliProTossTalent)) {
        range = 9.0;
    }
    else {
        range = 7.0;
    }
    // If nearby ally hero is injured cast the ability
    targetUnit = FindBestHealTarget(player, aiUnit, range, true, false);
    if (UnitIsValid(targetUnit)) {
        if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null)) {
            return true;
        }
    }
    return false;
}

//---------------------------------------------------------------------------------------------
bool LiLiCloudSerpent (int player, unit aiUnit, unitgroup scanGroup) {
    // buffs an ally hero with a cloud serpent that attacks
    //   for now casting on a high hp hero if we have plenty of mana
    order spellOrd;
    unit targetHero;
    point targetPos;
    fixed healthReq;

    spellOrd = StormHeroAICreateOrder(player, c_AB_LiLiCloudSerpent, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // only cast if we have high mana, otherwise save for heals
    if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) < libAIAI_gv_aIHeroMediumEnergyPercent) {
        return false;
    }

    // buff nearby ally hero
    targetHero = FindStrongestNearbyAllyHero(player, aiUnit, 7.0, 55.0, false);
    if (!UnitIsValid(targetHero)) {
        return false;
    }
        // only cast if there are nearby enemies
    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(targetHero), 8.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetHero, null);
}

//---------------------------------------------------------------------------------------------
bool LiLiBlindingWind (int player, unit aiUnit, unitgroup scanGroup) {
    // Damages and blinds nearby enemy heroes
    //    Use if we're low on health, in a team fight or, trying to kill a hero
    order spellOrd;
    fixed healthPercent = 75;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_LiLiBlindingWind, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Always cast while retreating from attacker
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        healthPercent = 100.0;
    }

    // Always cast if there is a team fight
    if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 6.0)) {
        healthPercent = 100.0;
    }

    // Always cast if we have high mana
    if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) >= libAIAI_gv_aIHeroHighEnergyPercent) {
        healthPercent = 100.0;
    }

    query.lv_maxDistance = 8.0;
    query.lv_maxHealthPercent = healthPercent;
    targetHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool LiLiJugof1000Cups (int player, unit aiUnit, unitgroup scanGroup) {
    // Heals all nearby allies, use if any ally is really hurt or if we're in a team fight
    order ord;
    unit targetUnit;
    fixed targetHealth;

    ord = StormHeroAICreateOrder(player, c_AB_LiLiJugof1000Cups, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    // Activate if there is a team fight
    if (TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 6.0)) {
        // And any damaged ally hero
        targetUnit = FindWeakestNearbyAllyHero(player, aiUnit, 10.0, 70.0, -1.0, false);
        if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null)) {
            return true;
        }
    }

    // Or if we find a nearby weak ally hero that is under attacked
    targetUnit = FindWeakestNearbyAllyHero(player, aiUnit, 10.0, 40.0, -1.0, false);
    if (UnitIsValid(targetUnit)) {
        if (HaveBeenAttackedRecently(targetUnit)) {
            if (HeroIssueOrder(player, aiUnit, ord, null, c_orderQueueAddToFront, null, null)) {
                return true;
            }
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool LiLiWaterDragon (int player, unit aiUnit, unitgroup scanGroup) {
    // Summons a dragon that charges the nearest enemy hero after 3 seconds and does aoe damage and slows
    order spellOrd;
    fixed healthPercent = 50;
    unit targetHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_LiLiWaterDragon, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Always cast if there is a team fight
    if (HaveBeenAttackedRecently(aiUnit) && TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 9.0)) {
        healthPercent = 100.0;
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = 11.0;
    query.lv_maxHealthPercent = healthPercent;
    targetHero = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkLiLi (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && LiLiJugof1000Cups(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (LiLiHealingBrew(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (LiLiBlindingWind(player, aiUnit, scanGroup)) {
        return;
    }

    if (LiLiCloudSerpent(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && LiLiWaterDragon(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}


//---------------------------------------------------------------------------------------------
// Vehicle Dragon Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_VehicleDragonFireBreath   = "VehicleDragonFireBreath";
const string c_AB_VehicleDragonDragonRoar   = "VehicleDragonDragonRoar";
const string c_AB_VehicleDragonPunt         = "VehicleDragonPunt";

//---------------------------------------------------------------------------------------------
bool VehicleDragonFireBreath (int player, unit aiUnit, unitgroup scanGroup) {
    // Deals damage to all enemies in a cone
    order spellOrd;
    unitgroup nearbyEnemies;
    unit targetEnemy;
    point center;
    int minEnemyEval;

    spellOrd = StormHeroAICreateOrder(player, c_AB_VehicleDragonFireBreath, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast on a weak enemy hero
    targetEnemy = FindClosestWeakHero(scanGroup, aiUnit, 0.0, 9.0, 40.0, -1, -1, c_Storm_AI_LOS_Optional);
    if (UnitIsValid(targetEnemy)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
    }

    // Cast if there is a large number of enemies
    nearbyEnemies = UnitsInArea(scanGroup, UnitGetPosition(aiUnit), 9.0);
    center = UnitGroupCenterOfGroup(nearbyEnemies);

    if (CountEnemiesInArea(nearbyEnemies, center, 4.0, 3, 1) < 3) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, center);
}

//---------------------------------------------------------------------------------------------
bool VehicleDragonDragonRoar (int player, unit aiUnit, unitgroup scanGroup) {
    // Heals and buffs nearby allies
    order spellOrd;
    unit nearbyHero;

    spellOrd = StormHeroAICreateOrder(player, c_AB_VehicleDragonDragonRoar, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Always cast to at least heal yourself
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
}

//---------------------------------------------------------------------------------------------
bool VehicleDragonPunt (int player, unit aiUnit, unitgroup scanGroup) {
    // Charges up and then punts target back a large distance
    order spellOrd;
    unit nearbyHero;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_VehicleDragonPunt, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Cast on a closest hero that isn't on the other side of a gate
    query.lv_maxDistance = 7.0;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_ignoreTargetsBehindGate = true;
    nearbyHero = FindBestHero(scanGroup, aiUnit, query);
    if (!UnitIsValid(nearbyHero)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, nearbyHero, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkVehicleDragon (int player, unit aiUnit, unitgroup scanGroup) {
    // Make sure it is a computer hero driving the vehicle
    if (libAIAI_gf_HeroAIIsAIEnabledForPlayer(player) == false) {
        return;
    }

    if (VehicleDragonDragonRoar(player, aiUnit, scanGroup)) {
        return;
    }

    if (VehicleDragonFireBreath(player, aiUnit, scanGroup)) {
        return;
    }

    if (VehicleDragonPunt(player, aiUnit, scanGroup)) {
        return;
    }
}
