//---------------------------------------------------------------------------------------------
// Butcher Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_ButcherHamstring             = "ButcherHamstring";
const string c_AB_ButcherButchersBrand             = "ButcherButchersBrand";
const string c_AB_ButcherRuthlessOnslaught              = "ButcherRuthlessOnslaught";
const string c_AB_ButcherLambToTheSlaughter   = "ButcherLambToTheSlaughter";
const string c_AB_ButcherFurnaceBlast          = "ButcherFurnaceBlast";
const string c_ButcherFlailAxeTalent       = "ButcherMasteryHamstringFlailAxe";

//---------------------------------------------------------------------------------------------
bool ButcherHamstring (int player, unit aiUnit, unitgroup scanGroup) {
    // damages enemies in a small range in front and slows them
    order spellOrd;
    unit targetHero;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    point inFrontofHero;
    fixed minEnemyEval;
    fixed minHeroEval;
    Storm_AI_TargetQueryOptions query;
    fixed range;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ButcherHamstring, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
  
      if (PlayerHasTalent(player, c_ButcherFlailAxeTalent)) {
        range = 9.0;
    }
    else {
        range = 6.5;
    }
    // Cast on a weak enemy hero
    query.lv_maxDistance = range;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    targetHero = FindBestHero(scanGroup, aiUnit, query);

    if (UnitIsValid(targetHero)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetHero));
    }

    // Cast on a group of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minEnemyEval = 2;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minEnemyEval = 4;
    }
    else {
        minEnemyEval = 6;
    }
    minHeroEval = (minEnemyEval/2);
    inFrontofHero = PointWithOffsetPolar(UnitGetPosition(aiUnit), 3.0, UnitGetFacing(aiUnit));

    if (!EnoughEnemiesInArea(scanGroup, inFrontofHero, 2.5, minHeroEval, minEnemyEval, minEnemyEval)) {
        return false;
    }
    
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, inFrontofHero);
}

//---------------------------------------------------------------------------------------------
bool ButcherButchersBrand (int player, unit aiUnit, unitgroup scanGroup) {
    // Small damage and grants lifesteal to future attacks on that target    
    order spellOrd;
    order attackOrd;
    unit targetEnemy;
    fixed energy;
    fixed life;
    Storm_AI_TargetQueryOptions query;

    life = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    // Only cast this if we aren't at high health
   if (life > libAIAI_gv_aIHeroHighHealthPercent) {
        return false;
    }
    
    spellOrd = StormHeroAICreateOrder(player, c_AB_ButcherButchersBrand, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    
    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        return false;
    }
  
    // Cast on the weakest enemy hero in range
    query.lv_maxDistance = 3.0;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (UnitIsValid(targetEnemy)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
    }

    // If high energy and not full health, can cast on a full health minion instead
    energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);   
    if (energy < libAIAI_gv_aIHeroHighEnergyPercent|| life < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_minHealthPercent = libAIAI_gv_aIHeroHighHealthPercent; // we want to use it on mostly undamaged minions
    query.lv_maxHealthPercent = 100.0;
    query.lv_healthFactor = c_Storm_AI_PreferHealthyTargets;
    targetEnemy = FindBestMinion(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }
    
    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetEnemy, null);
}

//---------------------------------------------------------------------------------------------
bool ButcherRuthlessOnslaught (int player, unit aiUnit, unitgroup scanGroup) {
    // charges at enemy, stuns them for 1 second if he reaches them    
    unit targetHero;
    order spellOrd;
    order attackOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed health;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ButcherRuthlessOnslaught, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        attackOrd = null;
    }
    
    // Don't jump into battle with low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) { 
        return false;
    }

    // Cast if enemy health is low enough
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        health = 90;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        health = 60;
    }
    else {
        health = 40;
    }

    // Find a target hero
    query.lv_maxDistance = 12.0;
    query.lv_minDistance = 3.0;
    query.lv_maxHealthPercent = health;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetHero = FindBestHero(scanGroup, aiUnit, query);    

    if (!UnitIsValid(targetHero)) { 
        return false;
    }

    // Don't charge heroes under tower protection. We add some extra distance to cope with the target running towards the tower and gaining protection as we charge in.
    if (libAIAI_gf_HeroAIUnitProtectedByTower(targetHero, libAIAI_gv_aIHeroFarFromTowerDistance + 2.5) == true) { 
        return false;
    }

    if (HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, targetHero, null)) {
        HeroFocusOnHero(player, targetHero);
        return true;
    }
    return false;
}

//---------------------------------------------------------------------------------------------
bool ButcherLambToTheSlaughter (int player, unit aiUnit, unitgroup scanGroup) {
    // Chain an enemy hero near a point in place for 4 seconds.
    unit targetHero;
    order spellOrd;
    order attackOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed health;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ButcherLambToTheSlaughter, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        attackOrd = null;
    }
    
    // Don't spend the ultimate if we won't follow up
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) { 
        return false;
    }

    // Cast if enemy health is low enough
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        // more likely to follow up if high energy
        health = 80;
    }
    else {
        health = 60;
    }

    // Find a target hero 
    query.lv_maxDistance = 8.0;
    query.lv_maxHealthPercent = health;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetHero = FindBestHero(scanGroup, aiUnit, query);   

    if (!UnitIsValid(targetHero)) { 
        return false;
    }

    if (HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueAddToFront, null, UnitGetPosition(targetHero))) {
        HeroFocusOnHero(player, targetHero);
        return true;
    }
    return false;
}

//---------------------------------------------------------------------------------------------
bool ButcherFurnaceBlast (int player, unit aiUnit, unitgroup scanGroup) {
    // After 3 seconds explodes in an area around the butcher
    order spellOrd;
    unit nearbyHero;
    Storm_AI_TargetQueryOptions query;
    
    spellOrd = StormHeroAICreateOrder(player, c_AB_ButcherFurnaceBlast, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    
    // Cast if there is a weak hero
    query.lv_maxDistance = 3.5;
    query.lv_maxHealthPercent = 40.0;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    nearbyHero = FindBestHero(scanGroup, aiUnit, query); 
   
    if (UnitIsValid(nearbyHero)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }

    // Or a large number of enemies nearby
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 3.5)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkButcher (int player, unit aiUnit, unitgroup scanGroup) {
    
    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }
    
    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (ButcherRuthlessOnslaught(player, aiUnit, scanGroup)) {
        return;
    }

    if (ButcherButchersBrand(player, aiUnit, scanGroup)) {
        return;
    }

    if (ButcherHamstring(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && ButcherLambToTheSlaughter(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && ButcherFurnaceBlast(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }
    
    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}
