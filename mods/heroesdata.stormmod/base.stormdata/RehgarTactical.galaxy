//---------------------------------------------------------------------------------------------
// Rehgar Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_RehgarChainHeal                = "RehgarChainHeal";
const string c_AB_RehgarLightningShield             = "RehgarLightningShield";
const string c_AB_RehgarEarthbindTotem              = "RehgarEarthbindTotem";
const string c_AB_RehgarBloodlust                   = "RehgarBloodlust";
const string c_AB_RehgarAncestralHealing            = "RehgarAncestralHealing";
const string c_AB_RehgarGhostWolfActivate           = "RehgarGhostWolfActivate";

const fixed c_AB_RehgarChainHealRange = 8.0;

const fixed c_AB_RehgarLightningShieldRange = 7.0;
//This is about 2 more than the actual Lightning Shield Radius, but allows us to check for enemies we expect to come into contact with soon
const fixed c_AB_RehgarLightningShieldRadius = 5.0;

//Sticking to lead by 1m
const fixed c_AB_RehgarEarthbindTotemRange = 4.5;

const fixed c_AB_RehgarBloodlustRadius = 8.0;

const fixed c_AB_RehgarAncestralHealingRange = 6.0;

const string c_AB_RehgarColossalTotemTalent = "RehgarMasteryColossalTotem";
const fixed c_AB_RehgarColossalTotemMultiplier = 1.5;

const string c_AB_RehgarMasteryElectricChargeTalent = "RehgarMasteryElectricCharge";
const fixed c_AB_RehgarElectricChargeRadiusModifier = 0.8125;

//---------------------------------------------------------------------------------------------
// Turn into wolf and give bonus damage on next attack, always want to use if possible.
//---------------------------------------------------------------------------------------------
bool RehgarGhostWolfActivate (int player, unit aiUnit, unitgroup scanGroup) {
    // Turns into wolf with increased movement speed.
    // Used to flee
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_RehgarGhostWolfActivate, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool RehgarChainHeal (int player, unit aiUnit, unitgroup scanGroup) {
    // Targetted shot that heals ally and neighboring allies
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unitgroup nearbyAllies;
    unit targetAlly;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_RehgarChainHeal, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    query.lv_maxDistance = c_AB_RehgarChainHealRange;
    // Restrict as energy decreases, start at mid-range
    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }
    
    // Cast on self if fitting energy and health requirements
    if(UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < query.lv_maxHealthPercent) {
        return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, aiUnit, null);
    }

    // Cast on a weak ally hero
    nearbyAllies = AllyHeroUnitsInArea(player, UnitGetPosition(aiUnit), c_AB_RehgarChainHealRange);
    targetAlly = FindBestUnit(nearbyAllies, scanGroup, aiUnit, query);
    if (targetAlly != null) {
        return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetAlly, null);
    }

    // If not high energy, don't target creep
    if (energy <= libAIAI_gv_aIHeroHighEnergyPercent) {
        return false;
    }
    // Target creep instead
    targetAlly = FindBestUnit(UnitGroupFilterAggroCreeps(AllyUnitsInArea(player, UnitGetPosition(aiUnit), c_AB_RehgarChainHealRange)), scanGroup, aiUnit, query);

    if (targetAlly == null) {
        return false;
    }

    return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetAlly, null);
}

//---------------------------------------------------------------------------------------------
bool RehgarLightningShield (int player, unit aiUnit, unitgroup scanGroup) {
    // Targetted shot that does PB-AOE damage to all enemies in a radius around the target
    order spellOrd;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    unit targetAlly;
    unit allyHero;
    fixed abilityRadius;
    int allyHeroIndex;
    int numAllies;
    unitgroup allyUnitGroup;
    
    spellOrd = StormHeroAICreateOrder(player, c_AB_RehgarLightningShield, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    abilityRadius = c_AB_RehgarLightningShieldRadius;
    if (PlayerHasTalent(player, c_AB_RehgarMasteryElectricChargeTalent)) {
        abilityRadius += c_AB_RehgarElectricChargeRadiusModifier;
    }
    // Use on others if mid-range energy, and self if low
    // Iterate through nearby allies and cast if one is found with enough enemies surrounding it
    if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        allyUnitGroup = AllyHeroUnitsInArea(player, UnitGetPosition(aiUnit), c_AB_RehgarLightningShieldRange);
        numAllies = CountPlayersInUnitGroup(allyUnitGroup);
        for (allyHeroIndex = 1; allyHeroIndex <= numAllies; allyHeroIndex += 1) {
            allyHero = UnitGroupUnit(allyUnitGroup, allyHeroIndex);
            if (UnitIsValid(allyHero)) {
                if (AnyEnemiesInArea(scanGroup, UnitGetPosition(allyHero), abilityRadius)) {
                   targetAlly = allyHero;
                }
            }
        }
    }
    else if (HaveBeenAttackedRecently(aiUnit) && AnyEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), abilityRadius)){
        targetAlly = aiUnit;
    }
    
    if (targetAlly == null) {
        return false;
    }

    return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetAlly, null);
}

//---------------------------------------------------------------------------------------------
bool RehgarEarthbindTotem (int player, unit aiUnit, unitgroup scanGroup) {
    // Places totem that slows enemy movement in radius

    // Two uses for now:
    //   Run away to live
    //   Catch a fleeing enemy hero
    order spellOrd;
    unit targetEnemy;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    Storm_AI_TargetQueryOptions query;
    fixed minHeroes;
    fixed abilityRange;

    spellOrd = StormHeroAICreateOrder(player, c_AB_RehgarEarthbindTotem, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    abilityRange = c_AB_RehgarEarthbindTotemRange;
    if (PlayerHasTalent(player, c_AB_RehgarColossalTotemTalent)) {
        abilityRange *= c_AB_RehgarColossalTotemMultiplier;
    }
    // Place totem if you have low health
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // Charge back to retreat to safety
        return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(aiUnit));
    }

    // Find a target hero 
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_maxDistance = abilityRange;
    // In keeping with previous implementation, base usage on combo of energy available and health of target
    if (energy > libAIAI_gv_aIHeroMediumEnergyPercent) {
        query.lv_maxHealthPercent = 100.0;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    }
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);
    if (targetEnemy == null) {
        return false;
    }

    return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool RehgarBloodlust (int player, unit aiUnit, unitgroup scanGroup) {
    // PB-AOE that increases attack speed and movement for neighboring allies in a large radius

    // Two uses for now:
    //   Run away to live
    //   Team fight
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_RehgarBloodlust, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // If you have low health, use to flee
    if (HaveBeenAttackedRecently(aiUnit) && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        // Charge back to retreat to safety
        return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
    }
    // Activate if there is a team fight
    if (!TeamFightInAreaWithEnemyRadius(player, scanGroup, UnitGetPosition(aiUnit), c_Storm_AI_DefaultTeamfightRange, c_AB_RehgarBloodlustRadius)) {
        return false;
    }

    return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool RehgarAncestralHealing (int player, unit aiUnit, unitgroup scanGroup) {
    // Targetted shot that heals target
    order spellOrd;
    unit targetAlly;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_RehgarAncestralHealing, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_healthFactor = c_Storm_AI_StronglyPreferUnhealthyTargets;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
    query.lv_maxDistance = c_AB_RehgarAncestralHealingRange;
    // Cast on a weak ally hero
    // Replace with best
    targetAlly = FindBestUnit(AllyHeroUnitsInArea(player, UnitGetPosition(aiUnit), c_AB_RehgarAncestralHealingRange), scanGroup, aiUnit, query);
    if (targetAlly == null) {
        return false;
    }

    return HeroIssueOrder (player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetAlly, null);
}

//---------------------------------------------------------------------------------------------
void AIThinkRehgar (int player, unit aiUnit, unitgroup scanGroup) {
    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }
    // No need to check the return value, as we want to perform other actions in easy AI mode. 
    RehgarGhostWolfActivate(player, aiUnit, scanGroup);

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && RehgarAncestralHealing(player, aiUnit, scanGroup)) {
        return;
    }

    if (RehgarChainHeal(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }
    
    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && RehgarBloodlust(player, aiUnit, scanGroup)) {
        return;
    }
    
    if (RehgarLightningShield(player, aiUnit, scanGroup)) {
        return;
    }

    if (RehgarEarthbindTotem(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}
