//---------------------------------------------------------------------------------------------
// Medic Tactical
//---------------------------------------------------------------------------------------------
// Abilities
const string c_AB_MedicHealingBeam              = "MedicHealingBeam";
const string c_AB_MedicRedirectHealingBeam      = "MedicRedirectHealingBeam";
const string c_AB_MedicDisplacementGrenade      = "MedicDisplacementGrenade";
const string c_AB_MedicSafeguard                = "MedicSafeguard";
const string c_AB_MedicStimDrone                = "MedicStimDrone";
const string c_AB_MedicMedivacDropship          = "MedicMedivacDropship";
const string c_AB_MedicMedivacDropshipDepart    = "MedicMedivacDropshipDepart";
// Range constants
// Medic heal range is artificially bigger so that she will move and seek out people to heal.
const fixed c_MedicHealRange                    = 8.0;
const fixed c_MedicChannelHealRange             = 9.0;
const fixed c_MedicSafeguardsRange              = 10.0;
const fixed c_MedicDisplacementGrenadeRange     = 12.0;
const fixed c_MedicDisplacementGrenadeRadius    = 2.25;
const fixed c_MedicStimDroneRange               = 7.0;
const fixed c_MedicMedivacMinRange              = 11.0;
const fixed c_MedicMedivacMaxRange              = 75.0;
// behavior and talent constants
const string c_MedicCastHealingBeamBehavior     = "MedicCastingHealingBeamBuff";
const string c_MedicDropshipAcceptingPassengers = "MedicMedivacDropshipAcceptingPassengers";
const string c_MedicBioshieldTalent             = "MedicBioshield";
// Current heal targets.
unit[libCore_gv_bALMaxPlayers + 1] g_currentMedicBeamTarget;
// Current Displacement Grenade target
unit[libCore_gv_bALMaxPlayers + 1] g_currentMedicDisplacementGrenadeTarget;

//---------------------------------------------------------------------------------------------
bool MedicHealingBeam (int player, unit aiUnit, unitgroup scanGroup) {
   unit healTarget;
   order toCast;

   // If we aren't casting
   if (!UnitHasBehavior2(aiUnit, c_MedicCastHealingBeamBehavior)) {
       g_currentMedicBeamTarget[player] = null;
       toCast = StormHeroAICreateOrder(player, c_AB_MedicHealingBeam, 0);
   }
   else {
       // We are casting.
       toCast = StormHeroAICreateOrder(player, c_AB_MedicRedirectHealingBeam, 0);
   }

   if (!UnitOrderIsValid(aiUnit, toCast)) {
       return false;
   }

   healTarget = FindBestHealTarget(player, aiUnit, c_MedicHealRange, true, true);

   if (!UnitIsValid(healTarget)) {
       return false;
   }

   // If we dont have a target, heal regardless of mana.  We are a healer, afterall.
   if (!UnitIsAlive(g_currentMedicBeamTarget[player])) {
       g_currentMedicBeamTarget[player] = healTarget;
       return HeroIssueOrder(player, aiUnit, toCast, null, c_orderQueueAddToFront, healTarget, null);
   }

   // If the best target to heal is my current target, see if he still even should be healed
   if (g_currentMedicBeamTarget[player] == healTarget) {
       // If we dont have bioshield, stop at 100% health, otherwise keep healing!
       if (!PlayerHasTalent(player, c_MedicBioshieldTalent)
           && UnitGetPropertyFixed(healTarget, c_unitPropLifePercent, c_unitPropCurrent) == 100.0) {
           // Cast on self to cancel, this guy doesnt need anymore healing for the moment.
           return HeroIssueOrder(player, aiUnit, toCast, null, c_orderQueueAddToFront, aiUnit, null);
       }
   }
   else {
       // we don't have the same target, redirect the healing beam to the new target
       g_currentMedicBeamTarget[player] = healTarget;
       return HeroIssueOrder(player, aiUnit, toCast, null, c_orderQueueAddToFront, healTarget, null);
   }

    return false;

}

//---------------------------------------------------------------------------------------------
bool MedicSafeguard (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    unit toSave;

    spellOrd = StormHeroAICreateOrder(player, c_AB_MedicSafeguard, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // Be selfish first, I cant heal if Im dead
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroLowHealthPercent
        && HaveBeenAttackedRecently(aiUnit)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, aiUnit, null);
    }
    // Exclude self because I check first above.
    toSave = FindBestHealTarget(player, aiUnit, c_MedicHealRange, c_Storm_AI_AllowAnyHealing, true);
    if (!UnitIsValid(toSave)) {
        return false;
    }

    // Only cast if he's been recently attacked.
    if (HaveBeenAttackedRecently(toSave)
        && UnitGetPropertyFixed(toSave, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroHighHealthPercent) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, toSave, null);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool MedicDisplacementGrenade (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    unitgroup enemyHeroes;
    unit enemyUnit;
    int totalEnemyCount;
    int enemyIndex;
    unit healTarget;

    spellOrd = StormHeroAICreateOrder(player, c_AB_MedicDisplacementGrenade, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // save heal target
    // not sure if we want to do this? we could be knocking the target of our heal target
    // away which can sometimes be unwanted? might need rework - kgu
    healTarget = FindBestHealTarget(player, aiUnit, c_MedicDisplacementGrenadeRange, false, false);
    if (healTarget != null && HaveBeenAttackedRecently(healTarget)) {
        enemyUnit = AILastAttacker(healTarget);
        if (UnitIsAlive(enemyUnit)
         && !libAIAI_gf_HeroAIIsPointInAOEDangerousToFaction(UnitGetPosition(enemyUnit), libAIAI_gv_aIHeroAvoidAOEAvoidExtraDistance, GetOpposingFaction(libGame_gv_players[player].lv_faction))) {
            // set our target variable, and enable our grenade think trigger
            g_currentMedicDisplacementGrenadeTarget[player] = enemyUnit;
            TriggerEnable(libGDHL_gt_HeroMedicAIDisplacementGrenadeThink, true);
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, enemyUnit, null);
        }
    }

    // Prefer healing over damage.
    if (UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroLowEnergyPercent) {
        return false;
    }

    // If heroes are grouping
    enemyHeroes = UnitsInArea(UnitGroupFilterHeroes(scanGroup), UnitGetPosition(aiUnit), c_MedicDisplacementGrenadeRange);
    totalEnemyCount = UnitGroupCount(enemyHeroes, c_unitCountAll);
    for (enemyIndex = 1; enemyIndex <= totalEnemyCount; enemyIndex += 1) {
        enemyUnit = UnitGroupUnit(enemyHeroes, enemyIndex);
        if (!UnitIsValid(enemyUnit)) {
            continue;
        }

        if (CountEnemiesInArea(scanGroup, UnitGetPosition(enemyUnit), c_MedicDisplacementGrenadeRadius, 1, 1) >= 3
         && !libAIAI_gf_HeroAIIsPointInAOEDangerousToFaction(UnitGetPosition(enemyUnit), libAIAI_gv_aIHeroAvoidAOEAvoidExtraDistance, GetOpposingFaction(libGame_gv_players[player].lv_faction))) {
            // set our target variable, and enable our grenade think trigger
            g_currentMedicDisplacementGrenadeTarget[player] = enemyUnit;
            TriggerEnable(libGDHL_gt_HeroMedicAIDisplacementGrenadeThink, true);
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, enemyUnit, null);
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool MedicStimDrone (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    int allyCount;
    int iterIndex;
    int targetUnitOwner;
    unit targetUnit;
    unitgroup nearbyAllies;


    spellOrd = StormHeroAICreateOrder(player, c_AB_MedicStimDrone, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // if there are more than 3 enemies near me and i have at least two allies.
    nearbyAllies = libAIAI_gf_AIGetAllyHeroesInRegion(player, RegionCircle(UnitGetPosition(aiUnit), 10.0));
    allyCount = UnitGroupCount(nearbyAllies, c_unitCountAll);

    if (allyCount < 2
        || CountEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), 10.0, 1, 0) < 2) {
        return false;
    }

    // Damage dealers first
    for (iterIndex = 1; iterIndex <= allyCount; iterIndex += 1) {
        targetUnit = UnitGroupUnit(nearbyAllies, iterIndex);
        targetUnitOwner = UnitGetOwner(targetUnit);
        if (libGame_gv_players[targetUnitOwner].lv_heroData.lv_class == c_heroRoleDamage) {
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetUnit, null);
        }
    }

    // Warriors next
    for (iterIndex = 1; iterIndex <= allyCount; iterIndex += 1) {
        targetUnit = UnitGroupUnit(nearbyAllies, iterIndex);
        targetUnitOwner = UnitGetOwner(targetUnit);
        if (libGame_gv_players[targetUnitOwner].lv_heroData.lv_class == c_heroRoleWarrior) {
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetUnit, null);
        }
    }

    // Then specialists
    for (iterIndex = 1; iterIndex <= allyCount; iterIndex += 1) {
        targetUnit = UnitGroupUnit(nearbyAllies, iterIndex);
        targetUnitOwner = UnitGetOwner(targetUnit);
        if (libGame_gv_players[targetUnitOwner].lv_heroData.lv_class == c_heroRoleSpecialist) {
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, targetUnit, null);
        }
    }

    // Don't cast on supports.
    return false;
}

//---------------------------------------------------------------------------------------------
bool MedicSummonMedivacTransport (int player, unit aiUnit, unitgroup scanGroup) {

    int numVisibleEnemies;
    int enemyHeroIndex;
    fixed enemyDistanceSquared;
    order spellOrd;
    point movePos;
    point enemyPos;
    unit enemyHero;
    unitgroup enemyScanGroup;

    spellOrd = StormHeroAICreateOrder(player, c_AB_MedicMedivacDropship, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)
        || OrderGetAbilityCommand(UnitOrder(aiUnit, 0)) == AbilityCommand(c_AB_MedicMedivacDropship, 0)) {
        return false;
    }

    numVisibleEnemies = UnitGroupCount(libAIAI_gv_aIHeroes[player].lv_visibleEnemyHeroes, c_unitCountAll);
    if (numVisibleEnemies >= 4) {
        for (enemyHeroIndex = 1; enemyHeroIndex <= numVisibleEnemies; enemyHeroIndex += 1) {
            // Center the region circle on the current unit, if within that circle there are 3 enemies, we cast.
            enemyHero = UnitGroupUnit(libAIAI_gv_aIHeroes[player].lv_visibleEnemyHeroes, enemyHeroIndex);
            enemyPos = UnitGetPosition(enemyHero);
            enemyDistanceSquared = DistanceSquaredBetweenPoints(UnitGetPosition(aiUnit), enemyPos);

            // Only continue considering this enemy if they are at least 50 units away. It looks very weird to
            // have the medic go in at 25 units.
            if (enemyDistanceSquared <= (30.0 * 30.0)) {
                continue;
            }

            enemyScanGroup = UnitGroupSearch(null, UnitGetOwner(enemyHero), UnitGetPosition(enemyHero), 7.0, UnitFilter((1 << c_targetFilterVisible) | (1 << c_targetFilterEnemy), 0, 0, 0), c_noMaxCount);

            // We check at 1000.0 range squared because we are ok walking a little bit.
            if (ShouldEnterTeamfight(player, enemyPos, enemyScanGroup, c_Storm_AI_AnyWinningCondition, c_Storm_AI_LosingTeamfight)
                && enemyDistanceSquared <= (100.0 * 100.0)) {
                // Go in, but dont check min distance because that will just be invalid so we can let it go invalid.
                movePos = enemyPos;
                break;
            }
        }
    }

    if (movePos != null) {
        libAIAI_gf_HeroAILeaveCurrentObjective(player);
        OrderSetTargetPoint(spellOrd, movePos);
        UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
        HeroClaimForTactical(player, 8.0, false);
        return true;
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool MedicSearchForDropshipOpportunities (int player, unit aiUnit, unitgroup scanGroup) {
   // TimerGetRemaining(libGame_gv_players[lv_playerIndex].lv_respawnTimer) <= 0.0)
   // libGame_gv_players[lp_trigPlayer].lv_isDead == true)
    // libGame_gv_players[lv_i].lv_faction == libGame_gv_players[lp_player].lv_faction) && (libGame_gv_players[lv_i].lv_isDead == true)
    int playerIndex;
    int deadCount = 0;
    fixed timeToBackThreshold = 7.5;
    // Dont do this if she's healing and helping someone OR if the order isn't valid.
    if (UnitHasBehavior2(aiUnit, c_MedicCastHealingBeamBehavior)
        || UnitOrderIsValid(aiUnit, StormHeroAICreateOrder(player, c_AB_MedicMedivacDropship, 0))) {
        return false;
    }

    for (playerIndex = 0; playerIndex <= libCore_gv_bALMaxPlayers + 1; playerIndex += 1) {
        if ((libGame_gv_players[playerIndex].lv_faction == libGame_gv_players[player].lv_faction
            && (libGame_gv_players[playerIndex].lv_isDead == true)
            && (TimerGetRemaining(libGame_gv_players[playerIndex].lv_respawnTimer) <= timeToBackThreshold))) {
            deadCount += 1;
        }
    }

    if (deadCount >= 2) {
        // we want to return to base
        libAIAI_gv_aIHeroes[player].lv_wantsToGoHome = true;
        return true;
    }
    return false;
}

void AIThinkMedic (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    MedicHealingBeam(player, aiUnit, scanGroup);

    if (MedicSafeguard(player, aiUnit, scanGroup)) {
        return;
    }

    if (MedicDisplacementGrenade(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && MedicSearchForDropshipOpportunities(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && MedicSummonMedivacTransport(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && MedicStimDrone(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}

//---------------------------------------------------------------------------------------------
// Dropship AI Think
//---------------------------------------------------------------------------------------------
void AIThinkMedivacDropship (int player, unit aiUnit, unitgroup scanGroup) {
    order departOrder;
    // If we should skip for normal reasons OR we are not accepting passengers,
    // we shouldn't consider departure orders
    if (HeroSkipTactical(player, aiUnit)
        || !UnitHasBehavior2(aiUnit, c_MedicDropshipAcceptingPassengers)) {
        return;
    }

    departOrder = StormHeroAICreateOrder(player, c_AB_MedicMedivacDropshipDepart, 0);
    if (!UnitOrderIsValid(aiUnit, departOrder)) {
        return;
    }

    // Simple first pass, if my health is low or there is no one within range of a region circle at 20 units radius, depart.
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroMediumHealthPercent
        || !AnyAllyHeroUnitsInArea(player, UnitGetPosition(aiUnit), 20.0)) {
        UnitIssueOrder(aiUnit, departOrder, c_orderQueueAddToFront);
        return;
    }
}