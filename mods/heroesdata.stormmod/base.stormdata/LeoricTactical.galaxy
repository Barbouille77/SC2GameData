//---------------------------------------------------------------------------------------------
// Leoric Tactical
//---------------------------------------------------------------------------------------------
const string c_AB_LeoricDrainHope                       = "LeoricDrainHope";
const string c_AB_LeoricSkeletalSwingTargetedReady      = "LeoricSkeletalSwingTargetedReady";
const string c_AB_LeoricWraithWalk                      = "LeoricWraithWalk";
const string c_AB_LeoricEntomb                          = "LeoricEntomb";
const string c_AB_LeoricMarchoftheBlackKing             = "LeoricMarchoftheBlackKing";
const string c_AB_LeoricGhastlySwing                    = "LeoricGhastlySwing";
const string c_AB_LeoricDrainEssence                    = "LeoricDrainEssence";
const string c_AB_LeoricOsseinRenewal                   = "LeoricOsseinRenewal";
const string c_AB_TalentHardenedShield                  = "TalentHardenedShield";
const string c_AB_LeoricCancelWraithWalk                = "LeoricCancelWraithWalk";

//---------------------------------------------------------------------------------------------
bool LeoricDrainHope (int player, unit aiUnit, unitgroup scanGroup) {
    // Skill-shot, single target
    order attackOrd;
    order spellOrd = StormHeroAICreateOrder(player, c_AB_LeoricDrainHope, 0);
    unit targetEnemy;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    fixed life = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    fixed healthReq;
    Storm_AI_TargetQueryOptions query;

    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (life > libAIAI_gv_aIHeroHighHealthPercent) {
        // not much point doing a drain life spell, but if it will finish off the enemy, then it is worth it
        healthReq = 30.0;
    }
    else if (life < libAIAI_gv_aIHeroMediumHealthPercent) {
        // if we need healing, attack anyone with this spell because it heals us
        healthReq = 100.0;
    }
    else if (energy > libAIAI_gv_aIHeroMediumEnergyPercent) {
        // if we have plenty of energy, attack almost anyone
        healthReq = libAIAI_gv_aIHeroHighHealthPercent;
    }
    else {
        // low energy, moderate health, only use on enemies close to death 
        healthReq = 40.0;
    }

    // Shoot any nearby enemy if there is a clear shot (we use a shorter range than what is possible because we want a chance to stay near them)
    query.lv_maxDistance = 7;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;   
    query.lv_maxHealthPercent = healthReq;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    targetEnemy = FindBestHero (scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        attackOrd = null;
    }

    if (HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueReplace, null, UnitGetPosition(targetEnemy))) {
        HeroFocusOnHero(player, targetEnemy);
        return true;
    }
    return false;
}

//---------------------------------------------------------------------------------------------
bool LeoricSkeletalSwingTargetedReady (int player, unit aiUnit, unitgroup scanGroup) {
    // damages and slows enemies in a hemisphere in front
    order spellOrd;
    unit targetHero;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    point inFrontofHero;
    fixed minEnemyEval;
    fixed minHeroEval;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_LeoricSkeletalSwingTargetedReady, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
  
    // Cast on a weak enemy hero
    query.lv_maxDistance = 5;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;   
    query.lv_maxHealthPercent = 40;
    targetHero = FindBestHero (scanGroup, aiUnit, query);
  
    if (UnitIsValid(targetHero)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetHero));
    }

    // Cast on a group of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minEnemyEval = 2;
    }
    else if (energy > libAIAI_gv_aIHeroLowEnergyPercent) {
        minEnemyEval = 4;
    }
    else {
        minEnemyEval = 8;
    }
    minHeroEval = minEnemyEval/2;
    // TODO: we need to be able to count enemies in arbitrary geometric shapes. Ideally we could query the spell for a list of potential targets.
    // TODO: we need to be able to find clusters of enemies in any direction, not just in front of the AI.
    inFrontofHero = PointWithOffsetPolar(UnitGetPosition(aiUnit), 2.0, UnitGetFacing(aiUnit));

    if (!EnoughEnemiesInArea(scanGroup, inFrontofHero, 2.2, minHeroEval, minEnemyEval, minEnemyEval)) {
        return false;
    }
    
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, inFrontofHero);
}

//---------------------------------------------------------------------------------------------
bool LeoricWraithWalk (int player, unit aiUnit, unitgroup scanGroup) {
    // can be used to escape faster
    order spellOrd;
    point inFrontofHero;
    fixed lifePercent = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);

    spellOrd = StormHeroAICreateOrder(player, c_AB_LeoricWraithWalk, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSFocusHero && lifePercent >= libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        if (UnitIsAlive(libAIAI_gv_aIHeroes[player].lv_targetHero)) {
            // only bother using wraithwalk if the target is more than 4 units away.
            if (DistanceSquaredBetweenPoints(UnitGetPosition(libAIAI_gv_aIHeroes[player].lv_targetHero), UnitGetPosition(aiUnit)) > 16.0) {
                return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
            }
        }
    }

    // If we are low on health but not extremely low health, and retreating, we should consider using the Wraith Walk to retreat
    if (lifePercent < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth && lifePercent > 10.0) {
        if (libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSReturnToSpawn || libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSRetreat || libAIAI_gv_aIHeroes[player].lv_heroState == libAIAI_ge_HeroAIStates_HSFleeInJungle) {
            // Especially if slowed or if there is an enemy hero blocking our retreat
            // This can't be used properly if we are on the wrong side of a gate because currently the AI pathing won't go through the gate. This is rare situation though.
            inFrontofHero = PointWithOffsetPolar(UnitGetPosition(aiUnit), 1.5, UnitGetFacing(aiUnit));
            if (UnitBehaviorCount(aiUnit, "SlowedCC") > 0 || CountEnemiesInArea(scanGroup, inFrontofHero, 1.5, 1, 0) > 0) {
                return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
            }
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
// This is not to be called from tactical because it is too infrequent, but from a special state that Leoric goes into when using Wraith Walk.
bool LeoricCancelWraithWalk (int player) {
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_LeoricCancelWraithWalk, 0);
    if (!UnitOrderIsValid(libGame_gv_players[player].lv_heroUnit, spellOrd)) {
        return false;
    }

    return HeroIssueOrder(player, libGame_gv_players[player].lv_heroUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool LeoricEntomb (int player, unit aiUnit, unitgroup scanGroup) {
    // trap enemies in front of player and smash them
    order spellOrd;
    order attackOrd;
    unit targetHero;
    fixed life = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);
    point inFrontofHero;
    fixed minEnemyEval;
    Storm_AI_TargetQueryOptions query;

    if (life < libAIAI_gv_aIHeroes[player].lv_startOffensiveHealth) {
        return false;
    }

    spellOrd = StormHeroAICreateOrder(player, c_AB_LeoricEntomb, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
  
    attackOrd = StormHeroAICreateOrder(player, c_Storm_AB_Attack, 0);
    if (!UnitOrderIsValid(aiUnit, attackOrd)) {
        attackOrd = null;
    }

    // Cast on enemy hero
    query.lv_maxDistance = 6.5;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;   
    query.lv_maxHealthPercent = 80;
    targetHero = FindBestHero (scanGroup, aiUnit, query);

    if (UnitIsValid(targetHero)) {
        if (HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueReplace, null, UnitGetPosition(targetHero))) {
            HeroFocusOnHero(player, targetHero);
            return true;
        }
        return false;
    }
    
    // Cast on a group of enemies
    minEnemyEval = 8;

    // TODO: we need to be able to count enemies in arbitrary geometric shapes. Ideally we could query the spell for a list of potential targets.
    // TODO: we need to be able to find clusters of enemies in any direction, not just in front of the AI.
    inFrontofHero = PointWithOffsetPolar(UnitGetPosition(aiUnit), 3.5, UnitGetFacing(aiUnit));
    if (!EnoughEnemiesInArea(scanGroup, inFrontofHero, 2.5, c_Storm_AI_AtLeast2Heroes, minEnemyEval, minEnemyEval)) {
        return false;
    }
    
    return HeroIssueOrder(player, aiUnit, spellOrd, attackOrd, c_orderQueueReplace, null, inFrontofHero);
}

//---------------------------------------------------------------------------------------------
bool LeoricMarchoftheBlackKing (int player, unit aiUnit, unitgroup scanGroup) {
    // 3 damaging swings in an area ahead of the player
    order spellOrd;
    unit targetHero;
    fixed energy = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    point inFrontofHero;
    fixed minEnemyEval;
    fixed minHeroEval;
    Storm_AI_TargetQueryOptions query;

    //only activate if there a team fight nearby
    if (!TeamFightInArea(player, scanGroup, UnitGetPosition(aiUnit), 8.0)) {
        return false;
    }
    
    spellOrd = StormHeroAICreateOrder(player, c_AB_LeoricMarchoftheBlackKing, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
  
    // Cast on a enemy hero
    query.lv_maxDistance = 6;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;   
    query.lv_maxHealthPercent = 100;
    targetHero = FindBestHero (scanGroup, aiUnit, query);

    if (UnitIsValid(targetHero)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetHero));
    }

    // Cast on a group of enemies
    if (energy > libAIAI_gv_aIHeroHighEnergyPercent) {
        minEnemyEval = 4;
    }
    else if (energy > libAIAI_gv_aIHeroMediumEnergyPercent) {
        minEnemyEval = 6;
    }
    else {
        minEnemyEval = 8;
    }
    minHeroEval = minEnemyEval/2;
    // TODO: we need to be able to count enemies in arbitrary geometric shapes. Ideally we could query the spell for a list of potential targets.
    // TODO: we need to be able to find clusters of enemies in any direction, not just in front of the AI.
    inFrontofHero = PointWithOffsetPolar(UnitGetPosition(aiUnit), 3.0, UnitGetFacing(aiUnit));
    if (!EnoughEnemiesInArea(scanGroup, inFrontofHero, 4, minHeroEval, minEnemyEval, minEnemyEval)) {
        return false;
    }
    
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, inFrontofHero);
}

//---------------------------------------------------------------------------------------------
bool LeoricGhastlySwing (int player, unit aiUnit, unitgroup scanGroup) {
    // slows enemies in a hemisphere in front
    order spellOrd;
    unit targetHero;
    point inFrontofHero;
    fixed minEnemyEval;
    Storm_AI_TargetQueryOptions query;

    // we can only use while dead
    if(libGame_gv_players[player].lv_isDead == false) {
        return false;
    }

    spellOrd = StormHeroAICreateOrder(player, c_AB_LeoricGhastlySwing, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
  
    // Cast on an enemy hero
    query.lv_maxDistance = 4;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;   
    query.lv_maxHealthPercent = 100;
    targetHero = FindBestHero (scanGroup, aiUnit, query);

    if (UnitIsValid(targetHero)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(targetHero));
    }

    // Cast on a group of enemies

    // TODO: we need to be able to count enemies in arbitrary geometric shapes. Ideally we could query the spell for a list of potential targets.
    // TODO: we need to be able to find clusters of enemies in any direction, not just in front of the AI.
    minEnemyEval = 3;
    inFrontofHero = PointWithOffsetPolar(UnitGetPosition(aiUnit), 2.0, UnitGetFacing(aiUnit));
    if (!EnoughEnemiesInArea(scanGroup, inFrontofHero, 2.2, c_Storm_AI_AtLeast1Hero, minEnemyEval, minEnemyEval)) {
        return false;
    }
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, inFrontofHero);
}

//---------------------------------------------------------------------------------------------
bool LeoricDrainEssence (int player, unit aiUnit, unitgroup scanGroup) {
    // Skill-shot, single target
    order spellOrd;
    order moveOrd;
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    // we can only use while dead
    if(libGame_gv_players[player].lv_isDead == false) {
        return false;
    }

    spellOrd = StormHeroAICreateOrder(player, c_AB_LeoricDrainEssence, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
  
    moveOrd = StormHeroAICreateOrder(player, c_Storm_AB_Move, 0);
    if (!UnitOrderIsValid(aiUnit, moveOrd)) {
        moveOrd = null;
    }

    // Shoot any nearby hero if there is a clear shot
    query.lv_maxDistance = 7;
    query.lv_healthFactor  = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_PreferCloserTargets;
    query.lv_lineOfSightRequired = c_Storm_AI_LOS_Required;
    targetEnemy = FindBestHero (scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, moveOrd, c_orderQueueReplace, null, UnitGetPosition(targetEnemy));
}

//---------------------------------------------------------------------------------------------
bool LeoricOsseinRenewal (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    int itemIdx = 1;
    unit invItem;
    string itemType;

    fixed life = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);

    if (life > 80.0) {
        return false;
    }

    if (UnitTestState(aiUnit, c_unitStateHallucination)) {
        return false;
    }

    spellOrd = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemInstant);

    while (itemIdx <= libCore_gv_bALPlayerActiveInventorySlots) {
        invItem = UnitInventoryItem(aiUnit, itemIdx);        
        itemIdx = itemIdx + 1;

        if (!UnitIsValid(invItem)) {
            continue;
        }

        OrderSetTargetItem(spellOrd, invItem);

        if (!UnitOrderIsValid(aiUnit, spellOrd)) {
            continue;
        }

        itemType = UnitGetType(invItem);           
        
        if (itemType == c_AB_LeoricOsseinRenewal) {
            UnitIssueOrder(aiUnit, spellOrd, c_orderQueueAddToFront);
            return true;
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool LeoricHardenedShield (int player, unit aiUnit, unitgroup scanGroup) {
    // only use if not dead and been attacked recently
    order spellOrd;
    int itemIdx = 1;
    unit invItem;
    string itemType;
    fixed life = UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent);

    // we take no damage when dead, so using a shield makes no sense
    if (libGame_gv_players[player].lv_isDead == true) {
        return false;
    }

    // we should save the shield for when we are under attack
    if (!HaveBeenAttackedRecently(aiUnit)) {
        return false;
    }

    // we should save the shield for when we have lost some health
    if (life > libAIAI_gv_aIHeroHighHealthPercent) {
        return false;
    }

    if (UnitTestState(aiUnit, c_unitStateHallucination)) {
        return false;
    }

    spellOrd = StormHeroAICreateOrder(player, c_AB_UseItem, c_abilInventoryCmdItemInstant);

    while (itemIdx <= libCore_gv_bALPlayerActiveInventorySlots) {
        invItem = UnitInventoryItem(aiUnit, itemIdx);        
        itemIdx = itemIdx + 1;

        if (!UnitIsValid(invItem)) {
            continue;
        }

        OrderSetTargetItem(spellOrd, invItem);

        if (!UnitOrderIsValid(aiUnit, spellOrd)) {
            continue;
        }

        itemType = UnitGetType(invItem);           
        
        if (itemType == c_AB_TalentHardenedShield) {
            UnitIssueOrder(aiUnit, spellOrd, c_orderQueueAddToFront);
            return true;
        }
    }

    return false;
}

//---------------------------------------------------------------------------------------------
void AIThinkLeoric (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (LeoricHardenedShield(player, aiUnit, scanGroup)) {
        return;
    }

    if (LeoricOsseinRenewal(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (LeoricDrainHope(player, aiUnit, scanGroup)) {
        return;
    }

    if (LeoricSkeletalSwingTargetedReady(player, aiUnit, scanGroup)) {
        return;
    }

    if (LeoricWraithWalk(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && LeoricEntomb(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && LeoricMarchoftheBlackKing(player, aiUnit, scanGroup)) {
        return;
    }
    
    if (LeoricGhastlySwing(player, aiUnit, scanGroup)) {
        return;
    }

    if (LeoricDrainEssence(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}
