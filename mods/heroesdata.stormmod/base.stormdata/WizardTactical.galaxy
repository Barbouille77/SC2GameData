//---------------------------------------------------------------------------------------------
// Wizard Tactical
//---------------------------------------------------------------------------------------------

// Abilities
const string c_AB_MagicMissiles      = "WizardMagicMissiles";
const string c_AB_ArcaneOrb          = "WizardArcaneOrb";
const string c_AB_Teleport           = "WizardTeleport";
const string c_AB_Disintegrate       = "WizardDisintegrate";
const string c_AB_ArchonDisintegrate = "WizardArchonPurePowerDisintegrate";
const string c_AB_DisintegrateCancel = "WizardDisintegrateCancel";
const string c_AB_ArchonBeamCancel   = "WizardArchonPurePowerDisintegrateCancel";
const string c_AB_WaveOfForce        = "WizardWaveOfForce";
const string c_FreeTeleportBehavior  = "WizardAetherWalker";

// Radii
const fixed c_MagicMissilesRange     = 12.0;
const fixed c_ArcaneOrbRange         = 15.0;
const fixed c_ArcaneOrbMaxRadius     = 2.5;
const fixed c_TeleportRange          = 4.0;
const fixed c_DisintegrateRange      = 16.0;
const fixed c_WaveOfForceRange       = 9.0;
const fixed c_WaveOfForceRadius      = 4.0;
const fixed c_TeleportCalamityRadius = 3.0;
const fixed c_DisintegrateInitRange  = c_DisintegrateRange * .75;

// Behaviors and talents
const string c_WizardDisintegrateBehavior = "WizardDisintegrateController";
const string c_CalamityTalent = "WizardTeleportCalamityTalent";
const string c_ArchonActiveBehavior = "WizardArchonPurePowerBuff";
const string c_ArchonLaserActive = "WizardArchonPurePowerDisintegrateActive";
const string c_AetherWalkerTalent = "WizardAetherWalker";

// Cast Times
const fixed c_WizardDisintegrateTime = 2.5;
const fixed c_WizardArchonDuration = 12.0;

// Talents
const string c_WizardArchonTalent = "WizardArchonPurePowerItem";

// Prototype for Leaving archon
bool WizardLeaveArchonCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff);

//-------------------------------------------------------------------------------------------------
bool WizardMagicMissiles (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit potentialTarget;
    fixed percentMana;

    spellOrd = StormHeroAICreateOrder(player, c_AB_MagicMissiles, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    percentMana = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    if (percentMana <= libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }

    query.lv_maxDistance = c_MagicMissilesRange; 
    query.lv_lineOfSightRequired = true;
    potentialTarget = FindBestHero(scanGroup, aiUnit, query);

    // We check if the target is within range of us, if so we target that point
    // If they arent in range, we can try to snipe.
    if (!UnitIsValid(potentialTarget)) {

        if (percentMana < libAIAI_gv_aIHeroMediumEnergyPercent) {
            return false;
        }

        query.lv_maxHealthPercent = 100.0;
        // He must be within range, get his position and cast to that point
        potentialTarget = FindBestMinion(scanGroup, aiUnit, query);

        if (!UnitIsValid(potentialTarget)) {
            return false;
        }
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(potentialTarget));
}

//-------------------------------------------------------------------------------------------------
bool WizardArcaneOrb (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    fixed percentMana;
    unit potentialTarget;
    point targetPos;

    spellOrd = StormHeroAICreateOrder(player, c_AB_ArcaneOrb, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    percentMana = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    query.lv_maxDistance = c_ArcaneOrbRange;
    query.lv_distanceFactor = c_Storm_AI_PreferDistantTargets;
    query.lv_lineOfSightRequired = true;

    if (percentMana <= libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
        potentialTarget = FindBestHero(scanGroup, aiUnit, query);
    }
    else {
        potentialTarget = FindBestTacticalTarget(scanGroup, aiUnit, query);
    }

    if (potentialTarget == null) {
        return false;
    }

    targetPos = UnitGetPosition(potentialTarget);
    if (!EnoughEnemiesInArea(scanGroup, targetPos, c_ArcaneOrbMaxRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        // try towers if we have the mana
        if (percentMana <= libAIAI_gv_aIHeroLowEnergyPercent) {
            return false;
        }
        potentialTarget = FindClosestWeakTowerOrCore(scanGroup, player, aiUnit, 0.0, c_ArcaneOrbRange, 100.0, -1, -1, false);
        if (potentialTarget == null) {
            return false;
        }
        targetPos = UnitGetPosition(potentialTarget);
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
}

//-------------------------------------------------------------------------------------------------
bool WizardTeleport (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    point targetPoint;
    unit potentialTarget;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_Teleport, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    targetPoint = PointWithOffsetPolar(UnitGetPosition(aiUnit), c_TeleportRange, UnitGetFacing(aiUnit));
    if (targetPoint == null
        || !PointPathingPassable(targetPoint)) {
        return false;
    }

    // We save ourselves first
    if (HaveBeenAttackedRecently(aiUnit)
        && UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPoint);
    }


    if (PlayerHasTalent(player, c_CalamityTalent)) {
        // We try to kill people next, only low targets because its risky
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroLowHealthPercent;
        query.lv_maxDistance = c_TeleportRange;
        potentialTarget = FindBestHero(scanGroup, aiUnit, query);

        // EnoughEnemies check to make sure we dont dive into a dogpile 
        if (UnitIsValid(potentialTarget)
            && !RequiredEnemyPlayerCountInArea(3, scanGroup, UnitGetPosition(potentialTarget), c_TeleportCalamityRadius)) {
            return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(potentialTarget));
        }
    }
   
    // Do we have a free teleport and there are no enemies nearby 
    if (PlayerHasTalent(player, c_AetherWalkerTalent) && !AnyEnemiesInArea(scanGroup, targetPoint, 10.0)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPoint);
    }

    return false;
}

//-------------------------------------------------------------------------------------------------
unit GetTargetForDisintegrateArchon (int player, unit aiUnit, unitgroup scanGroup) {
    unit targetEnemy;
    Storm_AI_TargetQueryOptions query;

    // We only start casting for heroes and we dont if we're low on health.
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return null;
    }

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), c_DisintegrateRange, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        return null;
    }

    // Lower disintegrate range to increase the chance of 
    // it hitting for more of its duration
    query.lv_maxDistance = c_DisintegrateRange; // TODO: should this be c_DisintegrateInitRange ?
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    targetEnemy = FindBestTacticalTarget(scanGroup, aiUnit, query);
    if (!UnitIsValid(targetEnemy)) {
        return null;
    }

    return targetEnemy;
}

//-------------------------------------------------------------------------------------------------
bool WizardDisintegrate (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    unit targetEnemy;

    spellOrd = StormHeroAICreateOrder(player, c_AB_Disintegrate, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    targetEnemy = GetTargetForDisintegrateArchon(player, aiUnit, scanGroup);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    OrderSetTargetPoint(spellOrd, UnitGetPosition(targetEnemy));
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    // 1.25 becaues it's a bit longer than our think
    HeroClaimForTactical(player, 1.25, false);
    // Don't use HeroIssueOrder for channeling
    UnitIssueOrder(aiUnit, spellOrd, c_orderQueueReplace);
    return true;

}

//-------------------------------------------------------------------------------------------------
bool WizardDisintegrateAim (int player, unit aiUnit, unitgroup scanGroup) {
    unit targetEnemy;
    order ord;

    targetEnemy = GetTargetForDisintegrateArchon(player, aiUnit, scanGroup);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    if ((UnitHasBehavior2(aiUnit, c_ArchonLaserActive)
     || UnitHasBehavior2(aiUnit, c_WizardDisintegrateBehavior))
     && UnitUpdateChanneledOrderTarget(aiUnit, UnitGetPosition(targetEnemy))) {
        return true;
    }

    ord = StormHeroAICreateOrder(player, c_AB_ArchonDisintegrate, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        HeroReleaseFromTactical(player);
        return false;
    }

    OrderSetTargetPoint(ord, UnitGetPosition(targetEnemy));
    return UnitIssueOrder(aiUnit, ord, c_orderQueueReplace);
}

//-------------------------------------------------------------------------------------------------
bool WizardShouldFleeDisintegrate (int player, unit aiUnit, unitgroup scanGroup, bool isArchon) {
    fixed range;

    if (isArchon) {
        range = 1.5 * c_DisintegrateRange;
    }
    else {
        range = c_DisintegrateRange;
    }
    // If there are enemies too close
    if (RequiredEnemyPlayerCountInArea(2, scanGroup, UnitGetPosition(aiUnit), 4.0)) {
        return true;
    }

    // We are low health
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return true;
    }

    // Or there are no enemies at all within range of the beam
    if (!AnyHeroesInArea(scanGroup, UnitGetPosition(aiUnit), range)) {
        return true;
    }

    return false;
}

//-------------------------------------------------------------------------------------------------
void WizardDisintegrateBeamThink (int player, unit aiUnit, unitgroup scanGroup, bool archon) {
    // Update direction of disintegrate
    order cancelOrd;
    order spellOrd;
    unit target;
    bool hasArchon;

    // Before we reason about who to shoot, see if we should cancel and run
    if (WizardShouldFleeDisintegrate(player, aiUnit, scanGroup, archon)) {

        if (archon) {
            UseItem(player, aiUnit, scanGroup, WizardLeaveArchonCallback);
            return;
        } 
        else {
            cancelOrd = StormHeroAICreateOrder(player, c_AB_DisintegrateCancel, 0);
        }

        if (UnitOrderIsValid(aiUnit, cancelOrd)) {
            HeroReleaseFromTactical(player);
            UnitIssueOrder(aiUnit, cancelOrd, c_orderQueueReplace);
        }
        return;
    }

    HeroClaimForTactical(player, 1.25, false);
    // This find and kill will also work for archon
    // This could fail if the move (index 4) order fails.
    if (WizardDisintegrateAim(player, aiUnit, scanGroup)) {
        return;
    } 
}

//-------------------------------------------------------------------------------------------------
bool WizardWaveOfForce (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit saveTarget;
    unit targetEnemy;
    point leadPoint;
    point enemyPoint;
    bool enoughEnemies;

    spellOrd = StormHeroAICreateOrder(player, c_AB_WaveOfForce, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    enoughEnemies = RequiredEnemyPlayerCountInArea(2, scanGroup, UnitGetPosition(aiUnit), c_WaveOfForceRange);
    // Look to be an assassin first, then a savior.
    query.lv_maxDistance = c_WaveOfForceRange;
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_adjustScoreCallback = Storm_AI_IgnoreTargetsInAOEDangerousToThem;
    targetEnemy = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsValid(targetEnemy)) {
        return false;
    }

    if (enoughEnemies
        || UnitGetPropertyFixed(targetEnemy, c_unitPropLifePercent, c_unitPropCurrent) < 20.0) {
        enemyPoint = UnitGetPosition(targetEnemy);
        leadPoint = PointNegate(TacticalNormalize(PointSubtraction(UnitGetPosition(aiUnit), enemyPoint)));
        leadPoint = PointScaleFixed(leadPoint, (c_WaveOfForceRadius / 2));
        leadPoint = PointAddition(enemyPoint, leadPoint);
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, leadPoint);
    }

    // If Im getting focused or a teammate is low and recently attacked
    saveTarget = FindBestHealTarget(player, aiUnit, c_WaveOfForceRange, true, true);

    if (UnitIsValid(saveTarget)
        && enoughEnemies) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, UnitGetPosition(saveTarget));
    }

    return false;
}

//-------------------------------------------------------------------------------------------------
bool WizardLeaveArchonCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
   
    if (itemType == c_WizardArchonTalent 
        && !AnyHeroesInArea(scanGroup, UnitGetPosition(aiUnit), c_DisintegrateRange)) {

        if (UnitHasBehavior2(aiUnit, c_ArchonLaserActive)) {
            HeroReleaseFromTactical(player);
        }

        UnitIssueOrder(aiUnit, ordTogOff, c_orderQueueReplace);
        return true;
    }
    return false;
}

//-------------------------------------------------------------------------------------------------
bool WizardItemCallback (int player, unit aiUnit, unitgroup scanGroup, string itemType, order ord, order ordTarget, order ordTogOn, order ordTogOff) {
    unit target;

    if (itemType == c_WizardArchonTalent) {

        if (UnitHasBehavior2(aiUnit, c_ArchonActiveBehavior)) {
            return false;
        }

        target = GetTargetForDisintegrateArchon(player, aiUnit, scanGroup);
        if (!UnitIsValid(target)) {
            return false;
        }

        UnitIssueOrder(aiUnit, ordTogOn, c_orderQueueReplace);

        return true;
    }
    return false;
}

//-------------------------------------------------------------------------------------------------
void AIThinkWizard (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (UnitHasBehavior2(aiUnit, c_WizardDisintegrateBehavior)) {
        WizardDisintegrateBeamThink(player, aiUnit, scanGroup, false);
        return;
    }

    // Commented out until turning bugs are addressed and can be refactored
    if (UnitHasBehavior2(aiUnit, c_ArchonActiveBehavior)) {
        WizardDisintegrateBeamThink(player, aiUnit, scanGroup, true);
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && WizardWaveOfForce(player, aiUnit, scanGroup)) {
        return;
    }

    if (WizardMagicMissiles(player, aiUnit, scanGroup)) {
        return;
    }

    if (WizardArcaneOrb(player, aiUnit, scanGroup)) {
        return;
    }

    if (WizardTeleport(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && WizardDisintegrate(player, aiUnit, scanGroup)) {
        return;
    }

    // She only has one item which enables an ult-like ability
    // so we check for ShouldUseUltimates.
    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && UseItem(player, aiUnit, scanGroup, WizardItemCallback)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}







