//---------------------------------------------------------------------------------------------
// Greymane Tactical
//---------------------------------------------------------------------------------------------
// Abilities
const string c_AB_GreymaneGilneanCocktail = "GreymaneGilneanCocktail";
const string c_AB_GreymaneRazorSwipe = "GreymaneRazorSwipe";
const string c_AB_GreymaneInnerBeast = "GreymaneInnerBeast";
const string c_AB_GreymaneDarkflight = "GreymaneDarkflight";
const string c_AB_GreymaneDisengage = "GreymaneDisengage";
const string c_AB_GreymaneCursedBullet = "GreymaneCursedBullet";
const string c_AB_GreymaneCursedBulletLeap = "GreymaneCursedBulletLeap";
const string c_AB_GreymaneGoForTheThroat = "GreymaneGoForTheThroat";
const string c_AB_GreymaneGoForTheThroatCD = "GreymaneGoForTheThroatCDHolder";

// Radii
const fixed c_GilneanCocktailRadius          = 9.0;
const fixed c_GilneanCocktailExplosionRadius = 2.5;
const fixed c_GoForTheThroatRadius    = 7.0;
const fixed c_RazorSwipeRadius             = 4.0;
const fixed c_TransformRadius         = 6.0;
const fixed c_RangedAttackRadius      = 7.0;
const fixed c_CursedBulletRadius          = 16.0;

// Behaviors
const string c_InnerBeastBehavior = "GreymaneInnerBeast";
const string c_CursedBulletLeapBehavior = "GreymaneCursedBulletCaster";
const string c_GoForThroatBehavior = "GreymaneFreeGoForTheThroat";
const string c_GreymaneWorgenForm = "GreymaneWorgenForm";


// Unit array for all greymanes to track their Cursed Bullet target
unit[libCore_gv_bALMaxPlayers + 1] GreymaneCursedBulletTargets;

//---------------------------------------------------------------------------------------------
bool GreymaneGilneanCocktail (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    region explosionRegion;
    point potentialCenter;
    point aiPos;
    point targetPos;
    point moveVec;
    unit target;
    fixed manaLevel;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GreymaneGilneanCocktail, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    manaLevel = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferCloserTargets;
    query.lv_maxDistance = c_GilneanCocktailRadius;
    query.lv_ignoreTargetsBehindGate = true;
    query.lv_projectedTargetDistance = c_GilneanCocktailExplosionRadius;
    target = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (target == null) {
        return false;
    }

    targetPos = UnitGetPosition(target);
    aiPos = UnitGetPosition(aiUnit);

    // We move this vector behind the chosen target unit to account for splash damage
    moveVec = PointNegate(TacticalNormalize(PointSubtraction(aiPos, targetPos)));
    moveVec = PointScaleFixed(moveVec, c_GilneanCocktailExplosionRadius);
    potentialCenter = PointAddition(targetPos, moveVec);

    if (UnitGetPropertyFixed(target, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroLowHealthPercent
     || (manaLevel <= libAIAI_gv_aIHeroLowEnergyPercent && AnyHeroesInArea(scanGroup, potentialCenter, c_GilneanCocktailExplosionRadius)) 
     || EnoughEnemiesInArea(scanGroup, potentialCenter, c_GilneanCocktailExplosionRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
    }
    return false;
}

//---------------------------------------------------------------------------------------------
bool GreymaneRazorSwipe (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    unit target;
    Storm_AI_TargetQueryOptions query;
    fixed energyLevel;
    point targetPos;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GreymaneRazorSwipe, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    energyLevel = UnitGetPropertyFixed(aiUnit, c_unitPropEnergyPercent, c_unitPropCurrent);
    if (energyLevel >= libAIAI_gv_aIHeroMediumEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroHighHealthPercent;
    } 
    else if (energyLevel >= libAIAI_gv_aIHeroLowEnergyPercent) {
        query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    }
    else {
        // Not using the constant because it needs to be really low to justify this
        query.lv_maxHealthPercent = 10.0;
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = c_RazorSwipeRadius;
    query.lv_ignoreTargetsBehindGate = true;
    target = FindBestTacticalTarget(scanGroup, aiUnit, query);

    if (target == null) {
        return false;
    }
    
    targetPos = UnitGetPosition(target);

    if (EnoughEnemiesInArea(scanGroup, targetPos, c_RazorSwipeRadius / 2.0, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast2Creeps, c_Storm_AI_AtLeast3Minions)
        || UnitGetPropertyFixed(target, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroLowHealthPercent) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPos);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool GreymaneInnerBeast (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    unitgroup enemyStructures;
    unitfilter structFilter;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GreymaneInnerBeast, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    // We need to consider structures as wel as Inner Beast is a good pushing ability
    structFilter = UnitFilter((1 << c_targetFilterStructure), 0, (1 << c_targetFilterMissile), (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)));
    enemyStructures = UnitGroupAlliance(player, c_unitAllianceEnemy, RegionCircle(UnitGetPosition(aiUnit), c_RangedAttackRadius), structFilter, c_noMaxCount);

    if (!EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), c_RangedAttackRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast3Creeps, c_Storm_AI_AtLeast5Minions)
        && UnitGroupCount(enemyStructures, c_unitCountAll) < 1) {
        return false;
    }
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, null);
}

//---------------------------------------------------------------------------------------------
bool GreymaneDarkflight (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    unit target;
    Storm_AI_TargetQueryOptions query;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GreymaneDarkflight, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = c_TransformRadius;
    query.lv_ignoreTargetsBehindGate = true;
    target = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsAlive(target)) {
        return false;
    }

    // We don't go into a fight if we have low enough health to justify returning to spawn
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    if (libAIAI_gf_HeroAIDangerRatioEval(libGame_gv_players[player].lv_faction, UnitGetPosition(target), c_TransformRadius) < libAIAI_gv_aIHeroEnterCombatEvalRatio) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, target, null);
}

//---------------------------------------------------------------------------------------------
bool GreymaneDisengage (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    unitgroup farUnits;
    point targetPoint;
    int farUnitCount;
  

    spellOrd = StormHeroAICreateOrder(player, c_AB_GreymaneDisengage, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    targetPoint = PointWithOffsetPolar(UnitGetPosition(aiUnit), c_TransformRadius, UnitGetFacing(aiUnit));
    if (targetPoint == null 
        || !PointPathingPassable(targetPoint)) {
        return false;
    }
  
    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth
        || libAIAI_gf_HeroAIIsPointInAOEDangerousToFaction(UnitGetPosition(aiUnit), libAIAI_gv_aIHeroAvoidAOEAvoidExtraDistance, libGame_gv_players[player].lv_faction)) {
        // if were low health get out toward retreat point
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPoint);
    }
    
    // If we have enemies within walkable melee range, do not disengage
    if (EnoughEnemiesInArea(scanGroup, UnitGetPosition(aiUnit), c_TransformRadius, c_Storm_AI_AtLeast1Hero, c_Storm_AI_AtLeast1Creep, c_Storm_AI_AtLeast3Minions)) {
        return false;
    }

    farUnits = UnitGroupUnitsInRing(scanGroup, UnitGetPosition(aiUnit), c_RangedAttackRadius, c_RangedAttackRadius * 2.0);
    farUnitCount = UnitGroupCount(farUnits, c_unitCountAll);

    if (farUnitCount == 0) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, targetPoint);
    }

    if (farUnitCount >= 2) {            
        // This is the exception to the retreat position rule.  We go toward enemies because we have high health.
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueAddToFront, null, MovePointTowardsPoint(UnitGetPosition(aiUnit), UnitGroupCenterOfGroup(farUnits), c_TransformRadius));
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool GreymaneCursedBullet (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit target;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GreymaneCursedBullet, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }
    // We use GilneanCocktail radius here instead of the standard Cursed Bullet radius because our AI is not
    // good at hitting far targets.
    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = c_GilneanCocktailRadius;
    query.lv_maxHealthPercent = libAIAI_gv_aIHeroMediumHealthPercent;
    query.lv_ignoreTargetsBehindGate = true;
    target = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsAlive(target)) {
        return false;
    }

    if (libAIAI_gf_HeroAIDangerRatioEval(libGame_gv_players[player].lv_faction, UnitGetPosition(target), 8.0) < libAIAI_gv_aIHeroEnterCombatEvalRatio) {
        return false;
    }

    GreymaneCursedBulletTargets[player] = target;
    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, UnitGetPosition(target));
}

//---------------------------------------------------------------------------------------------
bool GreymaneCursedBulletLeap (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GreymaneCursedBulletLeap, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (!UnitIsAlive(GreymaneCursedBulletTargets[player])) {
        GreymaneCursedBulletTargets[player] = null;
        return false;
    }
    
    if (IsTargetAcrossGate(aiUnit, GreymaneCursedBulletTargets[player], scanGroup, 2.0)
        || UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    if (libAIAI_gf_HeroAIDangerRatioEval(libGame_gv_players[player].lv_faction, UnitGetPosition(GreymaneCursedBulletTargets[player]), 8.0) >= libAIAI_gv_aIHeroEnterCombatEvalRatio
        || UnitGetPropertyFixed(GreymaneCursedBulletTargets[player], c_unitPropLifePercent, c_unitPropCurrent) <= libAIAI_gv_aIHeroLowHealthPercent) {
        return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, null, null);
    }

    return false;
}

//---------------------------------------------------------------------------------------------
bool GreymaneGoForTheThroat (int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit target;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GreymaneGoForTheThroat, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    if (UnitGetPropertyFixed(aiUnit, c_unitPropLifePercent, c_unitPropCurrent) < libAIAI_gv_aIHeroes[player].lv_returnToSpawnHealth) {
        return false;
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_maxDistance = c_GoForTheThroatRadius;
    query.lv_maxHealthPercent = 40;
    query.lv_ignoreTargetsBehindGate = true;
    target = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsAlive(target)) {
        return false;
    }

    if (libAIAI_gf_HeroAIDangerRatioEval(libGame_gv_players[player].lv_faction, UnitGetPosition(target), c_GilneanCocktailRadius) < libAIAI_gv_aIHeroEnterCombatEvalRatio) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, target, null);;
}

//---------------------------------------------------------------------------------------------
bool GreymaneSecondGoForTheThroat(int player, unit aiUnit, unitgroup scanGroup) {
    order spellOrd;
    Storm_AI_TargetQueryOptions query;
    unit target;

    spellOrd = StormHeroAICreateOrder(player, c_AB_GreymaneGoForTheThroat, 0);
    if (!UnitOrderIsValid(aiUnit, spellOrd)) {
        return false;
    }

    query.lv_healthFactor = c_Storm_AI_PreferUnhealthyTargets;
    query.lv_distanceFactor = c_Storm_AI_StronglyPreferDistantTargets;
    query.lv_maxDistance = c_GoForTheThroatRadius;
    query.lv_ignoreTargetsBehindGate = true;
    target = FindBestHero(scanGroup, aiUnit, query);

    if (!UnitIsAlive(target)) {
        return false;
    }

    return HeroIssueOrder(player, aiUnit, spellOrd, null, c_orderQueueReplace, target, null);
}

void AIThinkGreymane (int player, unit aiUnit, unitgroup scanGroup) {

    if (HeroSkipTactical(player, aiUnit)) {
        return;
    }

    if (UseDefensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (HeroSkipOffensiveTactical(player, aiUnit)) {
        return;
    }

    if (UnitHasBehavior2(aiUnit, c_CursedBulletLeapBehavior) && GreymaneCursedBulletLeap(player, aiUnit, scanGroup)) {
        return;
    }

    if (UnitHasBehavior2(aiUnit, c_GoForThroatBehavior) && GreymaneSecondGoForTheThroat(player, aiUnit, scanGroup)) {
        return;
    }

    if (GreymaneDisengage(player, aiUnit, scanGroup)) {
        return;
    }

    if (!UnitHasBehavior2(aiUnit, c_InnerBeastBehavior)) {
        GreymaneInnerBeast(player, aiUnit, scanGroup);
    }
    // We don't try to darkflight AND do other abilities in one loop as the other
    // abilities will be invalid due to our current Human form.
    if (!UnitHasBehavior2(aiUnit, c_GreymaneWorgenForm) && GreymaneDarkflight(player, aiUnit, scanGroup)) {
        return;
    }

    if (GreymaneRazorSwipe(player, aiUnit, scanGroup)) {
            return;
    }

    if (GreymaneGilneanCocktail(player, aiUnit, scanGroup)) {
            return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && GreymaneCursedBullet(player, aiUnit, scanGroup)) {
        return;
    }

    if (libAIAI_gf_HeroAIShouldUseUltimates(player) && GreymaneGoForTheThroat(player, aiUnit, scanGroup)) {
        return;
    }

    if (UseOffensiveItem(player, aiUnit, scanGroup)) {
        return;
    }

    if (RevealCloakedEnemies(player, aiUnit, scanGroup)) {
        return;
    }
}