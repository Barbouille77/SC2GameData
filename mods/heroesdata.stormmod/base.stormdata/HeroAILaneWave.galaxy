const int gv_maxAvoidWaves = 15;

struct gs_AIHeroWaveData {
    int ownerPlayerIndex;
    unit waveUnit;
    int waveLaneIndex;
    fixed waveLaneMoveDir;
    fixed waveSpeed;
    fixed tailLength;
    fixed tailWidth;
};

struct gs_AIHeroLaneWaveData {
    gs_AIHeroWaveData[gv_maxAvoidWaves] avoidWaves;
    int numberOfAvoidWaves;
};

gs_AIHeroLaneWaveData[3] gv_heroAITeamLaneWaveData; // Keep track of lane wave data for each team. 

fixed HeroAIGetCoreLanePos (int teamIndex, int laneIndex) {
    unit coreUnit = libGame_gv_teams[teamIndex].lv_core;
    return libAIAI_gf_AIGetClosestLanePosition(laneIndex, UnitGetPosition(coreUnit));
}

fixed HeroAIGetApproximateWaveLanePos (
    int waveLaneIndex,
    point wavePos, 
    fixed waveLanePos, 
    fixed waveLaneDir, 
    fixed speed, 
    fixed time
) {
    // Approximate where the wave will be in time
    fixed waveDestLanePos = waveLanePos;
    point newPos = wavePos;
    point prevPos = wavePos;
    
    if (speed > 0.0) {
        while(time > 0.0) {
            waveDestLanePos += waveLaneDir;
            
            prevPos = newPos;
            newPos = AILaneWaypointGetWaypointPosWithOffset(
                waveLaneIndex, 
                FixedToInt(waveDestLanePos), 
                0.0
            );
                    
            time -= (DistanceBetweenPoints(newPos, prevPos) / speed);
        }
    }
    
    return waveDestLanePos;
}

point HeroAICalculateRetreatPosLaneWave (
    int playerIndex, 
    int teamIndex,
    int currentLane, 
    point lanePoint,
    point waveDir, 
    point waveTangentDir, 
    fixed width
) {
    const int c_maxTries = 5;
    const fixed c_posOffsetPerTry = 4.0;
    
    fixed lanePosX = PointGetX(lanePoint);
    fixed lanePosY = PointGetY(lanePoint);
    fixed waveDirX = PointGetX(waveDir);
    fixed waveDirY = PointGetY(waveDir);
    fixed waveTangentDirX = PointGetX(waveTangentDir);
    fixed waveTangentDirY = PointGetY(waveTangentDir);
    fixed tryPosX = lanePosX;
    fixed tryPosY = lanePosY;
    point tryPoint;
    int try = 0;
    int laneIndex;
    fixed bestLaneDist = -1;
    point bestLanePoint;
    fixed tryLaneDist;
    
    tryPosX += waveTangentDirX * width;
    tryPosY += waveTangentDirY * width;
    
    // Try points along waveDir axis, using waveTangentDir as an offset.
    for (try=0; try < c_maxTries; try += 1) {
        tryPoint = Point(tryPosX, tryPosY);
        
        if (PointPathingPassable(tryPoint)) {
            return tryPoint;
        }
        
        tryPosX += waveDirX * c_posOffsetPerTry;
        tryPosY += waveDirY * c_posOffsetPerTry;  
    }
    
    tryPosX = lanePosX;
    tryPosY = lanePosY;
    tryPosX += -waveTangentDirX * width;
    tryPosY += -waveTangentDirY * width;
    
    for (try=0; try < c_maxTries; try += 1) {
        tryPoint = Point(tryPosX, tryPosY);
        
        if (PointPathingPassable(tryPoint)) {
            return tryPoint;
        }
        
        tryPosX += waveDirX * c_posOffsetPerTry;
        tryPosY += waveDirY * c_posOffsetPerTry;       
    }
    
    // If we still have no escape, use a place we know is safe. 
    // Typically retreat would use the spawn point but we know that is not safe due to the wave.
    // Use the closest adjacent lane's tower pos instead.
    // 
    bestLanePoint = AILaneWaypointConvertWaydistOffsetToPoint(
        currentLane, 
        libAIAI_gv_heroAITeamData[teamIndex].lv_laneData[currentLane].lv_frontTowerPosition, 
        0.0
    );
    
    for (laneIndex = 1; laneIndex < libGame_gv_laneCount; laneIndex += 1) {
        if (laneIndex == currentLane) {
            continue;
        }
        tryPoint = AILaneWaypointConvertWaydistOffsetToPoint(
            laneIndex, 
            libAIAI_gv_heroAITeamData[teamIndex].lv_laneData[laneIndex].lv_frontTowerPosition, 
            0.0
        );
        
        tryLaneDist = DistanceBetweenPoints(tryPoint, lanePoint);
        if (bestLaneDist < 0 || tryLaneDist < bestLaneDist) {
            bestLaneDist = tryLaneDist;
            bestLanePoint = tryPoint;
        }
    }
    
    return bestLanePoint;
}

bool HeroAIEvaluateLaneWaveHelper (
    int playerIndex,
    point playerPos,
    int teamIndex,
    int waveIndex,
    bool issueOrders
) {
    unit wave = gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveUnit;
    int waveLaneIndex = gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveLaneIndex;
    fixed waveLaneMoveDir = gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveLaneMoveDir;
    fixed waveSpeed = gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveSpeed;
    fixed tailLength = gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].tailLength;
    fixed tailWidth = gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].tailWidth;
    
    int playerLaneIndex = libAIAI_gv_aIHeroes[playerIndex].lv_currentLane;
    unit playerHero = libAIAI_gf_HeroAIGetHeroOrVehicle(playerIndex);
    
    fixed playerLanePos;
    point wavePos;
    fixed waveLanePos;
    fixed waveDestLanePos;
    point laneDir;
    point laneTangent;
    int beforePlayerLanePos;
    int afterPlayerLanePos;
    point lanePointAfter;
    point lanePointBefore;
    fixed playerOffsetX;
    fixed playerOffsetY;
    fixed tangentDist;
    fixed laneDist;
    fixed expireTime;
    
    const fixed c_playerAvoidanceTime = 0.8;
    const fixed c_retreatTime = 0.5;

    fixed tailHalfWidth = tailWidth/2.0;
    
    wavePos = UnitGetPosition(wave);
    
    waveLanePos = libAIAI_gf_AIGetClosestLanePosition(waveLaneIndex, wavePos);
    playerLanePos = libAIAI_gf_AIGetClosestLanePosition(waveLaneIndex, playerPos);

    // Approximate where the wave will be in c_playerAvoidanceTime. 
    waveDestLanePos = HeroAIGetApproximateWaveLanePos(
        waveLaneIndex, 
        wavePos, 
        waveLanePos, 
        waveLaneMoveDir, 
        waveSpeed, 
        c_playerAvoidanceTime
    );
    
    // Figure out if the unit is in danger of being hit by the wave based on their lane position.
    
    // Get the lane waypoints that the player lies between.
    if (waveLaneMoveDir > 0) {
        beforePlayerLanePos = FixedToInt(playerLanePos);
        afterPlayerLanePos = FixedToInt(playerLanePos + 1.0);
    }
    else {
        beforePlayerLanePos = FixedToInt(playerLanePos + 1.0);
        afterPlayerLanePos = FixedToInt(playerLanePos);
    }
    
    if (waveLaneMoveDir > 0.0) {
        // if the wave is not going to meet the player in c_playerAvoidanceTime, ignore it. 
        if (waveDestLanePos < beforePlayerLanePos) {
            return false;
        }

        // if the wave has moved past the player, ignore it. 
        if (waveLanePos > afterPlayerLanePos) {
            // Verify we are not currently being hit by the tail. 
            if (DistanceSquaredBetweenPoints(wavePos, playerPos) > tailLength * tailLength) {
                return false;
            }
        }
    }
    else {
        // if the wave is not going to meet the player in c_playerAvoidanceTime, ignore it. 
        if (waveDestLanePos > beforePlayerLanePos) {
            return false;
        }

        // if the wave has moved past the player, ignore it. 
        if (waveLanePos < afterPlayerLanePos) {
            // Check if unit is being hit by the tail. 
            if (DistanceSquaredBetweenPoints(wavePos, playerPos) > tailLength * tailLength) {
                return false;
            }
        }
    }
    
    // we know the unit will be hit by the wave if they are in the lane and don't move. 
    
    // Figure out if unit is actually in the lane.  
    lanePointAfter = AILaneWaypointGetWaypointPosWithOffset(
        waveLaneIndex, 
        afterPlayerLanePos, 
        0.0
    );
    lanePointBefore = AILaneWaypointGetWaypointPosWithOffset(
        waveLaneIndex, 
        beforePlayerLanePos, 
        0.0
    );
    
    // Calculate lane tangent.
    laneDir = lanePointAfter - lanePointBefore;
    laneDist = DistanceBetweenPoints(laneDir, Point(0.0, 0.0));
    if (laneDist <= 0.0) {
        return false;
    }
    
    laneDir = Point(PointGetX(laneDir)/laneDist, PointGetY(laneDir)/laneDist);
    
    laneTangent = Point(PointGetY(laneDir), -PointGetX(laneDir));

    playerOffsetX = PointGetX(playerPos) - PointGetX(lanePointBefore);
    playerOffsetY = PointGetY(playerPos) - PointGetY(lanePointBefore);
    
    // Do dot product projection of offset onto tangent.
    tangentDist = playerOffsetX * PointGetX(laneTangent) + playerOffsetY * PointGetY(laneTangent); 
    
    // If the projection is less than 0, laneTangent is pointing to the side of the lane that the unit is furthest from, negate 
    // it so the unit attempts to retreat to the closest side first
    if (tangentDist < 0) {
       laneTangent = Point(-PointGetX(laneTangent), -PointGetY(laneTangent));
       
        // Since we inverted the tangent, tangentDist should only be positivie.
        tangentDist *= -1;
    }
    
    // If we are too far from the center of the wave, we are not in danger. 
    if (tangentDist > tailHalfWidth) {
        return false;
    }

    // unit is in the lane and is going to be hit by the wave.

    if (issueOrders) {
        // Figure out where the center of the lane is relative to the player
        playerPos = Point(PointGetX(playerPos) - PointGetX(laneTangent)*tangentDist, PointGetY(playerPos) - PointGetY(laneTangent)*tangentDist);
        
        // Calculate retreat position. Add a 4.0 buffer so they are not in danger of the wave.
        libAIAI_gv_aIHeroes[playerIndex].lv_laneTargetPosition = 
            HeroAICalculateRetreatPosLaneWave(playerIndex, teamIndex, waveLaneIndex, playerPos, laneDir, laneTangent, tailHalfWidth + 2.0);
        
        expireTime = TimerGetElapsed(libGame_gv_gameTimer) + c_retreatTime;
        if ((expireTime > libAIAI_gv_aIHeroes[playerIndex].lv_avoidAOETimeout)) {
            libAIAI_gv_aIHeroes[playerIndex].lv_avoidAOETimeout = expireTime;
        }

        if ((libAIAI_gv_aIHeroes[playerIndex].lv_heroState != libAIAI_ge_HeroAIStates_HSAvoidAOE)) {
            HeroAIUnitIssueOrder(
                libAIAI_gv_aIHeroes[playerIndex].lv_currentHeroUnit, 
                OrderTargetingPoint(AbilityCommand("move", 0), libAIAI_gv_aIHeroes[playerIndex].lv_laneTargetPosition), 
                c_orderQueueReplace
            );
            
            libAIAI_gf_HeroAIChangeState(playerIndex, libAIAI_ge_HeroAIStates_HSAvoidAOE);
        }
    }
    
    return true;
}

bool HeroAIAvoidLaneWave (
    int playerIndex, 
    int teamIndex,
    int waveIndex
) {
    int playerLaneIndex = libAIAI_gv_aIHeroes[playerIndex].lv_currentLane;
    unit playerHero = libAIAI_gf_HeroAIGetHeroOrVehicle(playerIndex);
    if (!UnitIsValid(playerHero)) {
        return false;
    }
    
    // if the wave is not in the same lane as the player, ignore it. 
    if (playerLaneIndex != gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveLaneIndex) {
        return false;
    }
    
    return HeroAIEvaluateLaneWaveHelper(
        playerIndex, 
        UnitGetPosition(playerHero), 
        teamIndex,
        waveIndex,
        true
    );
}

void HeroAINotifyLaneWaveStarting (
    int faction, 
    int teamIndex,
    int waveIndex
) {
    // Variable Declarations
    int playerIndex;
    
    for (playerIndex = 1; playerIndex <= libCore_gv_bALMaxPlayers; playerIndex += 1) {
        if (libAIAI_gf_HeroAIIsPlayerActive(playerIndex, 2) 
         && libGame_gv_players[playerIndex].lv_faction == faction 
         && libAIAI_gv_aIHeroDodgeAOEAbilities[libAIAI_gv_aIHeroes[playerIndex].lv_difficulty]
        ) {
            HeroAIAvoidLaneWave(playerIndex, teamIndex, waveIndex);
        }
    }
}

int HeroAIAddLaneWaveToTeam (
    int teamIndex,
    unit casterUnit, 
    unit waveUnit, 
    int waveLaneIndex, 
    int startLanePos,
    int endLanePos,
    fixed waveSpeed, 
    fixed tailLength, 
    fixed tailWidth
) {
    int newWaveIndex;
    fixed waveLaneMoveDir;
    int ownerPlayerIndex;
    
    if (gv_heroAITeamLaneWaveData[teamIndex].numberOfAvoidWaves >= gv_maxAvoidWaves) {
        return -1;
    }
    
    if (startLanePos == endLanePos) {
        return -1;
    }
    
    ownerPlayerIndex = UnitGetOwner(casterUnit);
    waveLaneMoveDir = (endLanePos - startLanePos) / AbsF(endLanePos - startLanePos);
    
    newWaveIndex = gv_heroAITeamLaneWaveData[teamIndex].numberOfAvoidWaves;
    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[newWaveIndex].ownerPlayerIndex = ownerPlayerIndex;
    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[newWaveIndex].waveUnit = waveUnit;
    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[newWaveIndex].waveLaneIndex = waveLaneIndex;
    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[newWaveIndex].waveLaneMoveDir = waveLaneMoveDir;    
    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[newWaveIndex].waveSpeed = waveSpeed;
    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[newWaveIndex].tailLength = tailLength;
    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[newWaveIndex].tailWidth = tailWidth;
        
    gv_heroAITeamLaneWaveData[teamIndex].numberOfAvoidWaves += 1;    
    
    return newWaveIndex;
}

void HeroAIAddLaneWave (
    unit casterUnit, 
    unit waveUnit, 
    int waveLaneIndex, 
    int startLanePos,
    int endLanePos,
    fixed waveSpeed, 
    fixed tailLength, 
    fixed tailWidth
) {
    int ownerPlayerIndex = UnitGetOwner(casterUnit);
    
    int orderWaveIndex = -1;
    int chaosWaveIndex = -1;
    
    if (startLanePos == endLanePos) {
        return;
    }
    
    if (ownerPlayerIndex == libCore_gv_cOMPUTER_Hostile
     || libNtve_gf_PlayerIsEnemy(ownerPlayerIndex, libCore_gv_cOMPUTER_TeamOrder, libNtve_ge_PlayerRelation_Enemy)
    ) {
        orderWaveIndex = HeroAIAddLaneWaveToTeam(0, casterUnit, waveUnit, waveLaneIndex, startLanePos, endLanePos, waveSpeed, tailLength, tailWidth);
    }

    if (ownerPlayerIndex == libCore_gv_cOMPUTER_Hostile 
     || libNtve_gf_PlayerIsEnemy(ownerPlayerIndex, libCore_gv_cOMPUTER_TeamChaos, libNtve_ge_PlayerRelation_Enemy)
    ) {
        chaosWaveIndex = HeroAIAddLaneWaveToTeam(1, casterUnit, waveUnit, waveLaneIndex, startLanePos, endLanePos, waveSpeed, tailLength, tailWidth);
    }
    
    Wait(libAIAI_gv_aIHeroAvoidAOEMinResponseTime, c_timeGame);
    
    if (orderWaveIndex != -1) {
        HeroAINotifyLaneWaveStarting(libGame_ge_Faction_Order, 0, orderWaveIndex);
    }

    if (chaosWaveIndex != -1) {
        HeroAINotifyLaneWaveStarting(libGame_ge_Faction_Chaos, 1, chaosWaveIndex);
    }
}

bool HeroAIAvoidLaneWaveLogic (int playerIndex) {
    int teamIndex = libAIAI_gf_HeroAIGetAllyTeamIndex(playerIndex);
    int waveCount;
    int waveIndex;

    // Loop over each wave and check to see if the player should avoid it. 
    waveCount = gv_heroAITeamLaneWaveData[teamIndex].numberOfAvoidWaves;
    for (waveIndex=0; waveIndex < waveCount; waveIndex += 1) {
        if (!UnitIsValid(gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveUnit)) {
            continue;
        }
        
        if (HeroAIAvoidLaneWave(playerIndex, teamIndex, waveIndex)) {
            return true;
        }
    }
    
    return false;
}

bool HeroAIPointInDangerOfLaneWave (point pos, int factionIndex) {
    int waveCount;
    int waveIndex;
    int teamIndex = libAIAI_gf_HeroAITeamIndexOfFaction(factionIndex);
 
    // Loop over each wave and check to see if the player should avoid it. 
    waveCount = gv_heroAITeamLaneWaveData[teamIndex].numberOfAvoidWaves;
    
    for (waveIndex=0; waveIndex < waveCount; waveIndex += 1) {
        if (!UnitIsValid(gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveUnit)) {
            continue;
        }
        
        if (HeroAIEvaluateLaneWaveHelper(
                0, 
                pos,
                teamIndex,
                waveIndex,
                false
            )
        ) {
            return true;
        }
    }
    
    return false;
}

void HeroAICleanupLaneWaves (int factionIndex) {
    int teamIndex = libAIAI_gf_HeroAITeamIndexOfFaction(factionIndex);
    int waveIndex = 0;
    int lastWaveIndex;
    
    // Remove any waves which have been deleted.
    while (waveIndex < gv_heroAITeamLaneWaveData[teamIndex].numberOfAvoidWaves) {
        lastWaveIndex = gv_heroAITeamLaneWaveData[teamIndex].numberOfAvoidWaves - 1;
        
        if (!UnitIsValid(gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveUnit)) {
            if (waveIndex != lastWaveIndex) {
                // switch the removed wave with the last wave.
                gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveUnit = 
                    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[lastWaveIndex].waveUnit;
                gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].ownerPlayerIndex = 
                    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[lastWaveIndex].ownerPlayerIndex;
                gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveLaneIndex = 
                    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[lastWaveIndex].waveLaneIndex;    
                gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveLaneMoveDir =
                    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[lastWaveIndex].waveLaneMoveDir;
                gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].waveSpeed = 
                    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[lastWaveIndex].waveSpeed;
                gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].tailLength = 
                    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[lastWaveIndex].tailLength;
                gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[waveIndex].tailWidth = 
                    gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[lastWaveIndex].tailWidth;
            }
            
            // Clean up any references.
            gv_heroAITeamLaneWaveData[teamIndex].avoidWaves[lastWaveIndex].waveUnit = null;
            
            gv_heroAITeamLaneWaveData[teamIndex].numberOfAvoidWaves -= 1;
        }
        else {
            waveIndex += 1;
        }
    }
}